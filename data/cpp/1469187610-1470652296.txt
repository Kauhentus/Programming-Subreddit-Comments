Please note that these questions are better suited to /r/cpp_questions To answer your question, you can't really achieve that, unless you have the Derived compare function signature on your base class. What you could also do is dynamic_cast your Base pointer to Derived and if they are both Derived instances, do your compare with the Derived pointers
Another awesome release. But what happened to UI fonts? They all are bigger now.. GDB improvements **ARE AWESOME**. Seriously before this update debugging was painfully slow to start and inspecting variables was equally as slow. Now it is basically instant, both startup and variable inspection. This is single most useful feature of this update. Too bad there still is no way to inspect memory or assembly code when debugging. Yes i know we can do it in gdb console, but whats the point in IDE then eh? ;) But you know.. No matter how great software is people will complain like me now. Thank you Jetbrains!
Thanks, yeah that's what I'm doing right now, I'll stick to that. Next time I'll ask in cpp_question :)
I saw a comment in which [nuklear](https://github.com/vurtun/nuklear) was recommended. Couldn't respond to it as it was either deleted or user got shadowbanned, yeah. o:
Have you tried looking at the dump in Windbg (aka Debugging Tools for Windows)? For whatever reason, I end up having more luck with crash dumps there than with visual studio.
It needs to be left in the header file.
Sounds like a 2-hour solution ;) Hell, if you start spending more time looking for a fix I'd just write it myself. Shouldn't waste too much time on it :)
Thanks for the feedback. Not sure, what you mean taking about UI fonts. Could you please send us some screenshots to compare, platform name and if you use bundled JDK. Feel free to submit them to our support: https://intellij-support.jetbrains.com/hc/en-us Disassemble view is a nice feature indeed. We are considering it after finishing with remote debug on Windows.
We're working hard to fix issues. The most important thing I can ask is to [enter QPs for anything you encounter](https://quality.embarcadero.com) - we can't fix what we don't know about, and you'd be surprised how common it is for users to see a bug and assume it's known. Some are, of course, and we are looking at them. If there are specific issues you want to ask we look at, you can email me too - david dot millington at embarcadero.com - I welcome all input and I can escalate an issue I know is causing trouble for someone. We have Berlin Update 1 scheduled soon too and that fixes a large number of issues.
You are correct: my code doesn't apply for _two_ optionals. In that case, I would probably still prefer an explicit if, but with two conditions: auto x1 = getoptional(); auto x2 = getotheroptional(); if(x1 &amp;&amp; x2) // .... or if(auto x1 = getoptional()) { if(auto x2 = getotheroptional()) // .... } 
Thanks!
One of _those_ people? (even with fully quoted context, it still seems condescending/superficial to me).
I just give a try with U3, fixed one problem but variadics implementation of VS are not good enough. But the good news is that VS 2016 is comming and will (hopefully) fully compile C++14 ...
True, which is why I said it was a bit funky. But it does provide the exact functionality that was asked for. Frankly if saw something like this I would tell the person that they need to go have a rethink about what they are trying to accomplish.
Cool. Let's see - I'm not so enthusiastically that it will finally compile for example range-v3. I'm pretty sure we have to wait for that a bit longer :-)
Some minor improvements, but it still chokes on template-heavy libraries like Eigen. Although my personal pet peeve is incomplete C++11 support: no support for user-defined literals (it's just a sea of syntax errors).
Very interesting, thanks
The index variable isn't being used, why not make it a while loop?
You can do that, but it doesn't allow you to support a decorator pattern. Consider the following routine: std::future&lt;void&gt; filter() { auto rv = filter2(); rv.next([] { do_more_work(); }); return rv; } 
Huh... does `string_view` not have a sized literal constructor? A la: `template &lt;size_t N&gt; string_view (const char (&amp;str) [N])` They're nice as if you are just passing around `const char *`, a linear-time string length op is required. Even `template &lt;typename T&gt; string_view (const T &amp;str)` would work (as `sizeof` returns the size of the string) though you need to validate that T is suitable for `std::string` initialization.
lol :)
For a slightly different perspective, I am looking forward to these 2 talks from CppCon: 1) Making C++ and the STL Work in the Linux / Windows Kernels https://cppcon2016.sched.org/event/7nL9/making-c-and-the-stl-work-in-the-linux-windows-kernels 2) #include &lt;os&gt;: from bootloader to REST API with the new C++ https://cppcon2016.sched.org/event/7nLe/include-ltosgt-from-bootloader-to-rest-api-with-the-new-c
&gt; No, there's no such constructor, I suspect because there's no way to distinguish between a string literal and a local array, the latter of which could too easily result in dangling references. For a `string_view`, though, a local reference is fine, as it is a reference type. The `string_view` is already capturing it by reference whether it's a literal or a local array, but presently it must calculate size using a string length op. Adding such a constructor would just let it derive the size at compile time.
&gt; Your constructor would allow this to compile: std::string_view foo() { char s[] = "str"; return s; } to compile. You do not want this to compile, as this returns an invalid pointer (i.e., effectively a dangling reference). [That compiles *now*](http://ideone.com/NMeECR). That's my point. The only thing my proposal would change is that constructing the view from a literal would be constant time instead of linear time - the view are *already* unsafe as they already just take char arrays, which can be local arrays.
What I really want is constexpr parameters.
 char a[100] = "abc"; string_view sv(a); What's `sv.size()`? 100? 99? 3?
I was pointing out that the "sized literal constructor" would likely break with something like this. I disagree that it shouldn't compile. `string_view` has reference semantics; it's a non-owning reference that might be backed by a local array or a local `std::string` or a string literal or something else. Do you want to disallow conversion from `std::string` too? 
This is completely unreadable on mobile. The table of contents covers a solid seven eighth of my screen
The table of content is retractable
Probably for spamming 
Not sure if serving over HTTP is the best idea, but https://github.com/eidheim/Simple-Web-Server works well if you need to do it.
I don't believe it's being given special priority.
Edit: I forgot to mention that I'm German. So books in German would be preferred if there are any fitting. This is of course not as important as the quality of the book content. 
Thanks for clarifying this. 
Thank you. This is what helped me move forward and learn the lib more. :)
I have truly enjoyed and learned well from 'Practical C++ Programming' by Steve Oualline. It is an orielly book. I have tried accelerated c++ as well as an MIT course but the orielly book blew them out of the water. It truly is a well constructed and comprehensive text. Englisch ist besser, oder? Viel Gl√ºck!
CMake was a very good choice on their part, and really the only practical option for anyone who cares about cross-platform. Even for single-platform use, CMake files are much more concise and better structured than makefiles. The only real problem with CMake is lack of proper tutorials and documentation for modern CMake style (&gt;= v2.8.12). There are lots of terrible CMake files out there and people picking up bad habits by example. The learning curve is messed up, but it's squarely because of the lack of good learning material not because of the difficulty of the task. 
I applied to Bungie for new grad positions in November 2015 and they contacted me for interviews in December/January 2015
The following is sort of an evolving thing, but I'm sure they'll get up to templates eventually: [C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md) You might also pick up some wisdom from Effective C++. Last, Stroustrup's book, Programming Principles and Practice Using C++ talks about generic programming starting in chapter 19. E: I see the Core Guidelines already has some good info on templates. I hadn't looked at it for some time. 
You should remove the virtual in the second example and use a reference instead of a pointer in the print. If not, your example is very confusing.
The point of using .bind is to not throw an exception, bur rather carry the failure on.
If you really want to learn QT I would recommend just getting qt creator and the sdk and looking at the examples and the documentation. When I was doing QT programming I had the QT 4.0 book but never used it. The documentation was so much better. 
Read in order. Do examples and exercises as they are encountered. Don't bother with end of chapter problems. Do my own mini projects using the skills as I learn them. Rewrite projects with superior strategies from later chapters.
I usually skim read the book in order first with the intention of learning the overall information without attention to details. Then I go back and re-read from the beginning this time thoroughly focusing on the details, doing the exercises etc. If we take the example of an algorithms book. After the first read (assuming no prior knowledge) I would be able to talk in loose terms about a lot of the algorithms and what they are useful for. After the second read I would be able to implement a number of them, know their asymptotic performance etc. Depending on my interest I'd repeat this process until I feel comfortable that I understand as much as I want / need to. By this point it's usually about specific details (i.e chapter) rather than the whole book. I usually interweave subsequent readings with other books on the same subject. On the 2+ read I also read with the intention of explaining the subject in detail to someone else (even if I never do) - this really forces you to learn what you read.
Do you have any interest in implementing papers like these with your library: * [deblurring](http://yuzhikov.com/articles/BlurredImagesRestoration1.htm) * [automatic portrait segmentation](http://xiaoyongshen.me/webpage_portrait/index.html) * [PatchMatch](https://en.wikipedia.org/wiki/PatchMatch) * [Reflection removal using ghosting cues](http://www.cv-foundation.org/openaccess/content_cvpr_2015/app/2A_105_ext.pdf) * [Demosaicing](https://courses.cs.washington.edu/courses/cse467/08au/pdfs/lectures/09-Demosaicing.pdf) It is clearly a lot of work, but implementing these as a set of additional algorithms which build on top of your library would greatly increase its value, and also function as a test for your library. While implementing these algorithms, you'd probably notice limitations of your library which you can then remove/work around. It is always good to "field-test" a library. Also, any plans on Cuda/OpenCL integration?
And print and the reference should be better ``const``!
They still do not. At least it feels like.
N4268 is all about template **arguments**. It has nothing to do with template **parameters**. This is one case where the distinction between the words "argument" and "parameter" is really important :)
Some of us are planning to re-propose this for the next C++ after 17. There are some tough questions that would need to be resolved (only types with regular equality operators should be eligible etc.), but there are some of us that think there might be a reasonable path forward. But we shall see. Anyway, until then, here is a sample implementation if you would like to play around with what an eventual feature might look like (the final feature needs to leverage the equality operator somehow based on my discussions with folks who have some authority in this space) : https://github.com/faisalv/clang/tree/literal-type-template-params The test file can give you some idea of what type of code that patch compiles: https://github.com/faisalv/clang/tree/literal-type-template-params/test/CXX/literal-nttps If you have some solid use-cases, and feel like you can make a strong argument for the feature, and don't mind sharing (with acknowledgment) please email me @ faisalv at yahoo. If/when we get around to writing up a proposal, that can only help our case. Thanks.
Still looks complex, but I think it is the simplest so far!
I would actually only need to parse a single string, and then send something with always the same headers. Just the "body" would be slightly different. It still feels quite bloated?
Because I need to keep the program running. It takes 0.6 seconds to execute the function. If called from bash and if still needs to load resources it takes 2 seconds. That's why I would like to initialise only once, and keep it running.
&gt; Even for single-platform use, CMake files are much more concise and better structured than makefiles. Wait, aren't there any build systems with better syntax and documentation? I'm pretty sure there are. &gt; The learning curve is messed up, but it's squarely because of the lack of good learning material not because of the difficulty of the task. I'm curious, is there ANY way to learn modern CMake, except for reading not-so-good documentation?
I know this isn't what you want to hear. But one of the first things you learn as a software engineer is that you have to go where the jobs are.
Good question! Remote jobs in C++ seem hard to get. The most recent set of C++ job postings here had _no_ remote jobs - which was quite a surprise to me, as I just finished a remote C++ job (for a company I'd not recommend). To be honest, I suspect that there aren't that many good programming jobs in _any_ language in Columbus, which has a population of less than 900k - and C++, while a "deluxe" language where the jobs you get pay well, is also less common than e.g. "web" languages. So it might be that your best opportunities are elsewhere... :-/ Either Cleveland or Cincinnati have over twice the population of Columbus in their metropolitan areas. Wish I had better news for you.
Would love to move, but I have a lease for the next 10 months. If I could move to southern California within the next 4 months though where would you start looking for specifically C++ jobs?
It is based on NVidia's work: https://developer.nvidia.com/open-source-vulkan-c-api 
&gt; There are TONS of jobs in enterprise web development in Columbus. Aha, good to know. I just quickly scanned various boards, but then I don't do that stuff. :-) &gt; Also, I could be wrong here, but I think all 3 of Ohio's biggest cities have a similar amount of people (1.9m - 2.1m). Could be. I did a quick Wikipedia run but I might have got Columbus' core population and the greater metro for the others! and indeed I did: https://en.wikipedia.org/wiki/Columbus_metropolitan_area,_Ohio
This is just the regular program. We haven't announced all the keynotes and plenaries :)
I think you should be planning to move. Ten months isn't too long to start planning... You're strongly implying you're a young developer. The way to have a really good career is to have something brilliant - or at least brilliant-_looking_ - early on. The great majority of those jobs are in a small number of large cities. C++ is hard. Some of that difficulty comes from being a legacy language, and some of it from necessity of it being so "close to the metal", and so-called "modern" C++ (idiomatic use of C++11 features) is actually a lot easier, but I'm not going to soft pedal it for you - it's hard. But it's not _that_ hard. I watched my father learn to speak, read and write Chinese... this is an order of magnitude easier. And the advantage of it being hard is that if you become a _good_ C++ programmer, you will never want for work. But you need to become a good C++ programmer. You are quite right that the way to doing this is to be working on an actual project, but before that, you need to study the language. It doesn't have to be a chore at all, once you get into it. I've been doing C++ for about thirty years now (it doesn't seem that long) but I still read _about_ the language every day - for fun, like other people read about sports teams or movies. But that's just getting the flavor of things. At some point, you need to master the details. I would strongly suggest reading Meyers' "Effective C++" - and then in six months move to "Effective Modern C++" - or even get both right now. There are many other good books too - these ones were influential on me. You want something that goes into the details - not a beginner book, but an advanced intermediate one. You want a book that you have to read very slowly! Whatever books you get, I _strongly_ urge you to get these books in physical, not digital format. I love digital books in general - even for manuals, I prefer them to paper ones - but for _this specific purpose_, studying difficult material which you are going to have to go over and over, a physical book is much better, and several recent studies back me up. Basically, you have physical and tactile cues associated with the actual book that dramatically improve not just your recollection but also your comprehension. The "infinite scroll" metaphor is also really bad for retention... so get the printed copy, you'll be glad you did. ----- &gt; I really want to move to California Don't do it. Seriously. At least not Silicon Valley. That gold rush is panned out. The quality of living there is poor as a result. The pay is high, but the costs are very high, and as a result it's super-competitive. Many people have a six figure paycheck and yet are basically living from month to month - within a few weeks of losing their jobs, they're through their savings and into their credit cards. You're in computer programming - a comparatively lucrative job. You should be able to save some money each month but you won't, there... You should always avoid having a job that you can't possibly quit. Knowing that you can walk off the job at your pleasure and not end up living in a dumpster two months later gives you an internal serenity that translates into more respect from your superiors and better work from you. Everyone is in that stage when they're young - but you should pretty soon be in a stable stage where you can make decisions without panic. That's really hard to achieve as a young person in Silicon Valley. ------ Now, as you get further away from San Francisco, this gets less and less true, and you did mention Southern California. Los Angeles, for example, can be affordable if you don't mind living in "poor but honest" neighborhoods, and while it's not the hub SF is, it's such a big city that there _will_ be C++ jobs there. It is possible you could get a C++ job, rent there, sock away some money, and figure out what to do next. (I will warn you that everyone I know in LA is desperately lonely - but I get the impression you're young, which will help, and you don't have to stay there forever.) Many other places north of California are very nice too, and have excellent quality of life. --- Regardless, I think you should be looking at the long-term picture. I think you should be staying afloat somehow for the next ten months, but be planning a move, probably to a larger city center, and looking to seriously amp up your C++ expertise during that time. (Also, the penalty for breaking your lease might not be so huge. If you got a decent-paying job elsewhere, it might be worth taking the hit. You can always just fuck off to Oregon, then send the landlord a letter with a small check saying, "Sorry, had to go. I'll pay you off a little bit every month.")
&gt; Not to mention that those kinds of companies are notorious for chewing people up and spitting them out. Even when they aren't blatantly abusing their employees, they're still paying less than other software jobs, expecting longer hours, and offering pretty much no job security. It's considered completely normal to lay off hundreds of people once a project is finished. Quoted for truth. Programmers who work in the entertainment industry are generally miserable fuckers for this reason - you never see them because they're always working, until they're out of work and suicidal. Somehow "it's games" is supposed to be the compensation, but would you go work in a slaughterhouse just because you liked hamburgers? :-D
That looks cool -- any idea what sort of math background the workshop expects? 
Wow is now officially part of Vulkan. Good job cronos. I wanted to use it before but I was not sure if nVidia could push it to the community, but now that cronos is behind is official! Sweet! I will start moving my stuff to it. 
Alright, I tried to write my own but I kind of failed. Can you post the sample you used to work around the issue? I'm just not sure what I'm doing. This is an example: ``` [ { "directory": "/absolute/path/to/regulus/build", "file": "/absolute/path/to/regulus/main.cu" } ] ``` For example, I'm not sure if I _need_ the command field or how to get it from juCi++'s automated build.
OK, very good response to a breakup - "I'm going to stop being mediocre"! I did that a lot. It never worked perfectly - but it always worked fairly well. So take the opportunity to really study the details of the language C++ until you know it backwards. Immerse yourself in the language - really understand some of the hard parts. That's a kick ass attitude, and I'm sure you'll do well with that. Don't hesitate to ask questions on /r/cpp_questions!
&gt; Effective C++ doesn't cover C++11 right? That's basically true though it does talk about some C++11 features, particularly shared pointers. &gt; Is it still worth reading that rather than just starting with Effective Modern C++? Good question - so I pulled it out and compared. I'd say, "Definitely, yes." It's clear that Meyers made a great effort to avoid duplication between the books. You basically need to learn everything that's in Effective before you start Effective Modern. Almost nothing has been superseded. There's some stuff towards the end of Effective that's a little obscure - I don't think I ever used anything in chapter 8! - but even that is almost exactly the same in C++11 and doesn't even appear in Effective Modern IIRC. There are a couple of cases where "best practice" becomes a bit more complicated in C++11 - for example, the "rule of three" becomes the "rule of five". Even then, it's easier to learn the basic form, and then a little later learn the updated version. The book is divided into 55 more or less standalone "items" and looking through it, I can't see one item that isn't still applicable, though the details have changed.
It's still early days, there's still time for them to come around. 
Probably [this](https://en.wikipedia.org/wiki/Vulkan_%28API%29): &gt; Vulkan is derived from and built upon components of AMD's Mantle API, which was donated by AMD to Khronos with the intent of giving Khronos a foundation on which to begin developing a low-level API that they could standardize across the industry, much like OpenGL.
/u/devel_watcher: &gt; Vulkan originates from AMD ... Wikipedia: &gt; Vulkan is derived from and built upon components of AMD's Mantle API, which was donated by AMD to Khronos ... I don't see any conflicting statements here. Nobody said 'single-handed' or 'Herculean' but you. o_O
&gt; but I've seen this whole "nvidia isn't relevant, AMD!" You're a bit paranoid. I'm from the Linux-land where AMD's OpenGL drivers are total garbage and everyone uses nVidia for gaming.
I just mean from a developer perspective. It's annoying. I'm disappointed about the linux driver situation myself, as I have a perfectly good AMD card I'd like to use in my server, but ended up grabbing a new NVidia card in my desktop so I could pass down my previous Nvidia card. The fact is though that AMD didn't "make" Vulkan. They were an important (integral to what it is today certainly) part of it. But many companies worked on it. I hate to see their work downplayed. Maybe you meant something else by what you said, but that's why I asked for clarification (ideally from you).
The hardware has drifted too far from the API, so the new one is different. OpenGL has a problem with the brand (due to the drivers, I believe), so the name had to be different too. DX has kept the name. 3D APIs have too much marketing around them just because it's a pillar in the Microsoft's monopoly. You don't see such hype about other types of APIs.
A tip: prepend lines of code with 4 spaces and reddit will show the code properly. 
`std::optional` doesn't have it because `boost::optional` doesn't have it and no one considered adding it a hard requirement. Standardizing a pre-existing library is already a great deal of work. `boost::optional` doesn't have any chaining support because it dates back to 2003 and was originally trying to solve a somewhat different problem ("how do you reasonably return a nullable int" rather than "how do you make nullable types safer to work with"), and without lambdas how often would `bind()` actually make the code better? I'd personally be greatly in favor of adding it.
Why? How much string processing are you expecting to perform with Vulkan? Strings are least of your problems. I think `std::string` is fine.
As a rule, I read them front to back. However, it's a rule with many exceptions. Also the mode of reading depends on many things, eg. how great is my general knowledge of the topic and how great is my specific knowledge of the topic. 1) Most text books have an introductio/history chapter. I always skip this. (If I feel curious, I may come back to it later, but I'll never read it as the first thing) 2a) If my knowledge (general and specific) on the topic of the section is weak, I'll read it thoroughly 2b) If my general knowledge on the topic is strong (I know of the topic from a different programming language, say) I'll read it less thoroughly: I'll scan for methodologies and syntaxes that are different from what I know, and read up on those, when I find them. I read the examples, make sure I understand how they work. 2c) If my specific knowledge on the topic is strong (I basically know the contents already.. perhaps I read a blog post describing the topic for the same programming language), then I'll just skim it: scan for keywords and conclusions that might either differ or expand what I know already. Basically I'll read the headings, the source code and sample roughly 10 random lines per page. If I stumble upon something unfamiliar, I'll read the whole paragraph or section or however much I need to make sense of it. 3) I'll continue like this until I feel I've covered the basics. For some books that means continuing right to the end. For others that means reading the first half/third. At this point I give up on chronology and skip to whichever chapter sounds fun and interesting. This is mainly because most such books end the basics around chapter 6, but don't talk about I/O until chapter 14 or so... Once I know the basics, I want to get on with something useful. In my world, being useful means relating my program to the rest of the contents of my computer. *) As for exercises, if sections or topics seem abstract, I'll definitely do exercises, generally as many as it takes for the topic to not feel abstract. If the topic doesn't feel abstract, I generally don't do the exercises. I find them distracting and doing them breaks the flow. -- Instead what I do, once I have finished reading what I wanted to read, I'll come back (often with a head buzzing with ideas to try) and try out a few ideas, or set myself either an exercise or a small project, and then (re)read up on the info required as needed to complete the task. ... there you go... that's how I do it. For me it is generally fast and effective. I hope you find a method that is the same for you :) happy studying!
&gt; I also haven't heard about any contributions DICE supplied, so I was surprised to see them mentioned alongside AMD. Maybe they were thinking of Valve? He's probably referring to the fact that mantle was co-developed by [AMD and DICE](http://www.forbes.com/sites/davealtavilla/2013/09/30/amd-and-dice-to-co-develop-console-style-api-for-radeon-graphics/#25fa622234b7). You can hear Johan Andersson from DICE discus it [here](https://youtu.be/MH2hjhcfWic?t=5201), or if you want John Carmack's and Tim Sweeney's opinions too they start [here](https://youtu.be/MH2hjhcfWic?t=4974).
Breakpad is the solution Google open-sourced: https://chromium.googlesource.com/breakpad/breakpad Github mirror: https://github.com/google/breakpad Mozilla open-sourced the server portion to handle breakpad reports: https://github.com/mozilla/socorro
Thanks!
Learn to use a debugger.
I don't know why but CamelCase seems natural to C++ despite the standard library being snake_case. However snake_case is the one true style in C. Except on Windows. I dunno, I just write whatever is most common for the project, platform, and language, in that order.
If you're looking at UE4, there are tons of "C++ for UE4" tutorials on Google. It's worth mentioning that UE4 doesn't use the C++ standard library _at all_, although it has replacements for a lot of it. And UE4's own garbage-collection system and property reflection (UObject and UProperty) has absolutely no parallel in standard C++.
For learning the language pick a compiler that is as standard complete as possible, i.e. GCC or Clang. For Unreal, assuming you're on Windows, you probably want to use Visual Studio for convenience. The C++ Standard is not suited for learning the language, it's more of a definitely reference once you already know it but need the gritty details. For books, I'd read the following in order to get the basics down: * A Tour of C++, Bjarne Stroustrup * C++ Primer, Stanley B. Lippman * The C++ Programming Language, Bjarne Stroustrup Once you fully know those you should have a good grasp of where you need/want to study more, e.g. maybe about templates, or the STL, etc. Remember that game programming is not just about knowing C++ (even though engines like Unreal make it a bit easier). You will also have to be well versed in algorithms / data structures, threading, maths, internals of C++ to write efficient code when needed, and then depending if you want to specialise: physics, AI, graphics, networking, etc etc. There are a lot of documentation and tutorials for Unreal. You might also want to checkout Unity 3D even though it's in C#, it has a lower barrier to entry to get going.
#ifndef SICT_COURSE_H_ #define SICT_COURSE_H_ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include "general.h" using namespace std; class Course { char courseCode_[MAX_COURSECODE_LEN + 1]; char* courseTitle_; int credits_; int studyLoad_; public: Course(); Course(char courseCode, char* courseTitle, int credits, int studyload); ~Course(); Course(const Course&amp; src); Course&amp; operator=(const Course&amp; one); Course&amp; operator+=(int studyLoad); void setcourseCode(char * courseCode); void setcourseTitle(char* courseTitle); void setcredits(int credits); void setstudyLoad(int studyLoad); const char* getcourseCode() const; const char* getcourseTitle() const; int getcredits(); int getstudyLoad(); bool isEmpty() const; //ostream&amp; display(ostream&amp; py) const; void display(std::ostream&amp; py) const; }; bool areIdentical(const char* compare); std::ostream&amp; operator&lt;&lt;(ostream&amp; py, const Course&amp; A); #endif #pragma once 
#ifndef SICT_COURSE_H_ #define SICT_COURSE_H_ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include "general.h" using namespace std; class Course { char courseCode_[MAX_COURSECODE_LEN + 1]; char* courseTitle_; int credits_; int studyLoad_; public: Course(); Course(char courseCode, char* courseTitle, int credits, int studyload); ~Course(); Course(const Course&amp; src); Course&amp; operator=(const Course&amp; one); Course&amp; operator+=(int studyLoad); void setcourseCode(char * courseCode); void setcourseTitle(char* courseTitle); void setcredits(int credits); void setstudyLoad(int studyLoad); const char* getcourseCode() const; const char* getcourseTitle() const; int getcredits(); int getstudyLoad(); bool isEmpty() const; //ostream&amp; display(ostream&amp; py) const; void display(std::ostream&amp; py) const; }; bool areIdentical(const char* compare); std::ostream&amp; operator&lt;&lt;(ostream&amp; py, const Course&amp; A); #endif #pragma once #ifndef SICT_COURSE_H_ #define SICT_COURSE_H_ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include "general.h" using namespace std; class Course { char courseCode_[MAX_COURSECODE_LEN + 1]; char* courseTitle_; int credits_; int studyLoad_; public: Course(); Course(char courseCode, char* courseTitle, int credits, int studyload); ~Course(); Course(const Course&amp; src); Course&amp; operator=(const Course&amp; one); Course&amp; operator+=(int studyLoad); void setcourseCode(char * courseCode); void setcourseTitle(char* courseTitle); void setcredits(int credits); void setstudyLoad(int studyLoad); const char* getcourseCode() const; const char* getcourseTitle() const; int getcredits(); int getstudyLoad(); bool isEmpty() const; //ostream&amp; display(ostream&amp; py) const; void display(std::ostream&amp; py) const; }; bool areIdentical(const char* compare); std::ostream&amp; operator&lt;&lt;(ostream&amp; py, const Course&amp; A); #endif #pragma once 
&gt; I think people other than AMD gets too much credit Well now I'm really confused... ;-]
C++ is cross-platform; IMO platform should be last on that list, if a consideration at all.
Little extraneous allocations all over the place are anathema to an application that would need Vulkan in the first place.
What is garbage collection?
Nvmnd........... https://en.wikibooks.org/wiki/C%2B%2B_Programming/Compiler/Linker/Libraries/Garbage_Collection Google is your friend...
Saying allocating when it's trivially avoidable is dumb is not a "premature assumption about performance". If the string size exceeds SBO capacity there **will be** allocations if I use any string type other than `std::basic_string` ‚Äì indeed, even string literals. This is not about premature performance considerations, it's about common sense. Using an allocating type as an immutable view is bad design, in any language, period. EDIT: grammar EDIT2: tone
Lots of tiny, short-lived allocations cause memory fragmentation. I simply do not need to point out why that **is** a problem ‚Äì not in theory, in practice. A better allocator can mitigate this, but this API doesn't even allow for that, and only takes `basic_string`s using `std::allocator`. Good design is not pedantic, it's _necessary_ for an API to succeed. Allocating as part of your interface, when it offers absolutely zero benefits whatsoever, is not good design. Your whole "show me numbers" demand is purely fallacious.
I haven't thought of looking at universities yet, but I will give it a shot. I'm surprised many universities are looking to outsource the jobs rather than have them for undergrad/grad students.
the good old semicolon of death :D
This very much depends on the application. If it's software for research, which is often written just for one research paper and then dropped, then very often it will be grad students and/or postdocs writing it. But if it's for professional quality application development which will be published and supported in the medium to long term for use by others, then it can be more akin to commercial development--they will hire actual developers since it requires a level of robustness and polish which most academic software sadly lacks (because that's not the primary focus of research). We even have a full time technical writer and a full time tester in addition to the developers. There are quite a few groups around the world doing imaging stuff, in a range of fields from biology to astronomy, and most are fairly interesting stuff. And given the difficulty of hiring people with the specialist skills in many of these places, quite a few are amenable to remote working (or remote working for a large part of the time).
I did this at your age, and for a good long time after as well. I'd work 9 hours at work, then come home and spend another 6 working on free software projects (I was a Debian developer and ended up taking on a large number of commitments). Your mind and body have limits. You do burn out. And you do get RSI. Nowadays, I have to cut back on typing and mousing (and gaming :-( ) because otherwise I end up in crippling pain. I have to see a physio to work on my hands every fortnight just to keep working at my job. When it gets really bad I can't even hold the pages of a book open, or ride my bike. I can't criticise since I'm not exactly a gregarious super-social person, and I did exactly this, but I just wanted to say that there is more to life than staring at a screen and that doing so can have severe long-term consequences. Do think about your long term health as well, and get some interests that involve doing something else. For me, that was cycling, mountaineering and rock climbing, and reading. I still do a lot of programming; I can still be very productive, and am probably one of the most productive programmers in my group. But I have to deliberately limit myself to only doing that during work hours, and do other things outside, even when there are lots of interesting projects and problems I'd like to get myself involved in. I broke that rule a few weeks back when I got so stuck into a problem I worked on it over the weekend, and I have spent the last few weeks suffering the consequences. I also try to get to the gym or the climbing wall for an hour or so over lunchtime to give my hands a good break and do something for my health (I also cycle to work most days as well). I'll just add that you should maybe also consider the location you want to work in for things it has outside your work and the tech scene. I had job offers from ARM in Cambridge, UK to do Linux AArch64 toolchain and porting stuff and in Dundee doing scientific imaging. Both were good offers and both would have been great jobs with great people. But in the end I chose to live in Scotland right on the edge of some fantastic countryside and mountains (I'm off just now for a cycle ride) versus living in a city with nothing but flat and boring fields around it. Both are fine places to live and work, but that ended up being the decider.
Roger, are you hiring at the moment? (remote C++ dev)
Just checked, and it looks like there's nothing open just at the moment, but if you were to keep an eye on the website or jobs.ac.uk then it's quite likely there will be stuff coming up in the future. A large proportion of the team are Java devs, but there's an increasing focus on C++ for some components. The various groups making up the consortium as well as our commercial partners may be hiring independently though; it might be worth having a look on our about pages to see who they are and check out their sites.
The slide on built-in data types is slightly presumptive; the Standard does not mandate the exact bit-width of the integral types, and therefore their min/max values are not necessarily those indicated. It's likely to hold... but really we should just encourage developers to pick the `intXX_t` definitions and explicitly specify how much they need.
You seem to be missing the command node in your compile_commands.json. Mine is as follows: [ { "directory": "/home/eidheim/hello/build", "command": "/usr/bin/c++ -std=c++1y -Wall -Wextra -Wno-unused-parameter -o CMakeFiles/hello.dir/main.cpp.o -c /home/eidheim/hello/main.cpp", "file": "/home/eidheim/hello/main.cpp" } ] However, we have not activated libclang parsing of cuda files (.cu). Not quite sure if we should, as libclang does not yet support cuda files as far as I know. You could add cuda files here though if you want to try it: https://github.com/cppit/jucipp/blob/master/src/notebook.cc#L156. 
Comments and macros behaving differently.
Thanks for the reply!
Did you read the article at all? One of the trick is to the new comment syntax in C++. How is that undefined behavior? Same with the other two tricks.
&gt; tries say that C++ should output identically to C Where does he say this? Are you talking about the author of the code or the author of the blog post? 
Do you have any examples of better systems than CMake? They would need to have the same coverage of platforms and build systems, as well as comparable support for introspecting the system, libraries, programs and other features. While there are tools with nicer syntax, and maybe also better documentation, the cmake documentation is pretty good on the whole as reference material (tutorial material is definitely lacking). But the real killer features are all the Find modules and all the modules that do introspection of various features. That support is unmatched to the best of my knowledge, and is what makes it so useful. With lots of software now providing its own cmake config files in addition to or in place of pkg-config files, it means that there's a huge amount of value in being part of the ecosystem around the tool, which more than makes up for any annoying syntax or lacking documentation. It's kind of similar to how everyone in the free software world ended up using the GNU autotools in the mid 90s-mid 2000s and continued to use it from inertia. That's a real abomination when you look at the baroque collection of languages, tools and file formats that are munged together. But it worked, and still continues to work. And there weren't any alternatives with the portability or feature tests it provided, and there was value in using the same system everyone else was--you could get help and support relatively easily, and everyone would already know how to build and install your software. I see CMake arriving at the same place; not because it's the best tool technically, but because that's where the mindshare is, and that's where the institutional expertise is which you can draw upon. Regarding modern CMake, it might be worth subscribing to the mailing list and asking questions and observing good practice from what's being discussed, and also in looking at how other people are structuring their own projects. (disclaimer: I maintain a few of the Find modules e.g. for Boost, but I also wrote a bunch of autoconf macros back in the day)
You understood nothing, but felt enough confidence to write a comment highlighting your incompetence. Or you are trolling. Both are a bit sad...
This was an excellent read, thank you. Do you by chance have some links to some others of the newer techniques?
Please don't. That would mean freeze of VA development.
To be honest, I have no such experience. But reading this I wonder, how important portability can be for a typical project? I mean, every Python tool (for example) most likely has a coverage of Win+Mac+Unix. Do we need more?
Another trick being used is apparently C++11 raw string literals: #define r(R) R"()" In C++11 and later the `R"()"` is a single token and so the `R` does not get replaced by the macro argument. `r()` remains `R"()"` and is an empty string. In earlier versions the R is replaced and `r()` becomes a string containing parentheses. #define r(R) R"()" #include &lt;stdio.h&gt; int main() { printf("%s\n", r()[0] ? "C or C++03 or earlier" : "C++11 or later"); } 
The fact that this comment was downvoted tells me all I need to know about several of the posters attacking the author here.
Wishing for Khronos to release a C++ wrapper for Modern OpenGL as well. :)
I do not miss NEAR and FAR pointers from true 16-bit C/C++
That was a great fun read!
Where is the name-calling here? I'm looking for it...
This is the idea of the algorithms directory. I did start to add some like the fast detector and an implementation of pyramidal Lucas Kanade, but as you saw it lacks of lots of other algorithms. This is why you have a bridge to opencv if you need something that is not yet implemented in VPP. For the field-test, I've been using VPP for two years and the core has converged to a stable api, and at least for my needs (motion analysis) I think that it's well tested. But yes, the value of VPP will get better if we get lots of algorithms included. I'll add some whenever I have free time (or paid time dedicated to open source). But if you want to have something implemented, the fastest way is to write your version and send a PR. For your last question, Cuda support was actually part of the implementation years ago, with a host_image and device_image, but I removed it and will maybe re-enable it later. There are few reasons for this: * C++ support of the Cuda compiler has never been up to date with the latest c++ standards, and VPP needs it. * GPU Programming models were evolving too quickly : CUDA, OpenCL, C++ AMP, OpenACC, ... It is was not possible to build a stable API. * My PhD shifted from GPU to mobile processors, which had no CUDA or opencl support at this time. It may be re-introduced if a stable GPU-programming models emerges, and most importantly if someone have time to write it.
Or going through autoexec and config to remove enough TSRs so that my 250kb program could actually load and run :-P.
I'd like to tack onto this question, if I may. I'm a 5 year experienced dev at this point. That's 4 years web, 1 year c++ professionally and 2 years total including all the time I took to teach myself c++ and make a career move. I did all of this locally, though. Bought a house in a Midwest area without a lot of great job presence. I want to move to a better city (Seattle area maybe? Boston?) but how do you guys handle relocation when you're settled with a mortgage somewhere? I honestly have no idea how to coordinate selling a home and finding work in another city. Should I be looking for relocation assistance and primarily companies that offer this type of thing? Any advice you experienced guys have for a young-ish (late 20s) dev who hasn't relocated for a job before would be wonderful.
&gt; but how do you guys handle relocation when you're settled with a mortgage somewhere? I rent.
Take a look at https://github.com/ipkn/crow Super easy to use and setup.
The return type should be a pointer to account, i.e. account*.
Hi there - guy-from-the-contest-video here ;) I'm using http://www.glass8.eu/ on Windows 10 
The purpose of an anonymous namespace is to give things internal linkage. Functions declared outside of a class and not in an anonymous namespace (or declared `static`) will not have internal linkage.
&gt; why can't you just declare the function outside of a class instead? It will have external linkage if you do that (assuming you didn't declare it static.) The whole point is to avoid that. There are numerous advantages. The compiler can optimize better, since it knows that it can see all call sites/uses of the function; and it's a good way to avoid accidentally exporting unnecessary dynamic symbols when creating shared libraries. 
Can someone clarify this for me? I think that this isn't really correct. From my understanding, if you define something as `const` and/or `static` (i.e. "file-static") on namespace scope, it will have internal linkage, but if it's not `const` or `static`, it will have external linkage, regardless of whether it's a named or unnamed namespace. The effect of an anonymous (or unnamed) namespace on the other hand is just that the compiler will generate a namespace name which is different for each translation unit. The main purpose of this is to avoid ODR violations for otherwise equal symbols and to generally "hide" stuff that is internal to your translation unit, because you don't really know the compiler-generated namespace name beforehand and it's probably not a valid C++ identifier anyway. Did I understand this correctly?
In the end I go with pipes stdin/stdout between my python webserver and the C++ process.
From http://en.cppreference.com/w/cpp/language/namespace#Unnamed_namespaces: &gt; Even though names in an unnamed namespace may be declared with external linkage, they are never accessible from other translation units because their namespace name is unique. **(until C++11)** Unnamed namespaces as well as all namespaces declared directly or indirectly within an unnamed namespace have internal linkage, which means that any name that is declared within an unnamed namespace has internal linkage. **(since C++11)** So it seems the standard didn't make any strong statements about internal-vs-external linkage of things in unnamed namespaces prior to C++11, just about the accessibility of things within the namespace. That said, I can't imagine that linker vendors wouldn't have made the fairly obvious optimization of treating names in anonymous namespaces as effectively internal-linkage prior to c++11.
Try cppreference.com?
Who said anything about Windows? At a glance, that code's only dependency is ASIO, which is naturally cross-platform...
&gt; for (it = accountStore.begin(); it != accountStore.end(); it++) Change that to &gt; for (auto&amp;&amp; acc : accountStore) and the rest of the code simplifies too.
&gt; An anonymous namespace will limit the scope of the function to just one file but why can't you just declare the function outside of a class instead? That's the point, it protects you against [ODR violations](https://en.wikipedia.org/wiki/One_Definition_Rule), if you use the global namespace or a named namespace you may clash with another type/function/variable in another file. Since it's undefined behaviour to have two different entities with the same name the compiler/linker can assume that if it sees the same name twice it can assume that they are identical. I was once bitten by this when I had two different classes with the same name (something like `cleanup` if I remember correctly), let me tell you that realising that the code for `cleanup` in file _a.cpp_ was being used in _b.cpp_ was non-trivial. 
Looks very nice. You could already do something similar with e.g. pointer-types: if (auto ptr = myfunc()) { } Now, could we get a cleaner version of std::find and its relatives? I find it that 99% of the time one is targeting the whole container (iterator range), so having xxx.begin(), xxx.end() just becomes noise. I.e., consider the following: // Currently auto it = std::find(vec.begin(), vec.end(), item); // Hoping for auto it = std::find(vec, item); 
i mean the spots where you write the code and receive error messages
&gt; Now, could we get a cleaner version of std::find and its relatives? [N4569](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf) has this covered but won't be in C++17.
That's something IDE specific. Which one do you use? Visual Studio C++, I presume? Someone else will have to help you. Never used that thing before.
A lot of food for thought here, thanks for this will work on this kind of stuff.
While concepts seem to be powerful with respect to error handling and reasoning about the code (especially from a compiler's perspective), I fear they are hard to read and write. Is there maybe somewhere an article about concepts that talks exactly about this potential issue?
Along with four minutes of fixing mistakes in typing up the examples &gt;_&lt; I don't expect anyone to be perfect, but if you're presenting me with a video explanation/tutorial for some reason, then I do expect some editing and rehearsal.
concepts are no worse than the current solution of enable_if in any situation, and vastly better (more readable) in most situations.
The question is do you want to know how to create any libary at all? Or do want to make a standard template library like STL or Boost? I assume you mean the last one. So the STL or Boost are huge libraries which supplys you with various features like hashing, sorting, container and so on. I would recommend to start with a specific part for example a container or different sorting algorithms. Just pick a small part where you are most interested in and search for documention or examples.
Great article as always by Jeff Preshing. I have learned a lot about multithreading from the articles on the site. Jeff has a way of taking research paper skeletons and putting C++ flesh on them to make the concepts more understandable and relevant.
Can you expand on how this meets the goals (no locks on read)?
I think you have to do it like this: /** * description of the function */ int example () { return 0; } Try it and tell me if it worked. 
From [cppreference.com](http://en.cppreference.com/w/cpp/memory/shared_ptr): &gt; All member functions (including copy constructor and copy assignment) can be called by multiple threads on different instances of shared_ptr without additional synchronization even if these instances are copies and share ownership of the same object. So just a `shared_ptr` would be sufficient: void broadcast(const void* msg, size_t len) { std::shared_ptr&lt;client_list&gt; list = current_list; for (int fd : list-&gt;clients) send(fd, msg, len); } void add_client(int fd) { std::shared_ptr&lt;client_list&gt; old_list = current_list; std::shared_ptr&lt;client_list&gt; new_list = std::make_shared&lt;client_list&gt;(*old_list); new_list-&gt;clients.push_back(fd); current_list = new_list; } Plus, it would manage the memory.
&gt; An anonymous namespace will limit the scope of the function to just one file but why can't you just declare the function outside of a class instead? Because that does not prevent code in other translation units (files) from calling the function.
Can you comment on the Engine Programmer opening? Does that need the 3d experience too?
Cool. Do you have any information on the compile-time/run-time costs of this approach?
Can it be used for C/C++ programming on Windows ?
It's possible to implement that now, see https://gist.github.com/patstew/c4f1489769a84411e933201b2f328df7 (Works in c++17, with workarounds for older gcc, msvc and clang) Then you can just do: scope(exit) {cleanup();};
That is a good question, I should have collected this before hand I guess. Regarding compile-time costs: I have not attempted to benchmark the compile-times. I should do that I guess. I guess I assume that they will rarely be significant because you just won't be using a variant with that many types typically. But I could be wrong, and it could vary a lot from compiler to compiler. I wouldn't expect compile-times of the variant to be at all significant compared to the compile times of something complex like `boost::spirit`. So in my original application I wasn't concerned about this at all. Regarding run-time costs: The main difference between this variant and other variant types is the way assignment works. Since that is always resolved at compile-time for any variant, there should be no run-time difference here. A common difference among variant types has to do with, do they do what `boost::variant` does and make backup copies for full exception safety, or do they allow an empty state. In this variant, I assume that the types used a no-throw move constructible. So it's less general than `boost::variant` or `std::variant`, but it's usually appropriate for the scenarios where you might use this, and it makes it simpler, and you get very good performance this way. The last point of run-time variation is, how does dispatch work when you visit the value. Actually, I implemented two different strategies for this, which were described in this stack overflow post: http://stackoverflow.com/questions/32235855/switch-statement-variadic-template-expansion Basically there are two strategies. One is, make a `constexpr` array of function pointers, one for each possible type in the variant, and index it using the `which` value of the variant (which keeps track of the runtime type), and call that function. This is like a little manual jump table. The drawback is, the compiler cannot always inline these function pointers -- clang is a bit better at this than gcc, at least at time of testing. A different strategy is, make a binary tree of types using templates, and use binary search to find the leaf corresponding to the runtime type, and call the corresponding function that way. This way there are no function pointers, so gcc can always inline it. I didn't actually benchmark it myself, but on the basis of the benchmark work done there, it appears that for numbers of variants less than ten or so, the "binary search " strategy may be faster. I'm a little skeptical of that, the jump table strategy is the more established strategy. So, currently what it does is, it selects binary search if there are four or fewer variant types, because then binary search should really be quite good. (Consider also that branch prediction will help to speed up the binary search version.) And for larger than four, it uses the jump table strategy. I guess I should do some actual benchmarks with this implementation, but I didn't get around to it. Thanks for asking though.
You can workaround it with namespace a) nested in your module's namespace, b) related 1:1 to file path in module (to avoid duplication between files in module). Then you have external linkage, some build performance penalty, but you can test your functions. Are there any disadvantages I don't see? I was wondering for a long time and now that I stumbled upon this thread, it looks like a good opportunity to ask.
yes, absolutely. We have a language service and debugging works for Cygwin and mingw. 
Visual Studio
VS Code isn't really intended as a replacement... It's a lightweight editor with debugging and source control instead of a full IDE.
Cool stuff. Enjoyed your cppcon 14 talk as well. Will you be making an appearance at cppcon 2016?
Cool stuff. I briefly worked with a friend on a similar variant implementation that also allows you to specify your own conversions.
Absolutely, this is always overlooked. I'm in a city of 300k and have a job writing C++ with a large company (~5k employees) that I literally did not know existed until I ran into them at a local career fair. It just wasn't flashy or the new hotness, so it didn't show up or appeal to me in any of my online job searches. I also found out there was a little hardware testing firm right down the road from me. I see the building every day, but would never have realized they needed C++ developers or even developers at all from the unassuming sign outside.
Thanks! I had a blast in 2014 but unfortunately won't attend this year. Nic Fleury, a former Ubisoft colleague who I went with in 2014, is speaking again so keep an eye out for him!
My impression is that there's at least some kind of desire to enable #4 through the use of new language semantics because it enables the generated code to be much more efficient. Without those language semantics though it's not a great idea to leave an object in such a state. That being said, I'm not sure a socket or a file is your best example. Both of these typically have some kind of "invalid" state, whether NULL (FILE *) or -1 (file descriptor) or some other "closed" state. Additionally, if you have a close call (which isn't uncommon even for RAII abstractions of files or sockets), you'll need to model that as well with your invalid state anyway. I wouldn't be so stringent on trying to avoid the optional case. If you want, just put checks in accessors so that trying to access the actual resource will throw an exception (i.e. the "optional" is an internal implementation detail"). In fact, having a default constructor put it into the invalid state is actually useful. It allows you to declare an "invalid" object without having to initialize it right away with a valid state.
I would imagine that a single fetch_add/sub would still be cheaper than a fetch, wrapping the lambda in a std::function, acquiring a mutex, and performing a std::vector enqueue. There could be between 0 &amp; 2 heap allocations here on the read path &amp; allocations typically involve further atomic operations and/or locks in addition to the unconditional atomic fetch + mutex lock contention. There would also be much better cache coherency as the book-keeping associated with each list is kept beside it and can be de-allocated in one shot as opposed to the double indirection of vector + std::function that doesn't actually live anywhere near the list it's book-keeping for.
Jon Kalb has written a comment on my website with a similar view, I replied there: &gt; First of all, don't get me wrong: I really wish C++ move semantics would have been truly destructive. &gt; &gt; And yes, I am thinking from the perspective of an implementer, not a user. But I am thinking from the perspective of an implementer who wants to give the user full flexibility. &gt; &gt; What they call a "partially formed type" only applies to types implementing my case 4. Other types like std::unique_ptr have a "fully formed type", if you will. Their semantics are well defined. Thus users can use it even after a move and it makes sense to reason about it. After all, would you disable `operator bool()`, `get()` or `reset()` on a post-move unique_ptr? &gt; &gt; And there are cases where you sometimes want to reuse a moved from object: if it is a member variable. Suppose you have a class that fills some member with state and then moves the state out to fill it again. If the member has more move safety, you can just reuse the variable without paying extra cost for default constructing and assignment. &gt; &gt; But yes, in most cases you don't need that. And move safety shouldn't encourage it, it should just provide a better vocabulary. After all: the less UB something is, the better, isn't it? ;) 
[removed]
It's a side project. You can do whatever you want. Perhaps you mean "What would be considered an acceptable side project *for my CV*?" which is a very different question?
Yes that was what I meant, sorry. What would do as an acceptable side project for my CV? I also edited my post.
Ahhhh didn't know that reddit would f**k up my formatting First reddit post :P
what kind of industry are you trying enter? Whatever your answer, that will be the project you should add to your CV. 
Firstly, if you‚Äôre writing getters and setters you may need to rethink things in terms of the object‚Äôs behavior rather than its data. While getters/setters have advantages over public member variables, they‚Äôre only a minor step up from public member data. Personally, I find it useful to have distinctive names for member variables. When you‚Äôre reading a member function, and you see a parameter name, you have only to look up to the top of the function to see that it is a parameter. When you see a member variable, all you can immediately tell is that it is not a parameter or a local. You have to go check the class to see if it is a member. How to distinguish them doesn‚Äôt matter much. A leading underscore is popular. A trailing underscore is also sometimes used. (There was the mistaken thought that all identifiers starting with an underscore were reserved. While that isn‚Äôt true, some are, so trailing may be a bit safer if you don‚Äôt have all the rules memorized.) Personally, I‚Äôm a fan of a my_ prefix. (And our_ for static member variables.)
It really depeneds. Where do you want to work? For example if you want to work in the games industry you should obviously build your own games and in a the best case a own little 3d engine or framework. But from my expierence every cool project will be honored more or less. Just to give you some examples: Behavior Tree Editor: http://behavior3js.guineashots.com/editor/#Shader/Texture Editor: https://www.youtube.com/watch?v=NefbthPVJAs Map Gen: http://imgur.com/a/D1kIs A ASCII-Painter: http://www.gridsagegames.com/rexpaint/ 
&gt; So, currently what it does is, it selects binary search if there are four or fewer variant types, because then binary search should really be quite good. Wow, that's very thorough of you. In your stead I would have settled for the table (O(N)) and not bother with an alternative.
Legend has it that compilers/preprocessors will define all sorts of stuff starting with underscore so you as a programmer might want to avoid it to reduce the risk of clashes (postfix '_' should be fine though). Heres some more on that: http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier
There was a destructive move proposal, but I recall an SO question where I believe Howard Hinnant said that no progress was being made on it and he didn't anticipate any anytime soon. I agree it's not great to leave an object in such a state, but I still think this is the least bad in many cases. Point taken, at least about the file. The fact that "closing" it is a function that can fail is an additional complication; it means that you want to be able to do it before the destructor, and that in turn means your object will be alive after being closed as part of normal usage. I still think though one can do better than simply having an `OptionalFile` class by leveraging the type system more, maybe I'll write about a potential approach.
I agree. But sadly C++ lacks a real destructive move, so I just took the name for this category.
Again: read-intensive applications. Using `std::shared_ptr`, the reference count is modified every time the list is read. All that other stuff happens only when the list is modified.
A bit off topic but I wrote a simple sqlite wrapper for sqlite (and mysql), if you want to have a look: http://siliconframework.org/docs/sql.html I am planning to isolate it in a standalone library. Here are few examples: // Read one scalar. int s; c("SELECT 1+2")() &gt;&gt; s; // Read a record. int age; std::string name; c("SELECT name, age from users LIMIT 1")() &gt;&gt; std::tie(name, age); // name == "first_user_name" // age == first_user_age // Iterate on a list of records: c("SELECT name, age from users")() | [] (std::string&amp; name, int&amp; age) { std::cout &lt;&lt; name &lt;&lt; " " &lt;&lt; age &lt;&lt; std::endl; }; // Read a record using a IOD object. auto r = D(_name = std::string(), _age = int()); c("SELECT name, age from users LIMIT 1")() &gt;&gt; r; // r.name == "first_user_name" // r.age == first_user_age // Iterate on a list of records using a IOD object: typedef decltype(r) R; c("SELECT name, age from users")() | [] (R r) { std::cout &lt;&lt; r.name &lt;&lt; " " &lt;&lt; r.age &lt;&lt; std::endl; }; 
I guess I had the code lying around from that SO question, and those other guys did the benchmarks, so it wasn't such a big deal. I wasn't really on a mad performance quest or anything. :)
nameSPACE, missing semicolon, missing return.
1. its "namespace" not "nameplace" 2. You're missing a semicolon after "test 123" There are also other minor issues. 
`main()` doesn't need an explicit `return`.
You're right. I got the read and write code sections mixed up.
You can already use the Microsoft compiler. The only problem is that you can't debug your binaries in VSCode without GDB, as the open source C++ extension does not yet have support for either of Microsoft's proprietary debug engines. https://github.com/Microsoft/vscppsamples/issues/66 It's "being worked on" according to comments I've seen in various places, but with no eta.
Sill waiting on that "Ultimate" version of sqlite that doesn't let you insert corrupt data into your database silently. Numeric column? Sure, you can store "Two" into it, no problem, good luck debugging that in a year's time.
Can you use the `| lambda` thing with `INSERT`/`UPDATE`? I've been using [SOCI](http://soci.sourceforge.net/), which is pretty nice, except for stupid things like not supporting 8/16-bit or unsigned variables, etc...
Maybe [sqlpp11](https://github.com/rbock/sqlpp11) could help? I've seen creators presentation in some conference videos, quite... magic.
If your goal is to use the project to get hired, I would focus on building a smaller application that still makes use of a variety of C++ language constructs. You want to show off your experience but still keep the codebase simple enough for someone to easily review. Plus smaller projects are more likely to actually be finished, which is important especially if you need a job "soon". Make sure your code is very well polished and have some people with experience review it to get some feedback if you are not confident with your implementation - but don't ask anyone to write it for you of course :). Take a look at Cracking the Coding Interview for some ideas of common algorithms, data structures, and other key things you need to know and try to implement some of them in C++ as part of your project. Many interviewers just want to make sure you know the base concepts, and this is a good way to prove it. Regarding the type of application to work on, that's really up to you, and depends on the kind of job you want. If you want a game developer position then yes, graphics and a fancy UI can help you (but again, don't get in over your head with this). For most developer positions though, you just really need to show that you can code. Even a console application is fine for this purpose. Don't worry too much about making it a million dollar application. Chances are when you do that you'll try to build something way too complicated and you'll have a hard time finishing it.
I believe this question belongs to [/r/cpp_questions](https://www.reddit.com/r/cpp_questions/). the constructor didn't initialize member std::string name.
In addition to thewisp1's answer 1) It unnecessarily copies name into the constructor. It could be passed by const reference, or it could be moved 2) It unnecessarily copies other_name into greet. 3) The return is attempting to sum together temporary c_strs, which are pointers. return std::string("Hi") + ... would work, but c_strs can't be summed to concatenate them.
&gt; Does it have to be fancy with UI, graphics, and stuff? This kind of fancy flashyness would be pretty useless if you want to show off a portfolio piece for a job writing web servers or database backend software. If you want to make a portfolio piece for the CV rather than a real side project, figure out what you are looking for and will be a useful skill for that specific job. Or just work on anything that seems interesting as an actual side project rather than as a portfolio piece. I talked to a guy at a career fair who told me about his Pokemon battle simulator. It had nothing to do with the job he was interested in, but he could speak cogently about optimizing it, about the architecture, about things he learned on the project. Scratch an itch. Learn something cool. Have a problem, solve a problem. You'll be working on something where you have a much better understanding of the problem domain so the resulting software will probably be better than if you write something you have no use for.
Removed as duplicate.
Yes, this is off-topic for our subreddit. Removed.
have you heard of [doctest](https://github.com/onqtam/doctest)?
I'm not quite sure what you're meaning but what I'm meaning is simply this -- I may not have been very clear. If you try and compile \#include &lt;string&gt; std::string BuildString() { return "Hello " + "world"; } int main() { auto string = BuildString(); return 0; } g++ will tell you "Invalid operands of types 'const char[4]' and 'const char[4]' to binary 'operator+'". (I don't have clang or MSVC on this machine but they say something very similar.) That's because it's trying to build the return value first, and "sdf" is a char*, which (obviously) doesn't have operator+ defined on it. If instead you have std::string BuildString() { return std::string("Hello ") + "world"; } then the "Hello" is built as a string rather than a c_str. The string has an overload operator+(char*), so it can concatenate with c_strs.
My point was that instead `You can only call its destructor or assign it a new value.` should be `You can only call its destructor.` Because assign operator may consult the lhs' internal state, which is not what you want. Or you should do the destructor/constructor combo. I would be careful about assigning value to moved-from objects. So, from my point of view category 4 would be: destroy and assign allowed - same as yours. Category 5 would be destroy allowed, no assignment allowed. And what about category 6: nothing allowed to moved-from objects, not even destroy. Useful for some singleton-style allocated global variable at program startup.
It's not a legend, it's the standard. And yes, if you look into any standard library implementation, you will spot the `__Ugliness`.
Yes, but if you're building a library that needs to work with C code then you won't have overloading anyway. He asked if there are any "gotchas," so I simply pointed one out.
I asked because overloading is what OP's looking for. As far as i know there's no fundamental difference between operator overloading and regular function overloading.
I've had some bad experience with destructors before (performance related), so I suppose "living life" would have to suffice.
I don't necessarily need compatibility with C (it's effectively a new project), so name-mangling should not be a problem. Though will I have to wrap a C library in `extern C {...}` if I want to use it in C++?
Hmm, yes, actually. Apologies. He's removed the code now but if I remember right he had a method std::string greet(std::string other_name) { return "Hello " + other_name + ... } and the overload on other_name would let that build.
Yep. Removed as this is off-topic here.
C++ is highly compatible with C. It's part of the beauty of the language: C++ is never any slower than C, because you could always just write the code the same was as C and get the same results. (It's also the cause of a lot of the headaches in the language, but that's a discussion for another day.) *For the most part*, you can just compile C code with a C++ compiler with minimal changes. &gt; \1. Can I use C headers (math.h, stdlib.h, etc.) with C++? Or am I required to use iostream, new/delete and all the rest of C++ stuff? The C++ standard inherits all of the C standard library. To include the standard C headers, you would actually use `#include &lt;cmath&gt;`, `#include &lt;cstdlib&gt;`, etc. Including headers that are not part of the C standard is possible as well, but it needs to be wrapped with an `extern "C"` block so it has the correct linkage. Some headers do this for you, so you would just include the file directly. You can even link C and C++ object files together. You do have to be careful when mixing C and C++ features. For example, if you use `new`, you have to use `delete` for that memory. Likewise, if you use `malloc`, you have to use `free` to release that memory. (Just to clarify: you can use both `new` and `malloc` in the same program, as long as you use the correct method to release that memory.) Also, sometimes one C++ feature will limit you from using something in C, or can make it tricky. Since you mentioned constructors, you'll probably want `new` and `delete`. Think about it: if you allocate memory with `malloc`, how would you then call a constructor for that object? (There is a way: "placement `new`", but that's a more advanced topic.) Over time, what you'll find is that C++ provides a better way of doing things anyway. For example: you really won't ever use `new`/`delete` yourself anyway, instead using a smart pointer like `std::unique_ptr` or `std::shared_ptr` or a container class like `std::vector`. Another example is the `std::string` class. It's a superior replacement for C strings and I highly recommend using it in the general case ... but integrating it with C functions that expect C strings can be tricky. Fortunately, most of these situations are pretty rare: C and C++ integrate very well together, everything considered. &gt; \2. Are there any gotchas that I need to be worried about when programming like this? (For example - I know that C++ is NOT exactly a superset of C, but are there any subtle syntactical/semantic differences that will bite me later on but not get caught at compilation?) Honestly, there aren't many, and most of the time it was probably poor C code to begin with. The classic example: in C, a character literal (`'A'`) is actually of type `int`. Which is somewhat surprising, but there's historical reasons for it (there was a time when *everything* was an `int` in C). C++ changed this (I think partly because it would produce surprising behavior with function overloading and templates) so that it's of type `char`. Thus `sizeof('A')` is 4 in C (depending on architecture) but 1 in C++. But ask yourself: when have you ever relied on that specific behavior? Probably never, since it's actually unexpected. Thus it goes with most of the other differences (that the compiler won't catch, at least). One last word of caution: operator overloading seems really cool at first, but there's very limited cases when it's a good idea. The primary purpose is to create a type that has the same interface as a built-in type. `operator+` should do addition, just like it does with `int` and `double`. Or you can emulate pointer types with `operator*` and `operator++`, which is how C++ iterators work. Before you venture beyond this (for example, using `operator+` to concatinate two strings), ask yourself if that's *really what you want*. Sometimes it might be (see: Boost Spirit), but generally not. Operator overloading is there for two reasons: 1. make coding easier for the programmer, 2. enable templates to work with primitive types and user-defined types alike. Also: constructors are nice, but destructors are much more important. The RAII paradigm is possibly the most important feature to come out of C++.
I'd be interested to know the context of your destructor-related performance issues. There should be no penalty to calling a destructor vs calling `delete/free` manually (other than the negligible function call overhead, which might get inlined-away anyway). Destructors are among the best features of C++, I'd encourage you to give them a go, even if you end up disabling exceptions.
Framerate drops every time the entity collection was refreshed as far as I can remember, though it's been some time. And I was just starting out back then, so possibly I did something wrong
I haven't kept track of the proposal closely enough to comment on the progress of destructive move, except to say that as far as I know, it will not be in C++1z (where z hopefully is 7). If anyone knows different, please correct me.
The same thing as the fox.
&gt; Thing is, in gamedev, I don't think you want destructors to start firing and run who knows what code as soon as player move across grid boundaries or something. A destructor isn't something magical - it's just a function with guarantees about when it will be called. Everything that needs to happen in the destructor *should* also need to happen in the C code, whether it's just a series of calls to `free()` or some other cleanup. 
Vectors and Matrices are why I was thinking of operator overloading. &gt;Constructors are broken in most languages, including C++ Can you please elaborate a bit?
"Forgetting" can be somewhat emulated using an uninitialized storage or a union. 
Ok, I made a benchmarks framework for visitation and committed it. I will try to do a write up later I think. But I'm not entirely sure if it is sane yet... will probably end up looking at generated assembly I guess.
&gt; to wrap **C-compatible** C++ functions declarations I sometimes see `extern "C" { some&lt;template&gt; my_fun(const foo&amp;); }`. It's not very useful.
Also, if the OP wants constructors, he'll need to ditch malloc/free in favor of new/delete. 
Definitely something outside of the language.
haha extern "C" {template&lt;typename T&gt; constexpr auto fun(const T&amp;) noexcept {...}}
RAII and templates are in my opinion the best tools in C++. If you don't want to use template and agree with the runtime penalty of not using it, at least give RAII and move semantics a try.
This: http://www.powells.com/book/standard-c-bible-9780764546549 However, it's not it. It's just the only one I could remember the name of.
&gt; And if C has taught me anything, it's that all abstractions come at a price. Then C has taught you nothing at all - because this is quite wrong. Many C and C++ abstractions cost precisely _zero_. One of the underlying aesthetics of C++ is that you don't pay for what you don't use. Consider these two types: using Type1 = int; struct Type2 { Type1 x; }; struct Type3 { Type2 y; }; There is no cost to using any of the abstractions `Type1`, `Type2` or `Type3` over the concrete type `int` - whether you are writing in C++ or C. (Well, in C you couldn't have the typedef, but that's a detail...) Indeed, this whole passage you write is... not meaningful: &gt;&gt; operator overloading seems really cool at first, but there's very limited cases when it's a good idea. &gt; Right now, I simply want to use it for Vector and Matrix arithmetic. And if C has taught me anything, it's that all abstractions come at a price. What "abstraction" are you even talking about? Not using operator overloading?! That doesn't even make sense... Honestly, I think you should bite the bullet and learn C++ properly. You seem to be making decisions about your future direction of development based on misconceptions and myths.
&gt; I am not going to use STL, Boost, Templates, etc. Sure, avoid Boost, but avoiding STL (without replacing it with some other library)? You are saying, "I like to spend most of my programming life re-inventing the wheel over and over again before I can get to the simplest business/game features." No `std::vector`? No `std::string`? Indeed, no generic containers at all? It's you buy a sports car and decide never to shift it out of first gear. &gt; Operator Overloading This is a minor feature in C++ that gives you nothing new except a slightly neater syntax. This gives you nothing you can't do in C. &gt; Namespaces This feature just gives you shorter names - it really gives you nothing you can't do in C. &gt; Constructors [but no destructors] What's the point of that??
You can't overload C symbols, so you lose nothing by this. EDIT: this is a technical group. If you think I'm wrong, explain - don't downvote and say nothing.
&gt; Companies and organizations write internal style guides to purposely restrict themselves to a particular subset of the C++ language all the time. But they are doing this from a position of knowledge about and experience with the language, not because they have strong beliefs about the usefulness of language features without corresponding evidence.
&gt;&gt; if you allocate memory with malloc, how would you then call a constructor for that object? &gt; Silly me! You are right, ofcourse You can do that. It's called placement new. 
This is what you wrap with extern "C": C++ functions which you want to call from C Declarations of C functions which you want to call from C++ (e.g. in C headers for a library) Also note that C++ name mangling is not standardized and all compilers do it differently, so you often need to use extern "C" for any exported DLL functions even when both ends are written in C++
Ehhhh, you can write C and C++ in the same project. Just remember to restrict access to C++ parts through a well defined, standard compliant C interface. Everything in those function declarations is POD, C structs, and pointers. Perfectly legal to pass around structs of void pointers that you cast back to their C++ types in C++ function definitions. The C++ gets hidden away behind C. If you do that it isn't hard to keep the two sides nice and separate. This is how most binary APIs are written, since C++ linkage rules are not standardized due to no standard implementation of the ABI.
I fixed a type punting warning in GCC using a C union alias yesterday... Ugh, felt so dirty.
It is legal for member variables to begin with a single underscore followed by a lowercase letter though. I use a single underscore prefix for protected/private member variables in classes. I use a trailing underscore for parameters. I also personally use double underscores in struct member variable names to represent things that should not be touched by anyone using that struct (that mostly applies to C though, for APIs that link back into C++).
Do you ever end up duplicating lots of code when you wish you had templates? Or do you think templates are one of those dangerous hammers that cause everything to look like a nail?
&gt; is starting with C++ a good idea no &gt; is C++ a good idea no
lol neither are wrong, but context dependent :P 
If you're interested in C++, I'd strongly recommend starting with C. Once you're comfortable in the language, it'll be a lot easier to make the mental jump to C++; you'll understand *why* the language has certain features, and what problems they were trying to solve. Edit: Care to comment on why some of you disagree?
Starting with C++ is a good idea, but not necessarily for you. The problem is that there are many bits of legacy in it and you'll need a good teacher that knows how to not use them to start you on the path of modern C++, rather than teaching you all the old stuff and then letting you find out why we consider it not modern C++. I'd pick a language that has a shorter history and that has less legacy bits left in it to start with, but mostly because you're more likely to find a good teacher in it.
I love reddit , I knew having not the same opinion as other will lead to downvotes but I still love to see how everyone hates each other. It's like a competition of who is part of the most main stream group to get the maximum score...
That or find another job. I've always tried to learn a lot of various languages and frameworks and I got jobs in: C++, Java, Android, iOS, webdev, C, ... You have to be flexible physically or mentally.
Is there no downside to using double references? I've always been told to deter the use of double pointers. 
r/learnprogramming
Note also that most C headers already do this, using the guard specified by u/mr-agdgdgwngo above.
&gt; That is after the Update 3 installer took 3 hours and 50 minutes to do its job, because it turns out it downloads 1.7 GB during the installation on-demand ‚Äì and it does so much slower than it would have taken to download the full 6 GB ISO, all while preventing getting any work done because the installation is in progress. A bug is a bug, but *that* is just plainly wrong-headed design. I don't mind having large downloads be necessary, or I mind being on a not-so-fast connection, but it's par for the course nowadays. However, having this occurring *synchronously, in the foreground*? Whoever could think it's a right idea? Did *anyone* test the update flow before releasing? Seriously... Just let the downloads occur in the background, then have a little icon signaling the user it's ready to install whenever there's *nothing left* to download (no pop-up, no, I am working on something else and I'll deal with this upgrade when I decide thank you). I sometimes wonder if some developers have such an ego that they think we use their tools *just for the sake of using it*, instead of, you know, actually *working* with it. 
It's not the downloading. My internet connection can download 1.7GBs of data under 3 minutes. Yet when I installed VS2015 a few weeks ago it took all afternoon. I'm really disappointed in visual studio 2015. I've also discovered it's C++11 support is still bad. For example, some of the DNN example programs that come with dlib v19 cause visual studio to enter an infinite loop while compiling. I've never caused gcc to get stuck forever.
&gt; Ends with an intellisense that is barely useable on a larger C project. In all of my professional career, intellisense has never been useable on the bigger commercial projects. It also always going to fixed in the next version. 
This video should dispel a few misconceptions: **CppCon 2015: Kate Gregory "Stop Teaching C"** https://www.youtube.com/watch?v=YnWhqhNdYyk And yes, in my opinion, learning C++ as a first language is a good idea if you're a quick learner or have a mentor. 
I wonder if they'll get out a hotfix, I mean this is pretty bad and not something particularly exotic...
Strictly speaking, you are right, though in practice [this shouldn't be a problem](http://stackoverflow.com/questions/16520951/c-linkage-for-function-pointer-passed-to-c-library). I don't know how/whether the technique could be adapted to generate C linkage thunks. **Edit:** actually the C linkage issue can be solved (if it ever appears) through another indirection layer, I've updated the article to explain it.
&gt; My internet connection can download 1.7GBs of data under 3 minutes. Lucky you, I currently have a 100 kb/s connection; I'd be looking at 37 hours of download (hope it can be resumed).
It's pretty silly to recommend starting with a non OO language. Not to mention learning C before C++ will cause OP to learn bad habits for C++.
There are no bad habits in C. But I get the point, this is r/cpp so yeah C++ for sure. What else? This is the best and only approach.
100% agreed. I have no idea why VS gets the love it does. And I absolutely do not accept this as "par for the course nowadays." It's absurd in any day. IMO the entire VS team needs to be taken to the woodshed. I told my employer to send them a bill for the time wasted installing the last update. There is a feedback/issue reporting button in the upper right corner. Use it. I do, at least once a month. 
Sure, but we know for a fact that this guy is doing game development. In 2016, no one does game development on an 8-bit machine with a few K of memory! I've done development on these tiny machines. It's challenging and even fun, but if someone had waved a magic wand and given me an extra 64K of memory and the full STL, I'd have taken it in a New York minute...
Some of this is very reasonable. * Multiple inheritance is rarely needed and causes problems - inheritance is overused in general. * Operator overloading is basically syntactic sugar - in some cases you need `operator()` for the STL. * Deciding to avoid exceptions can make your life easier. But avoiding templates? What is the reasoning behind that? "Templates are hard!!!oneone!!" This smacks of [cargo cult programming](https://en.wikipedia.org/wiki/Cargo_cult_programming). How do you possibly have typed containers? Do you have to write a new container for each thing you hold?! Or, even worse - do you store everything as `void*` and downcast when you store and upcast when you retrieve? It seems without templates there would be no way to prevent you from storing two different types in such a container - and havoc ensues... &gt; (we have our own library which uses our custom allocator) How can you have a "custom allocator" without templates? I've run into a lot of people using "their custom library" rather than the STL. Back in the 90s, when the STL was small and primitive, this made a lot of sense. But to be honest, in the last ten years or so all of the developers I've seen doing that are people who simply _do not understand templates or the STL_ and instead of hitting the books and figuring out their issues, have concluded that the STL is "broken" and have gone off and written their own library - libraries which are typically much more broken than the STL has ever been. I think it's [Dunning-Kruger](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect), myself. "What do those idiots on the standards committee know? I know so much better than they do!"
Our C++ code base is pretty big, and it's mostly usable... however I also use Visual Assist X. I do tend to have to wait a while after opening a new solution though... Edit: Someone did tell me that update 3 had improvements for large projects... not sure to what extent though.
It'd be pretty amazing if you could have both compilers installed, and switch between them like that. I hate how the compiler and the UI are tied together, such that you can't get updates to one without changing the other. For example, I hear that update 3 had a lot of UI improvements for big projects, but if you're stuck on update 2 compiler, you can't have those benefits.
/u/davis685, can you please point me to which DNN examples cause the compiler to enter an infinite loop? That's a surprise to me. We've got some (very serious) name lookup bugs in our C++11 support but otherwise we're very close to C++11 conformant. 
You might also want to mention also this famous article "The Impossibly Fast C++ delegates": http://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates It also shows a situation where this phenomenon arises, where you need not only a function pointer, but a `void *` extra, to carry the "context" for the call. You could also look at "eraserface" https://github.com/badair/eraserface which I feel is tangentially related.
/u/tyrellj, that's a good idea--have multiple compilers installed that you can switch between. We're working on it, but no timelines. For now, you can install the latest compiler as a NuGet package and quickly switch back: https://blogs.msdn.microsoft.com/vcblog/2016/04/26/stay-up-to-date-with-the-visual-c-tools-on-nuget/
Thank you for the link, I appreciate it. I do admit that I haven't been staying up to date as much as I should, and I'm glad you're working on making this possible. It will definitely help us out in the future.
&gt; If you want this to be applied globally, you can set _ CL_ or CL in the environment I'm confused. Where do I that exactly?
The banning of templates is a coding standard that's at least 12 years old and I'm sure had more justification at the time. Here are the justifications I've heard: 1. Compile times are slower 2. Error messages from templates can be difficult to decode 3. Executable size is larger 4. They are often used completely unnecessarily and thus make the codebase incomprehensible (your hammer/nail analogy) I myself can come up with counters to any of those points, and also compilers have improved on the first three points. As for duplicated code, you can use helper functions or inheritance in a lot of cases.
So the base class would basically just be "read only". I think that this segmentation will likely be more difficult and less beneficial than you'd initially guess. One interesting way to validate that claim is to start writing up the design or making an implementation of a single STL class, like `std::vector`.
Perhaps I'm missing something, but what's the use-case for this? I can see that it might be desirable to have a function like void sort_ints(std::vector_base&lt;int&gt;&amp; vec) { std::sort(vec.begin(), vec.end()); } and be able to call it with `std::vector&lt;int, std::allocator&lt;int&gt;&gt;` or `std::vector&lt;int, MyAllocator&lt;int&gt;&gt;` or whatever else. But isn't this something that's better solved with generic programming than by inheritance? With the Concepts and Ranges TSs, you could instead write something like the following: template &lt;typename T&gt; concept bool Vector() { return requires { // Vector requirements } } void sort_ints(Vector&lt;int&gt;&amp; vec) { std::sort(vec); } (Edited to use Concepts syntax rather than ugly Range-V3 `CONCEPT_REQUIRES`).
No, the base class wouldn't be read-only. You can still modify the container's values, just not the storage.
I hear you. If it were my choice, I'd replace the no templates rule with a sensible best practices guide for the use of templates. For containers, we have containers for commonly used types (basic types, vector, matrix), and a void* container for other types.
Well, there are several problems with that. Concepts have been promised since C++11 was still called C++0x and we still don't have them. Secondly, the use of templates and generic programming for this precludes the implementation in a different compilation unit (i.e., putting the implementation of `sort_ints` in a `.cc` file), which is ~~important~~ essential for many large code bases (at least, until we have modules). It also leads to the generation of more code unnecessarily. If `sort_ints` contains several megabytes of code, and my code base uses hundreds of different kinds of allocators, the binary blows up pretty quickly. Also, the proposed changes here are *much* simpler than generalized Concepts.
Java uses boolean and if I am not mistaken, the University where Arduino was created are heavy Processing users. The Java environment for creative coding. 
I'm confused by the example- does the bug show up because of the ref-capture lambda, or because it was hidden in a macro? I would think that the preprocessor would have nothing to do with compiler backend, which is where the new optimizer resides. So let's assume the macro is superfluous- so stripping it out, the offending line becomes: Report( [&amp;]() -&gt; size_t { if (a&gt;b) return a; return b; }, a, b); What we're left with is alarmingly trivial. This is not some obscure combination of barely used language features- it's just a simplification of a common pattern which appears to be fairly similar to lambdas I've seen in C++11 production codebases. Needless to say, I'm surprised that testing hasn't caught this bug.
another documented example of this: https://deplinenoise.wordpress.com/2014/02/23/using-c11-capturing-lambdas-w-vanilla-c-api-functions/
Regarding only needing some specific header-only boost libraries: Have you tried [_bcp_](http://www.boost.org/doc/libs/1_61_0/tools/bcp/doc/html/index.html)? A little tool shipped with Boost to extract only specific boost libraries including all dependent files. I've used it with success for our own projects with both compiled and header-only boost libraries. For compiled libraries its a little tricky but Google helped me all the way.
regarding the install experience. I just wanted to acknowledge that we know this is really not very good right now, my apologies. Fixing acquisition of the product is one of the top priorities for the team right now. Can folks interested in giving feedback on our vnext installer technology please PM me their email addresses so we can make sure we follow up? we'll have a preview in the not distant future. 
vector results in vastly simpler code, that automatically handles unbounded-length input (of course, you have to know how you use it; you can't simply say v[i] and think that it'll automatically make that a valid index). Dynamic memory allocations are more expensive than using the stack, but vector imposes essentially zero additional costs beyond malloc().
I'm the main developer of the new optimizer. The problem doesn't have anything to do with the lambda or the fact that's used by a macro. There are multiple things that need to happen at the same time to trigger the bug - something that didn't seem to appear when testing with Windows, Chrome, Chakra, CoreCLR, Firefox and a large amount of other smaller tests. 
I am not sure I understand the reasoning for this. If you are using templates, then something like ranges would provide what your are looking for. If you are not wanting to use templates, then you have to specify the template types for the container ie vector&lt;int&gt; and in my experience, the container type template argument varies a lot more than the allocator. In other words, writing a function for every container_base&lt;T&gt; that you are interested in is not significantly easier than container&lt;T,Allocator&gt; as Allocator is maybe 1 or 2 options and T is many,many options. 
You can avoid binary blow-up by passing pointers to first and one-past-last elements of the vector into sort_ints.
I don't think he's saying bad habits in C, but bad habits in C++ that result from learning C first.
initialization of elements, ehem.
I can understand it. But I think that everything below 4 isn't sensible, YMMV of course.
I agree, the name isn't optimal.
That's nice, I didn't know about that. Thanks.
If you reserve and then push back, you're not paying to initialize anything.
No, it won't even work in the scenario of a single writer. Concurrent writing (`current_list = ...`) and reading (`list = current_list`) the same shared_ptr instance causes a data race. Only the control block is threadsafe. ([Relevant SO topic](https://stackoverflow.com/questions/27149947/is-it-thread-safe-to-reset-and-copy-shared-ptr-simultaneously)) 
Which is a pattern that does not fit uninitialized-write random-access buffers, which is the case in a lot of data processing applications. Those pay for the overhead of initialization unless they have their special allocator.
I spoke to spongo2 on here, and followed up with them over email. I submitted some perf traces but never heard back after, unfortunately. Edit: What more can I say - read /u/spongo2 reply below. Hopefully it will have worked out for our use case in the next update. Really can't fault them here! Thanks Steve!
Well, at some point you have to pay for the heap allocation, which costs way more than the zeroing anyway. So if you really need to keep this out of the critical path, then you simply ensure that the zeroing happens at the same time as the heap allocation by using resize instead of reserve, and forego the luxury of different size vs capacity (which you don't have with an array anyway). Anyway your comment that initialization is a cost beyond malloc is of course correct, but I guess the broader version of my point that the cost is easy to mitigate (either by understanding what you can afford when, or just by writing a trivial custom allocator) is correct as well.
All large code bases face the legacy problem, boost is still very well, as it never embraced the framework idea, like wxWidgets or Qt strictly try to use it self and create a closed framework. boost is just a collection of libraries, often predating the standard for years. Also, its not the boost library that gets standardized, that's why the boost library can have certain features, which don't make it into the standard. Another advantage of boost is, that you have one implementation, not one for each compiler you are using. Also, boost::thread is covering C++11s threading, but also offering much more. I'd prefer using boost::thread over the standard currently. From today's perspective, boost is embracing the problems the new standards bring for it, it often has adopted or added new libraries like hana, which allow to replace older libraries like fusion and MPL. So, there is a new generation of "boost 2.0" libraries which use the new standards and bring other important features with them. And, boost is completely run by volunteers, not having a group of companies backing it like Qt.
Slightly offtopic, but gcc (https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.201z), Clang (http://libcxx.llvm.org/ts1z_status.html) and MSVC (https://msdn.microsoft.com/en-us/library/hh567368.aspx) all have support for experimental/filesystem. I've only used the MS implementation in cold blood but it's closely based on boost::filesystem, with very few breaking changes (directory iteration is the one I found). If filesystem is holding you back from going header-only with boost I'd be inclined to give experimental/filesystem a bash and see if it does what you need.
The other counterargument is that it adds functionality and flexibility to the standard without really breaking anything (unless there's something I'm missing)
&gt; inheritance is yesterday's solution I'll confess that was my initial reaction too, and you might be right about that. The iterator library is certainly moving in that direction
Aha! Good to know. Honestly, it might just be that "this is the time". We really do understand templates now a lot better than we did ten years ago. I've done a bunch of experimentation with C++17 and even did a project on C++14 (though I thought the developers on that one spent far too much time upgrading to be bleeding edge) - but for my real production still, I always target C++11 - _but_ what we have learned from C++14 and 17 is "Where are we going with all of these features?" and "What does best practice really mean?" I was making some limited use of templates ten years ago. I'm glad I don't have access to that code. But today I'm actually pretty confident I can write coherent template code and solve the problems that come up. (And I have to give some credit to clang and recently, VS2015, for having the good error messages...)
Why don't you just write the approximately 30 line custom allocator that solves this problem, and then show them a toy program where the assembly proves there's no extra cost?
Exactly. An example is Howard Hinant's no_init_alloc http://stackoverflow.com/a/21028742/1858436 This will allow you to use the memory management of vector and resize without paying for the overhead of initialization.
&gt; Can you please elaborate a bit? Of course. I claim that C++ constructors are hardly an improvement over the factory functions one could write in C. I think this is appropriate for the topic as OP is considering to use some C++ features on top of essentially C. ## A broken promise The promise of a constructor is to guarantee that the object is initialized before it is first used. In most circumstances it seems to be the case: one cannot just forget to call the constructor, because it will be called either explicitly or implicitly. However, this is a broken promise. Due to the complicated initialization rules of C++, one can indeed [access an object before that object is initialized](http://www.gotw.ca/gotw/080.htm). ## Additional limitations Now that we have seen that C++ constructors fail to deliver their promise of initializing objects before use, let us consider in what ways constructors are limited compared to factory functions. #### No distinct names Often there is need to construct instances of a class from different input arguments. No problem, one can use overloading to write different constructors for different purposes. However, these constructors cannot have different names, which becomes clunky when the types are not sufficient to distinguish between the uses. For example, one can construct a complex number from real and imaginary parts, or from magnitude and phase, but for both the constructor prototype would likely be `complex(double, double)`. #### Only one way to report failure The only way to report failure from a constructor is throwing an exception. Of course, this opens a whole can of worms: class destructor won't be called, all initialization already done in the constructor has to be undone manually etc. This could be a whole different post, but for now, let us just consider what other ways one could have for reporting failure when using factory functions. **Factory function returning a pointer:** especially handy when one would dynamically allocate the object any way. Can return NULL / nullptr to signal failure. T *factory(...); **Factory function with optional placement pointer:** a variant of the above, but heap allocation is optional. One can specify a placement pointer which could simply point to a stack allocated struct, and then the object will be initialized there. If the placement pointer is NULL, the factory function calls malloc / new. T *factory(..., T *placement = nullptr); **Factory function with error code and placement pointer:** object must be pre-allocated and pointer given to the factory function which otherwise has a return value which is an error code. A classic. int factory(T *p, ...); And of course, exceptions are still an option with factory functions.
The debugger is OK. But then again, I'm quite happy using gdb. It's useful when I need it, but it's not something that makes me want to use Visual Studio for everything.
Ah, sorry, I forgot about the cmake check for C++11 support. As it is, it won't compile the DNN examples in visual studio. If you grab the current version from github and disable the checks (located here) https://github.com/davisking/dlib/blob/master/dlib/cmake_utils/use_cpp_11.cmake#L62 it should compile the dnn examples. It's specifically the imagenet example programs that have trouble.
Because I did that seven years ago and they are stubborn. :(
I don't know what people consider big, but it was completely unusable for me half the time at 100k LoC.
He did not pointed a typo, he implied asking a question about the meaning of the "string c++ skills"... thus my comment.
&gt; However, having this occurring synchronously, in the foreground? It's kind of *both* foreground and background: the main installer runs in the foreground, and alerts you to close Visual Studio when it begins if you are using it; but the download seems to take place in the background, via the BITS download service. So you get all the advantages of a foreground installation preventing work, and the transfer speed you might associate with a background transfer. :-) It is indeed much better to download the full ISO and install from that, even though it is several times larger than what otherwise needs to be downloaded for a partial (mainly Visual C++) installation.
The new optimizer actually handles such PHI cases, just that in this example it processes the instructions in a non-optimal order: before getting to x * y it finds the two PHIs for x and y and converts them to QUESTION operations (CMOV) like x = a &gt; 3 ? 4 : 8. For the QUESTION1 x QUESTION2 case it does not check yet for the situation when both select values based on the same expression - I'll add it as a task.
Thanks! The hang does repro when forcing C++11 support. Our dev is looking into this now. 
It is now called [span&lt;T&gt;](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0122r1.pdf) and is on its way into the standard. (It wasn't ready for 17, but will probably be included shortly after that) 
http-parser.h/.c is joyent's parser written in C (used in node.js, inspired by nginx). I was talking with a friend and we where discussing updating http-parser to a header only implementation. Could be fun to port! Fork it and i'll accept pull requests as well. Should be getting the cmake files updated and tests updated this weekend.
Marek, No. Assignment is defined for moved from objects. This was part of the design from the very beginning. If you couldn't do this, then you couldn't use move when swapping or sorting objects and that would be a very big missed opportunity. It is true that the assignment operator can examine the lhs object's state, but this fine because that operator is a member function and is therefore has knowledge about the class implementation including its moved from state.
hey Donal, sorry for dropping the ball on communicating back here. Let me update you. We actually did a bunch of work triggered by your traces! let me reply back to the original private thread as I want to respect your source bases privacy. Shorthand answer is that we are working with the middleware vendor to update their code so their PCH files will be respected at design time. We have a feature coming up in the next preview of Dev15 that should also help. apologies again for poor followthrough on communications. you were very very helpful.
Ah, I'm not on that project anymore, sorry. May have been fixed in versions since, and doubt I'd be helpful.
Actually debugging is pretty good, but I still find myself using windbg for postmortem analysis. I don't have concrete feedback on this, but using vs for dump analysis feels insufficient.
ok thanks.
i think its the age that is the issue as most information aint bad its just outdated no longer following standards etc
I've just recently listened to large portion of the cppcon 2014 talks, and am starting into 2015. Most, if not all, are definitely geared towards the audience in attendance, which is, surprise surprise, C++ experts. That being said, I think there are some that beginners would really enjoy. [The 2014 keynote by Bjarne is good](https://www.google.ca/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjQwsDiyJfOAhWj8YMKHZscC_UQtwIIKTAC&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DnesCaocNjtQ&amp;usg=AFQjCNEJ01Gx3P9kWMQqog8AZGzYi1bhqA&amp;sig2=zzrBHHd2fh1TbmBavzQjmQ), and similarily, [Herb Sutters Back to basics talk is good](https://www.youtube.com/watch?v=xnqTKD8uD64). Particularly, I like that Herb goes out of his way to welcome new programmers to the language, and at one point he remarks that here are only a few dozen people in the world who really work on the super hardcore language implementation and core libraries, but there are 3 million or so people using C++ for application development, and that they (they as the language developers) need to focus on the 3 million developers, not the few dozen or few hundred super language laywers. I thought this was a good point. Other than that, Chandler Carruth's talks are good because he's such an engaging speaker, even if the subject matter is a bit advanced. If you know C or have exposure to C, [Kate Gregorys talk on "stop teaching C"](https://www.google.ca/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjIv_3eypfOAhWI1IMKHZV4ATYQtwIIIjAB&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DYnWhqhNdYyk&amp;usg=AFQjCNHL_BulZPi3el2xvc5kSkMDmrA7cw&amp;sig2=_DarvTHiEhKiF4d_sZu_lQ&amp;bvm=bv.128617741,d.amc) was quite interesting. As my language training years ago started with C, and I thought her point was quite insightful. [Nicolas Fleurys talk on C++ in AAA games](https://www.google.ca/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjF-8S1ypfOAhUm6YMKHWZ2CxYQtwIIGzAA&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DqYN6eduU06s&amp;usg=AFQjCNF9IswFVI3XLfN44JjoFbE9szwynA&amp;sig2=x4qzZmGsiRB5qwaWRmlSSA&amp;bvm=bv.128617741,d.amc) was great... I think beginners would find his from-the-trenches point of view interesting, however, I must add a huge warning and disclaimer - just because AAA games don't use exceptions and avoid the STL does not mean you as a beginner should as well. Anwyay, just a few suggestions. Note that these aren't the "best talks", but rather ones that I think beginners might benefit from. If you do have absolutely zero C++ knowledge, it would probably be best to at least spend a day or two reading and coding before investing the time to put into the talks. As most speakers have an hour, and the keynotes even longer, they aren't the typical 2 minute dense and slickly edited youtube tutorials you might be after. Microsoft Channel 9's hosting of mp3s and downloadable videos of the cppcon talks is a *tremendous* resource for the community. I've had to do some long distance driving recently and having downloadable mp3s of the talks to listen to in the car has been great. I definitely encourage Channel 9 to continue making mp3s and downloadable videos available for future cppcons and other conferences. 
*Michael ;-)
... which only works for CMake projects for now.
It looks like your problem is that VC doesnt generate an Error when it would be better too, not that ?: is 'inherently unsafe in VC'.
Yes, using Csmith. Read the *Testing approach* section here: [Introducing a new, advanced Visual C++ code optimizer](https://blogs.msdn.microsoft.com/vcblog/2016/05/04/new-code-optimizer/) 
Thanks for the explanation. I've also hit that problem with MFC's CString and the ternary operator, although in that case I definitely blamed the operator char* conversion operator. Do you compile your code with clang or gcc regularly? That would let you find these bugs. If you compile constantly with those compilers then you could safely use the ternary operator. It would be nice if VC++ would make this an error, or at least a warning. Have you filed a connect bug? I'd upvote it. 
i'm following up on this with the compiler guys.
have you seen the Visual Studio 15 new installer? any feedback? next preview should be significantly closer to a complete experience. we'll really appreciate any feedback since it is such a radical departure.
for what it's worth, the c++ extension for VS Code and all the VS C++ stuff are all developed by my team. (different crews, but using a lot of the same code). we're trying out new techniques and such in VS Code. Some people prefer lightweight editors over IDEs and VS Code is for them (and Linux and Mac).
Those two are the same thing.
Ah, maybe I should have mentioned that the project is huge. Well actually it's a collection of projects, probably spanning a few MLOC's with tens if not hundreds of makefiles, not that I'll be using all of them but I can use any one at any moment. Creating my own CMakeLists doesn't seem like an option, sadly. The project is https://github.com/libretro
I don't think videos from CppCon are for begginers. I mean - beginners can watch them to see the level of C++ experts, real production problems and their solutions, maybe notice some trends or news. But when people start to discuss some new proposal which will be (or maybe not) in C++20 - that's pretty useless for someone new to the C++ language.
Hi, could you find the main developer of the installer and punch him for me? The number of developer-days wasted by the installer must be huge. I dare say the installer wastes more man-hours than your optimizer could ever hope to save.
There is a [series of video lectures](https://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-) by Stephan T Lavavej /u/STL on channel 9. It still assumes some basic knowledge of C++. Update: he also made series on [Standard Template Library](https://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Standard-Template-Library-STL-) and [Advanced STL](https://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Advanced-STL)
Thank you for reporting 'fast text input after Ctrl+F'. It breaks the programming flow a lot and is one of those issues that lead to lots of frustration (hence the initial negative feedback. Overall, VS 2015 isn't that bad after all!) About the intellisense issues, I will first need to check what we can disclose. It's mostly that "jump to definition" would pop up the "Intellisense is working" dialog, which seems to never finish. Thank you very much for the offer though - it's very much appreciated! 
Java also has a signed byte, not an unsigned one. While an unsigned byte may make more sense it is not a good sign for consistency if they really added the boolean typedef to make it more Java like. 
This is my code. I need to see a self-contained repro. You should not be seeing my internal _Unforced type.
I agree with /u/xixor. &gt; isn't there more bad information about C++ than other languages? There defininitely is a lot of bad information/outdated information/myths out there as well as extremely opinionated, controversial subjects. Best thing to do is to take a scientific approach to it - be thorough and analytical, assess source credibility, actively seek out counterarguments to your beliefs and make actual experiements to test hypotheses.
Probably https://connect.microsoft.com/VisualStudio/feedback/details/1298009 - see if VS 2015 RTM fixes it.
This looks awesome. Edit: Closed source?
it's interesting, but I can't imagine it not getting incredibly cluttered in a large codebase.
Thanks! Yes, the core of Coati is closed source. Why do you ask?
Thanks for the answers guys, learned quite a bit from this thread alone! :) 
Yes, that was one of the bigger challenges when starting the project. We addressed this by only showing the information of the currently active symbol and also bundle nodes together in the graph if the diagram is getting too big. If you look at a codebase, there are some classes and functions that get used in a lot of different places. But because most classes just have a few dependencies, it's usually not too cluttered, but it really depends on the codebase you look at. 
&gt; In that case, what is the benefit of having one massive monolithic boost distribution? I don't know for you but in many linux distributions, all the boost packages are broken up by library. https://packages.debian.org/search?searchon=names&amp;keywords=libboost 
Hey. Nice trick. As it happens i was working with a c-api today, which uses callbacks with the exact style (void* pointer as additional arguement). But sadly this trick does not work on Visual Studio 2012. Consider this snippet: #include &lt;iostream&gt; typedef void (*test)(int id, void* userdata); void do_something(test callback, void* userdata) { callback(10, userdata); } int main(int argc, char *argv[]) { int blup = 123; auto closure = [&amp;](int id) { std::cout &lt;&lt; id &lt;&lt; std::endl; std::cout &lt;&lt; blup &lt;&lt; std::endl; }; auto wrapper = [](int id, void* userdata) { (*static_cast&lt;decltype(closure)*&gt;(userdata))(id); }; do_something(wrapper, &amp;closure); } Visual Studio 2012 complains, that "closure" cannot be implicitly captured benacuse no default capture mode has been specified. Is this a compiler bug? Gcc 5.2.0 works fine
Don't get me wrong - I'm not trying to pour cold water. The post was interesting and inspiring. I'm honestly interested in this, since I worked previously on trying to present lots of structured data in graphs, with the goal of exploring/studying the dataset, and the result was rarely as useful as I had thought when designing with small example data-sets. I would love some future example of the product used on some complex open source. How does the graph and search look there? It would help see the actual benefit. It's not that I don't think it's useful - it's just that I don't know how much improvement it gives vs built-in "Find All References" tools (I mean the good ones, not plain text search) and how much the graph is better in information presentation than a list/tree of connections. I appreciate the test offer - I'm not sure I can easily configure it right now in my dev environment, and I don't think my employer will shell out for it eventually, so I don't wanna abuse your offer for nothing :) 
&gt; I have worried about ending up with a bad book that the Wiki in /r/learnprogramming didn't warn about... isn't there more bad information about C++ than other languages? I am more mentioning bad C++ books as most of them are not bad just using older standards pre c++11 books 
Which is written in Java as far as I know. With all it's drawbacks.
You might want to take a look at how [nodejs](https://nodejs.org/en/) and [CEF](https://bitbucket.org/chromiumembedded/cef) do it.
Thanks for this suggestion, I have heard of QT Creator but never used it. I've downloaded the MSYS precompiled version as I've read this integrates directly with the MinGW on there. Sure sounds easier than getting everything to work in VS. We'll see how it goes.
From looking at those graphs it really is not immediately clear what code is doing, to me at least. And examples are tiny. Navigating while clicking things in graph looks cool, but if i have to read source code to understand whats going on anyway i would prefer clicking things in code instead of doing brain-context-switching between graph and source.
Code fails also in http://webcompiler.cloudapp.net/ which reports Jan 2016 version of MSVC. I guess it's a compiler bug, not sure. You can work around it like this though: using closure_t = decltype(closure); auto wrapper = [](int id, void* userdata) { (*static_cast&lt;closure_t*&gt;(userdata))(id); };
We designed the graph to provide an overview, but as you mentioned looking at the code is still the most important thing. Therefore we keep the codeview next to the graph to show all the relevant locations. Hovering a symbol in the code highlights the corresponding element in the graph and vice versa. And you can click symbols in the code view as well! :)
Do you plan to make money out of individual developers or corporations? I'm sure you have thought about this, but you could still license your software as pay to use by companies/on closed-source projects, and free to use on open-source software and by students. I mean, you say that after using it for 6 months you cannot live without it anymore. Imagine if other students start using it now. In 2-3 years when they are at a company they'll push for your software to remain productive. I understand you'll be worried about people using it "illegaly" if it is easy to do so, but those users are the ones that would crack it in the first place anyways, and maybe when they land on a company where they cannot do that they will still push for it. Having it as open source would also allow those studying or working on open source to improve your software, and maybe allow you to find good new hires. If you ever get to write about your business model, and how the application for the startup funding went, and what you learned, ping me. I'm sure that would also be a very interesting thing to read! Good luck!
I though double underscores were illegal, the implementation could define a __Macro, no? 
I agree. You usually can judge books by their first publishing + at least one year it took it to write. There is classics which stay valid, and ofc other books which get outdated fast. As a beginner you should have one book which is a good introduction into the language (stays valid many years) and maybe a book giving a more complete view/reference on the standard, but pages like cppreference are a good replacement of such books. But sometimes its just better to have some paper to read through.
Hmmm. You know what, if it's ok with eating up visual studio SLN's I might try it on some legacy code in a monster project I worked on last year, and ping you back with results. A lot of the code is windows kernel API and windows kernel MACROs so It'll be a good challenge ;)
Same boat here. Having the ability to navigate a ton of spaghetti code in the form of VS project would be incredibly helpful. Looking forward to trying this on Monday.
In short: We thought about that a lot and came to the conclusion that it is companies where we want to make money. That's why we are licensing Coati in two different ways (private/academic and commercial). Right now both kinds of licenses are relatively cheap but with the release of Coati 1 in late fall 2016 the price of the commercial license will rise to a level that is more common for dev software. On the other hand the price for a private/academic license will stay relatively low. What we definately can do is making deals with universities so that the students can get free licenses!
Take a look at how to make C++ addons for node.js: https://nodejs.org/api/addons.html There are lots of blog tutorials out there as well- but this will walk you through the entire process. 
Sounds great! So just e-mail us for a test license :)
Closed source? -1
The *tic tac toe* example is good. I would love to try take a look at my own c++ project without having to obtain a temporary license. Great article.
Thanks, if you want a test license please write to support@coati.io
Remember to support other open source hosting sites (BitBucket and SourceForge for example) and not just a single one (GitHub) if you want even more people to be able to test using the tool and bring in potential customers. 
Cool. It would be great if visual studio could deal with variadic templates as that's a pretty fundamental use case of variatic templates :)
I agree with Jens (meetingcpp). Part of the reason that we don't have more beginner talks is because our surveys of attendees indicate that we don't have that many beginners attending. I hope that changes as the conference grows. I'd love to have more beginners and hope one year to introduce a beginners' track. But this doesn't mean that the videos that we do have won't be valuable, it just means that not all of them will be appropriate and you'll have to do some screening. But that's true for everyone, no matter what their experience or domain.
Yes, we should definitely add a more complex sample project. I'm not sure if we can take the clang source code and distribute it that way in terms of licensing. Is that possible?
Thanks for the guidance. If you are interested in doing this more formally, please contact me at jon@cppcon.org. By the way, Chandler's last name is Carruth.
Why? There is CLion for Windows. Or are you saying ReSharper C++ is better? 
An alternative to nodejs is Qt which has a native integration between Javascript and C++ objects : http://doc.qt.io/qt-5/qtqml-cppintegration-topic.html
I thought I would write this to clarify the OP's post and address concerns raised by /u/jbandela and /u/tcbrindle. I've had a similar thought for a while. This is a good idea in principle because every single time you write a function that takes `const vector&lt;double&gt;&amp;`, or `const unordered_map&lt;string, int&gt;&amp;`, you are over constraining this function. Namely the function can only operate on those types of containers with the standard allocator. Yet, no functionality from the allocator can be used (well, without const_cast....). So why bother constraining it this way? There's even a talk that Chandler Carruth gives where they discuss allocators to solve the issues with certain containers, and he points out that the allocator is actually hard coded to the API boundary and cannot easily be changed. Transitioning to a Q&amp;A format to address concerns. &gt; Isn't this solved by iterators/ranges? No. Iterators/ranges deal with iteration. In the particular case of random access iterators, they happen to mostly duplicate the read-only interface of the most common data structure, `vector`. If you think about wanting to pass a view of an associative map, you'll see that iterators/ranges do not help you. &gt; Can't you just template the function? You can of course solve the problem with templates, or concepts. You can write template &lt;class A&gt; void foo(const std::vector&lt;double, A&gt;&amp; x); But the reality is that template functions have downsides. As OP noted, they have to be in header files. They cause code bloat. That is, in this case you have many functions instantiated which will be exactly identical. They don't obey the same rules as regular functions for implicit conversions. In practice, almost nobody writes code this way. The standard allocator is quite ubiquitous, and people will write huge libraries assuming it everywhere, causing a lot of work if you ever need to change the allocator. I'm not sure if I like implementing this via inheritance, but I think that "views" would be great. If I was writing a new STL tomorrow, I would base things around views, and treat them as a generalization of ranges.
This is extremely interesting, but I as with all highly promising tools I'm skeptical regarding it's usefulness. Any chance you can analyse the chromium (or other big project) codebase and show how a it would help implement the show fps button for example? That would be an example I'd love to see.
I am saying that Visual Studio is better, specially the architect version which can even do code navigation across binary libraries. Many aren't aware of these features because only enterprise Microsoft shops tend to pay for it.
Yes, that would be a great follow up. We are not scaling to extremely big code bases yet, but we are working on it. We recently posted about indexing clang which works nicely and has roughly 1 million lines of code: https://www.coati.io/blog/indexing_clang_with_coati_using_clang/ 
Personally I'm most interested in Clang. How big the pre-analyzed file would be with and w/o LLVM?
 #include &lt;future&gt; struct A { void Foo(int i); private: void Bar(); }; void A::Bar() { auto tester = std::bind(&amp;A::Foo, this); auto f = std::async(std::launch::async, tester, 2); } f, in A::Bar(), is of type std::future&lt;std::_Unforced&gt;.
I don't have any exact numbers here right now, but I think for Clang with LLVM it is more than 1gb large. Which (in my oppinion) is too large for a download in the trial version. But I think we'll soon have time to optimize that file and bring down its size :) So I can imagine these preanalyzed projects to be optional downloads.
Of course I want to hear it. That probably means that I will never use Coati though. I develop free software, and that means that I cannot use non-free software, because that would imply forcing non-free software upon others.
&gt; I develop free software, and that means that I cannot use non-free software, because that would imply forcing non-free software upon others. This is a tool, not a library; no one is "forcing" anything on anyone.
At its current price it's worth picking up even just to play around with it. I'm really excited to give it a try :)
`A::Foo` isn't callable without a parameter, so `std::bind(&amp;A::Foo, this)` is ill-formed. Try `auto tester = std::bind(&amp;A::Foo, this, std::placeholders::_1);` instead.
The article mentions Chrome but it doesn't show any examples of a large code base. I'd love to see how this hold up on very large projects where the code can't fit in your head anymore instead of a toy program like tic-tac-toe. I think we need more C++ tools and I'm glad whenever I see people taking risks and exploring that space! 
Yes. And with my current development build, this emits a hard error, `type_traits(1570): error C2672: 'std::invoke': no matching overloaded function found` (I would expect 2015 Update 3 to behave identically).
That is both beautiful and horrifying. Respect.
The diagnostic is terrible for two reasons - my code got confused by the bogus invocation and went down the wrong metaprogramming codepath (not detected by tests, because bind doesn't have to SFINAE), and the compiler can't help but print out every level of my metaprogramming. The diagnostic for an actual call is comprehensible if and only if you are extensively familiar with how I implemented invoke, which is probably limited to me at the moment. Heh. (The key bit is that it says `_Rx=std::_Unforced` in the context, which should never happen.)
Oh my god I love this.
[Online example](http://ideone.com/uCTm0X)
... This is why C programmers don't like us, guys. \*copies code snippet\*
It's a tool to help _you_ develop code. Why would you force a dev tool that's not required for the build process on anyone else? This whole line of reasoning is absurd.
It will lead me to recommending the other developers about it. I'm just playing devils advocate. My main reason not to use it is because it is non-free, and I very much dislike everything that is non-free.
I see. I should have compiled first. ;)
&gt; I'm cheap. 
nice! :)
What kind of wizardry...
unary negate returns a template type. The compare operator is overloaded for it. That's about it; pretty basic template meta programming. a &lt;- b; Can be decomposed into: a &lt; (-b); 
Yes, in fact, I am. People that say "I like Visual C++, you have to use it for this class" and "I like Coati, you have to use it for this job" is forcing it upon me. First case I'll quit the class, second case I wont take the job.
No, I'm actually pretty expensive. I think you read free as in no cost, instead of free as in freedom.
As a fellow Chrome Graphics developer, this looks great! I'll try it out on my personal projects at home.
Doesn't overloading the unary minus operator like that really fuck shit up? If I have: int i = 5; std::cout &lt;&lt; -i &lt;&lt; endl; what will I get?
Using capture by value does indeed solve the problem in this case. For the bug to happen, one requirement is to have a function with parameters by-ref that gets inlined, and after inlining those parameters should be replaced by local variables.
Visual C++ is a compiler; even if not ideal, it makes sense for that to be a project requirement, especially for a Windows-only product. Coati is a code viewer/navigator. Do you really not see the difference?
Yes you can set up projects from Visual Studio Solutions or compilation databases exported from CMake: https://www.coati.io/documentation/#ProjectSetupWizard Or you can just manually define project paths, include paths and compiler flags. Thanks, the website design was done by friends of us from http://www.edgycircle.com/
Ok. thanks for checking. I guess that makes sense since the default behaviour for the minus unary operator for integers is more type specific that this templated implementation. I guess this code should be safe provided no one implements unary operator in the exact same way, at which point we would get fairly obvious compile time errors.
I await the first implementation of this hack that enables Haskell-like do notation in C++. Literally, I will co_await on it.
Some men just want to watch the world burn.
While I appreciate your drive for only using open source everything, that is a situation for you and not for everybody (or this product). People use Windows. People play AAA games. People have iPhones. You have a valid concern. But it is a restriction on yourself, and shouldn't become a viral restriction for everything you look at. If this product doesn't fit your restriction then so be it.
http://melpon.org/wandbox/permlink/FmCGjJ8WVLt8ABf4 Still can't figure out a way to get it to print `f` or `g`... really not sure how it works at all!!
The vector could contain both. The string could have been modified. I can't tell enough from your example to describe the problem because there isn't enough to compile and there's a lot there that's certainly not "standard C++".
Which is still missleading if the type names were meant to reflect Java. 
That may be true, but how many things in life are free anyway?
We use Clang LibTooling for indexing of C/C++. We need all information for building to run our indexing which generates a DB. There are 3 options for project setup: - manual: define project paths, include paths and flags - compilation database: load a clang compilation database. It can be exportet from CMake with CMAKE_EXPORT_COMPILE_COMMANDS, or generated from other build systems with Bear: https://github.com/rizsotto/Bear - Visual Studio Solution: load an existing .sln file We are constantly working on raising the upper bound of project size. For me Coati currently runs smooth with projects up to 2 million lines of code on my laptop with an 2,4 GHz Intel Core i5, 8GB RAM and 250GB SSD. 
nein danke.
Good, now we need to figure out how to pass parameters.
When you want to have a laugh.
It's the same as `(&amp;x)-&gt;*fn` (which is in turn the same as `x.*fn`). See [pointer-to-member access operators](http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_pointer-to-member_access_operators).
What I would love to see is a really nice simple easy way to detect if the vs c++ build tools have been installed and some build+run buttons added. Actually having a preferences option to specify what compiler we want to use (and provide the path as an option) from within the gui without having to edit Json files. If someone new to c++ could install vs15, mingw or icc and add them to vs code in an easy way and just have a run button/shortcut, this would make the barrier to entry for c++ so low. 
I've also seen people introduce operator `---&gt;` as an agglomeration of `--` and `-&gt;`.
the arduino IDE is the old processing IDE actually
Overload the comma operator for the new type returned by operator&lt; for larrow.
If you started in 2012, you must refer to C++Now, as CppCon started in 2014... You might also like the videos from last years Meeting C++: https://www.youtube.com/playlist?list=PLRyNF2Y6sca0UKKZ2PTSwF3WrDjABQdcL
WHY
This looks really useful. But: &gt; The trial version of Coati includes all UI features, without providing source code analysis. You can use it to familiarize yourself with Coati's UI by exploring our pre¬≠analyzed TicTacToe project written in C++. In order to analyze arbitrary code, please purchase a license [...] Seeing how it works on your pre¬≠analyzed TicTacToe does not help at all to evaluate whether Coati is something for me/us or not. One of the biggest unknown with such tools is how well they're able to analyze an "arbitrary" code base. And exactly that the trial doesn't allow! Does it have any CMake integration or how does it fare with small/medium-sized projects that are built using CMake? What about analyzing a header-only library? Some tools fail at that and produce zero output... How well is it able to resolve symbols and dependencies in these scenarios? I understand that I could drop you an email and would probably get a test license - but in the long run, you'll shy a lot of people away that are put off by this. If I can just download and quickly test (and not email, wait, ... come back to it, ...), I'm much more likely to evaluate it instead of just closing the browser tab. A suggestion: Make it free for open-source projects. That seems to be a very successful business model.
A screenshot would be appreciated! I'm on Linux right now, I quickly tried building it but I guess some shaderc-related stuff is missing. I was really just curious what it looks like - I don't have any experience with SPIR-V.
right now the tool is windows only. I'll also add a screenshot 
I'm curious, would your opinion change, if the tool was still closed-source, but free to use for open-source projects?
Alignment: Chaotic Evil I love it!
&gt; Visual Studio Solution: load an existing .sln file Can I also just throw bunch of .vcxproj into it? Or does it have to be .sln file? I'm kinda worried of making 300+ projects into one .sln. Last time I tried I gave up, took too long time to do than in VS.
I get your point, just would like to point out that I got the test license in like 2 hours, so atm the waiting time isn't that big
screenshot added 
Here you go: http://melpon.org/wandbox/permlink/j1OSxa3qEnbaHsg1 I went with /u/foonathan's suggestion of overloading `oparator,` for a temporary struct. I'd love to know how to do it without packing the arguments in a tuple though...
hm, I never actually looked inside .sln that much, thanks for the tip, will try to script it somehow
thanks. that's good feedback. I just sent it to the PM designing these experiences. 
&gt; In the real world, you deal with OOP whether you like it or not, unless you go out of your way to avoid it, which is a silly thing to prioritize over factors like company culture, software purpose, impact of what you get to work on etc. That doesn't make it not suck. And you can always choose to write non-OO code even in a mostly OO code base. &gt; The Linux kernel is the way it is because of its contributors, not because it chose the "right" paradigm. The Linux kernel is the way it is partly because it's written in the simple and straightforward C and not in say C++, a language which enables the use of counter-productive abstractions like OOP. Linus himself says so.
Maybe you can do a closed-sourced project without a team, but /u/rubdos (the first post you've responded) was talking about free software projects: &gt; I develop free software, and that means that I cannot use non-free software, because that would imply forcing non-free software upon others. In free software development you've got no team only if the development is over or nobody needs your software.
In an ideal world, maybe. The truth though is that there are thousands of pre-existing codebases that are already written in an OOP fashion. Many times they are too big to be rewritten. Perhaps you're right and Coati won't be useful in the future. But for now, having a tool that helps you explore monster codebases will be helpful. EDIT: spelling
On mobile now, and had a beer. So no link, bit I think it's called bitkeeper. You can Google on the creation of git. Anyhow, the Linux people tried to reverse engineer the protocol of the scm, and the devs of the scm didn't like that, so kinda revoked their right to use it for free. Linus then said "I can make something better over the weekend", and he did: git.
Okay, for that _loose_ definition of "team", you really think anyone cares what tools anyone else on the "team" is using to _read_ code? That's like thinking anyone cares what text editor someone uses, or which terminal app, or which diff tool ‚Äì they don't! No one gives a shit! This conversation is lunacy. Have you even looked at the product being promoted here? (rhetorical)
I've actually been doing something relatively similar. I've been trying to mimic `std::vector`. https://github.com/SandSnip3r/Imitation-std-vector And I must say, I've already learned a ton and I'm still a little ways from being done.
Cool! Does the GUI support keyboard shortcuts like Tabbing, Alt+&lt;Key&gt; shortcuts, Home/End etc., Shift-tabbing, and so on? I don't know imgui that well but "native-like" keyboard shortcuts would be important before I consider using a tool like this.
In my opinion there's enough great beginner's talks online. The keynotes from GoingNative '12/13 are very suitable for beginners, I could name you at least 1 to 2 more talks from each of these conferences, and then the same for CppCon 2014 and 2015. That makes at least 8 great talks for beginners, and after watching these plus some hands-on-coding, a beginner should be ready to watch the next set of talks.
I wonder who implemented it in Visual C++'s STL.
&gt; If you write code like that [...] It's a joke. &gt; I wouldn't call &lt;-- an operator [It's also a joke.](https://stackoverflow.com/questions/1642028/what-is-the-name-of-the-operator-in-c)
It's a shame you didn't use a cross-platform ide especially considering how diverse the c++ community is
Probably because most IDEs still recommend .h files instead of .hpp, many you have to go out of your way to make it use .hpp 
&gt; This convention reflects a common use pattern: Headers are more often shared with C to compile as both C++ and C, which typically uses .h, and it‚Äôs easier to name all headers .h instead of having different extensions for just those headers that are intended to be shared with C. This is a bullshit reason imho. Most of my c++ headers contain template stuff, not meant to be shared with C at all. 
&gt; Visual Studio's "Win32 Console Application" presents you with the following No, it doesn't (it's actually worse, because it's `_tmain` and stuff).
That's how it used to be. Visual Studio 2015 Community Edition doesn't have "_tmain and stuff". That's proof that the templates *do* change.
Thanks for your reply, I understand your motivation. 
The extension `.cc` seems to be more popular. Then there is `.cxx`, `.xx`, `.c++` and `.C`. I don't care anymore as long as it's consistent in a single project.
Hi Tom, it is good to hear from you! I would suggest just modifying the library. The implementation is quite short (and just one header, no source). Just search for "micro" and make it behave more like "nano".
This is the result of using `bcp` to extract `boost::optional` from the distribution (after removing the documentation): qis ~/boost du -hs boost/ 3.3M boost/ qis ~/boost cloc boost/ 327 text files. 327 unique files. 58 files ignored. https://github.com/AlDanial/cloc v 1.66 T=0.53 s (615.5 files/s, 82230.6 lines/s) ------------------------------------------------------------------------------- Language files blank comment code ------------------------------------------------------------------------------- C/C++ Header 327 5454 6794 31437 ------------------------------------------------------------------------------- SUM: 327 5454 6794 31437 ------------------------------------------------------------------------------- Don't get me wrong. Boost is awesome! Sadly, due the primitive nature of `bcp` and the fact that boost libraries are highly dependent on other boost libraries it is impractical to distribute it with smaller projects. I would like to hear the opinion of boost developers on the practicality of splitting boost into two versions. One for older compilers and one for C++14 (or rather C++latest) compiles that does not rely on redundant classes which were accepted into the standard library. Sure, there is a minor benefit in using e.g. `boost::thread` instead of `std::thread` but there are also drawbacks.
It's two characters shorter.
This is available on all US/international keyboards. ¬µ!
I do that often, allthough i name them .tcc. The reason is simply the fact, that all the template implementations are not needed for understanding the class, and only the class is needed. So, if you want to get an overview, having only the declarations is fine. And the implementation are than in another file to separate them (allthough it is included in the .h) 
It's like the entire Ripple C++ team is on here üòã
I filed a feature request for loading .pro files, but I don't think it's a priority at the moment: https://github.com/CoatiSoftware/CoatiBugTracker/issues/124 Coati can handle all source files that can be compiled by the Clang compiler, we are using Clang LibTooling for indexing. The generated moc files can be analyzed, the only question is if the resulting source code is of any interest. We using Qt as well. We index our source files that make use of Qt classes, without indexing the Qt classes. Then all Qt classes show up as undefined, but you can see all the places where they are used within the source code. Only thing that doesn't work is seeing SIGNAL to SLOT calls.
You are arrogant. That's it and only it.
Are you talking about supporting qmake .pro files? I just opened a feature request, because another user asked: https://github.com/CoatiSoftware/CoatiBugTracker/issues/124
I find this quite annoying too. I strictly use .hpp for C++ headers, and .h for C headers. I think that's the best way to do it :-)
Iiiiih. Sorry to say it, but: Never design a GUI without native look &amp; feel &amp; behaviour! It's sooo annoying as a user. If a GUI framework doesn't support that by default, it's useless for desktop applications in my opinion. Use a different one. I even get annoyed when UIs in _games_ don't behave like you would expect from a "normal" Windows / Linux desktop.
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I tend to just implement them out-of-line in the same file. You still get the naked interface at the top for quick reference and still only have one file. But that's just opinion.
In my experience .hpp is used for headers that have code in them, like templates. .h is used for class, or structure declarations or simple procedural signatures.
Thats also a good way.
&gt; How should we verify what Coati is used for? Well, for this, you can put a form where you can apply and have to give a reason and/or open source project name you're going to use it for, optional or mandatory even with an URL. Of course that's again not an immediate download. But at least in my opinion there's a big difference between "Writing an email to get some sort of test license which will be completely unknown for how long it exists or for how long it will allow me to use Coati", or "Filling out a form to apply to use it with an open source project, giving it a defined license context I can count on". Of course in the end, you can't verify for what _other_ projects a user might use it on, but that's what the law is for. And no company will risk using a software it doesn't have a license for.
Thanks, seems good with 200 pages. Any other suggestions?
Compiling != linking, for one thing. Also, in VS you can add a file to your project without it being configured as a source file.
Unter anderem. I don't know if that's already the case, but it would be nice if I could still use Qt Creator (or any other IDE) for editing my stuff while having Coati open somewhere else and the changes would be applied at the same time. I, and probably many other users, probably don't want to switch IDE for Coati.
[It's a pretty universal agreement.](http://www.bipm.org/en/publications/si-brochure/section5-3-3.html)
Cool! Great link. I just researched a bit more on myself. I really didn't know that, and unconsciously I think I often did it wrong, or wondered about it. Thank you :)))
What would those be?
That's actually a useful distinction, I'll use this from new on, thanks!
Is there any you'd recommend? 
 the assumption that people who work for Google are incompetent. I think it has more to do with the fact that most of their developers are far more competent in other languages such as Java, PHP, Python etc than they are competent in C++. Hence the need for a coding standard that attempts to make code written in C++ look as much like Java/C#. That being said, from what I can tell most Google engineers are generally *competent*. 
In terms of just the basics quickly, [cplusplus](http://www.cplusplus.com/doc/tutorial/) has a language tutorial. Yes it starts with initialising a variable but you can skip that down to the classes part. In terms of the STL [cppreference](http://en.cppreference.com/w/) is a good website that shows you what's available and what you can do with it all. Start off with [`std::vector`](http://en.cppreference.com/w/cpp/container/vector) which should be relatively easy to get your head around (examples down the bottom of the linked page). Once you think you've got the extra language down pat, Scott Meyer's effective C++ is excellent for examples of how to use it without shooting yourself directly in the foot. Finally, just because you're in C++ doesn't mean you should go object crazy. I only use objects when they define a clear type, a multidimensional array, a resource managed handle to a C library resource for example.
codelite, eclipse, qtcreator or clion(although clion is not free)
If you really wanna impress interviewers, learn more than just OOP. These are some things that I think are more attractive than knowing objects (knowing OOP is basically just a standard these days): * `enable_if` and the other stuff in `&lt;type_traits&gt;` * move semantics, reference collapsing, argument forwarding * iterators, including how to use `iterator_traits` * when/how to use everything in `&lt;algorithm&gt;`, `&lt;functional&gt;`, especially together * ability to work with `std::promise` and `&lt;thread&gt;` and the other C++11 async stuff Also, being able to implement your own STL-compliant containers is a huge boon. Half of C++'s power is this ability to separate interface from implementation and generic programming and iterators give you quite a bit of room for flexibility.
Ok, now you _have_ to come see my chrono tutorial this Sep at Cppcon 2016! :-) It is dangerous in the same way that it is dangerous to `reinterpret_cast&lt;T&gt;(u)` from type `U` to type `T`. The type system can no longer protect you from some logical errors that it could without forcing a type change. It provides run time opportunities for errors such as mistaking milliseconds for seconds, or durations for time points, or dollars for minutes. If you can stay within chrono's type system, such run time errors are detected at compile time, or in the case of changing duration units, are accommodated correctly.
Very bad book in my opinion, didactically. It's a good **reference** though.
&gt; I am pretty adept to C language and would like to learn C++. &gt; No video tutorial/Coursera please Sorry, but videos from GoingNative 2012, 2013, CppCon 2014/all following are one of the best resources to accomplish exactly that. Not saying there are no books, there are, but the videos are great.
I like how you took special care to make sure your naming conventions matched the standard library...
Can you provide me with a link? Google doesn't seem to consolidate a playlist. Thanks for suggestion. :)
I thought they were more like do's and don'ts book? I will check em out. Thanks for suggestion. :)
That's just wrong.
*I assume you are taking about `CamelCase`.* I see you didn't take special care to check what naming convention I use in whole library... ;) And since when naming convention from standard library is something people actually follow? From my experience most people use `CamelCase` instead of `snake_case`. If it's a problem for someone i guess it's 10 min to change it. At least i'm consistent with it. In truth if you use external libs you will almost certainly mix those because everybody uses their own naming conventions.
Because it doesn't matter and consistency is nice (`.h` implies a header file). C++ standard library doesn't use any extension at all (e.g. `&lt;iostream&gt;`). 
This is off-topic here. You want /r/cpp_questions.
correct! we do change them. This is a really interesting piece of feedback. It's always interesting what becomes invisible after time. I think the main issue here is that templates serve two purposes: 1) give you an easy starting place 2) helping you fall in what we call the "pit of success" for best practices. pch usage makes such a huge difference to developer productivity and what starts in the template today over time becomes somebody's legacy code base in 20 years and so we like to make sure people get started on the right foot. Let me run this by our PMs and see what sort of ideas it generates. I'll also see if I can get the answer to why these are called stdafx... i'll be one of our veterans knows.
The sentiment stands, then: learn far more than just OOP. That's one tiny little tool in a big toolbox, and one that has a bad rap these days (unfairly, perhaps). In C++ you can at least easily study declarative programming styles (template meta-programming), functional programming styles (also template-metaprogramming, and also the significance of value types, const everywhere, lambdas and std::function, and avoiding state mutation), imperative styles (more C-like code), concurrency fundamentals like actors and coroutines and channels, and so on. You don't need to know all that to be a good C++ programmer. Heck, most C++ engineers _don't_ know any but a tiny fraction of all that. Since you're on a (very respectable and good!) quest for self-improvement, though, study all of it you can. When you boil down C++ to just "STL and OOP" you're basically doing the same as boiling down English to just "adverbs and participles." :) Note also that you can do most of the STL in C (albeit with type-unsafe macros) and you can do OOP in C as well (the Linux kernel has a _lot_ of heavily object-oriented design in it and is 100% C/assembler). Languages make certain designs easier or harder, but no language is a necessity for any particular software design. If you think your interviews will be focused on problem solving, focus on learning how to solve problems (e.g. _why_ you should use OOP, _why_ you should use functional programming, etc.) rather than learning a particular new language.
So it's case insensitive? That's a terrible design choice that I thought died with Visual Basic.
Not really so rare of an opinion (I had a similar experience and know others who did the same).
There is some stuff in the code that would prevent me from adopting it: - macro abuse (can/should be replaced by a function): #if HTTP_PARSER_STRICT # define STRICT_CHECK(cond) \ do { \ if (cond) { \ SET_ERRNO(HPE_STRICT); \ goto error; \ } \ } while (0) # define NEW_MESSAGE() (http_should_keep_alive(parser) ? start_state : s_dead) #else # define STRICT_CHECK(cond) # define NEW_MESSAGE() start_state #endif - bad names `http_parser_execute` (what's wrong with "parse", "consume", , which is what the method does?) - you pass arguments by pointers, when references should do - `goto error;` 
This is the book which was recommended by the "2015 authors panel" in C++ conference, for introduction to modern C++ programming. Authors panel consisted of C++ book authors, so yes, this is the book you want.
Is there any timeline on when a fix for this will get released? I suppose you already have it fixed internally, but it takes a while to get through all the testing protocols. Maybe an "unofficial" hotfix release would be possible?
Algorithms &amp; containers in this blog series may be worth getting familiarized with: https://marcoarena.wordpress.com/category/competitive-programming/ Try practicing with all of the following yourself: http://en.cppreference.com/w/cpp/algorithm
Yes many users say that they don't want to switch applications. But having Coati as a separate tool allows us make Coati available to all developers of a certain language, not only those using a certain editor or IDE. With our plugins we make the application-switching smoother: https://www.coati.io/documentation/#CODEEDITORPLUGINS You can set Coati to automatically refresh when changes happen, but I personally don't use this feature. Constantly re-indexing files that changed is more annoying than useful. Also you sometimes have an in-between state while developing that still causes compiler errors. Coati then fails to index theses files as well.
On standard Windows US keyboard layouts you can type it with alt-codes: alt 0181 or alt +00B5. On Macs with the standard US layout it can be typed with option-m. In vim it can by typed as a digraph using \^KMy
I did but here comes the infamous but. It seems nodejs was created using V8 engine. What I'm trying to do is, see how the V8 engine becomes a javascript engine using C++ functions. It lets the programmers just type in whatever syntax associated with the standard javascript engine and gives the javascript programmers the implemented version of the C++ functions. 
none
Spirit for creating syntax parsers for my language Thread due to mingw being a little sketchy on thread support on windows
Filesystem. Boost::Python is also awesome.
Boost.Random for a `random_device` that's not broken; Boost.Range, string algorithms, Boost.Tokenizer; Boost.Variant, Boost.Optional, MultiIndex containers; Boost.Container with a non-broken `vector&lt;bool&gt;`, `type_info::name()` demanglers, `boost::lexical_cast`, `boost::numeric_cast`. There's a lot of useful functionality I use regularly which isn't included in the standard. 
Just watch all the keynotes first, starting from 2012. Then you might have the knowledge to go from there by yourself. I've posted a list probably several times before, just search my username for this subreddit. There are other lists as well. There are quite a few talk gems (e.g. Sean Parent's Seasoning talk springs to mind).
Not using all of these at once of course, but over the last three or so jobs I used, in production (excluding what's in C++11): asio, any, container, crc, date/time, dynamic bitset, filesystem, GIL, graph, interprocess, intrusive, iostreams, lexical cast, multi-index, optional, pool, program options, range, serialization, spirit, statechart, string algorithms, tokenizer, variant And even things that are nominally in C++11, like thread or regex, have been evolving and growing new useful features since they were snapshotted for the standardization ~10 years aog
How's `random_device` broken? 
It isn't required by the standard to be non-deterministic, while boost is non-deterministic.
Serialization, FIlesystem, DateTime, ASIO. I try to use std when I can, but last I looked, there was no timed join in the std::thread stuff.
Off the top of my head: * optional * small_vector * begin/end * range stuff * ublas matrices * graph stuff
Filesystem, program_options, graph, serialization, dynamic_bitset, and I really want to modify existing code to use boost::units.
Spirit, Optional, Uuid, Range, MultiIndex &amp; BiMap, Container (mostly small_vector, static_vector and flat_map, flat_set), CallTraits, Iterator (esp. IndirectIterator), Align
program_options, lexical_cast/string algos, optional, signals2, serialization
It is written as do's and don'ts indeed, but some of its do's are somewhat broader in nature ("Do familiarize yourself with X") and the overall outlines of his books are meant to progressively improve your overall C++ skills bit by bit, rather than simply providing an index of quick tricks. If you really want to use C++ professionally, I highly recommend going through all of his books at least at some point in your career. The next best resource for learning idiomatic C++ is Herb Sutter's Guru of the Week series, particularly [#91](https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/) if you want a good grasp of smart pointers. The only things I feel that article to be missing are 1) prefer references over raw pointers (not always, but most of the time) and 2) avoid `std::shared_ptr`, it's almost never a better option than `std::unique_ptr`. You may also want to check out the [Core Guidelines](https://github.com/isocpp/CppCoreGuidelines) for brief do's and don'ts. Note: General C++ advice applies generally, but some applications may require going against general advice. High performance domains, like AAA gaming, tend to not afford the overhead of general-purpose containers like the ones in the standard library, so they use [non-standard, performance-focused ones](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html), or implement their own allocation strategies etc. . The standard algorithms are fine though - one of the special things about C++'s approach to algos is that they work on iterators, not containers, and they sometimes have the liberty to choose faster implementations if the iterators satisfy particular requirements (like being [bidirectional](http://en.cppreference.com/w/cpp/concept/BidirectionalIterator), random access etc.)
A VS micro-update with a fix for this bug should be released this week.
You should talk with Google, its [Chromium repo is full of `.cc` files](https://chromium.googlesource.com/chromium/chromium/+/master/ui/views/).
This is the worst thing I've read all day. :(
Just a small correction, I noticed you used "wildly" in two of your comments when I believe you meant "widely"? FWIW, I agree with you, and wish that there were a standard for naming conventions for C++, but it's probably too late. Modern languages have the advantage of hindsight and are making naming convention part of the language, failing to compile if you don't comply. Perhaps C++ could take Python's approach with PEP8, providing a mechanism for transforming your code to a standard, or at least reporting inconsistencies. 
At my work place .H and .C are common for C++ files... :/ Edit: Also, indents are three spaces.
You can change the layout if you wanted, it doesn't affect anything else in my US keyboard other than adding the capability of using √±, √º, √∫, etc. 
&gt; Boost.Container with a non-broken `vector&lt;bool&gt;` More importantly (for me), Boost.Container with non-broken support for incomplete types, so that e.g. the following works. struct node { vector&lt;node&gt; children; };
I‚Äôm surprised by how few answers here mention Spirit, it‚Äôs *extremely* versatile and can/should be used to build even small parsers for everyday use (such as file formats, user input etc).
Networking is such a basic thing. It's so strange that only now people are looking into standardizing it.
The ones I use most are asio, filesystem, optional, and algorithm. In one of my recent projects I needed regex, so I figured I'd use the C++11 std::regex. I found that the performance in libstdc++ was awful at the time - no idea if it still is (this was within the past year) - but replacing it with boost::regex gave me a ~11x speed improvement. This experience has made me a bit wary of adopting newer parts of the standard library.
Because .h is more widely used. Sometimes the only reason to do something is that it's the usual thing to do.
Completely agree with you, every single time I have tried to learn it in my free time I end up procrastinating with any other stuff.
&gt; http-parser.h/.c is joyent's parser written in C (used in node.js, inspired by nginx). If you have any suggestions for a battle tested http parser to replace it, let me know. Otherwise, a port to modern C++ is needed and anything anyone contributes will be considered.
You can use vscode and make a pseudo makefile with a batch file that will call g++ and all of your .cpp files. 
Your English is great regardless of whether you're a non-native speaker. Clang-format is an interesting tool mainly interested in solving the whitespace problem, but I'm sure it would be capable of handling naming conventions as well with some extra work. Edit: clarified first paragraph
* filesystem * variant * hana (I **love** this library... this should be in STL) * compressed_pair * preprocessor (necessary evil for implementing reflection) * numeric cast * lockfree queue * signals2 All I can remember from top of my head. I try to keep my reliance on boost to a minimum.
optional https://raw.githubusercontent.com/cjdrake/boolexpr/master/include/boolexpr/boolexpr.h
This post was very useful for me. Having recently picked up C++11 (learned legacy C++ long time ago, didn't use Boost), I was kind of intimidated by the large volume of Boost features and didn't know where to pick up. I heard a lot of important features in Boost were incorporated into C++11 (and further into C++17), and didn't know what extra I needed to pick up from Boost. This post exactly answered that question. Thanks!
nice, thanks for these!
Non-native look is fine i think, but reasonably native keyboard shortcuts is a must.
I honestly think that for smaller things like file formats a library like PEGTL (https://github.com/ColinH/PEGTL) is a way better fit. But that's just my two cents.
Ahh ... didn't know that ... Carry on :)
What about compilation times and binary size? 
&gt; How hard is for Visual C++ people to add a simple C++ hello world template?! How hard is to replace the name of stdafx.h with precompiled.h? Likely easy to do it, but it probably won't change for retrocompatibility reasons.
Use Spirit X3, it's great and a huge improvement!
Same goes for standalone ASIO.
So it'll download that zip everytime I fire off the build process right? That's a bit of overhead for local development, don't you think? Also here's something relevant to Cmake and Gtest - https://cmake.org/cmake/help/v3.0/module/FindGTest.html. Do you have any experience with it?
I find it easier to create custom streams with boost's framework than with STLs
Yeah but I have a boost dependency already, and it's already going to be replaced by the standard library.
[Meson](http://mesonbuild) has build + unit testing framework + native support for GTest and GMock. [Docs](https://github.com/mesonbuild/meson/wiki) and [GTest sample project](https://github.com/mesonbuild/meson/tree/master/test%20cases/frameworks/2%20gtest). I am the main developer of Meson so feel free to apply as many grains of salt as appropriate.
You can use [Hunter](https://github.com/ruslo/hunter), which uses ExternalProject, but it also makes a cache. You won't have to download everytime the package. Hunter has an entry for [GMock/Gtest](https://github.com/ruslo/hunter/wiki/pkg.gtest).
No, it wouldn't download the zip or Git repository every time. Only when it needs to, i.e. you change the referenced source ZIP or Git branch or whatever. It is strongly discouraged to use a precompiled and installed version of Googletest. The developers of Googletest recommend using it as a static library. Don't worry, it will only get compiled the first time after downloading it.
I don't know how many devs start *new* projects using MFC, and then being confused that `stdafx.h` has been replaced with `precompiled.h`. Kenny Kerr also [promotes the idea](https://twitter.com/kennykerr/status/306932370127323136) of renaming `stdafx.h`.
I tried using meson in my previous project and absolutely loved how less conf was needed to get going. However setting it up with CIs was troublesome - https://github.com/mesonbuild/meson/issues/465
Meson now does its own CI with Github + Travis using Docker. [Here's](https://github.com/mesonbuild/meson/blob/master/.travis.yml) the Travis conf file and [an appveyor one](https://github.com/mesonbuild/meson/blob/master/.appveyor.yml) as well.
* memory-mapped file streams * array-backed streams (C++ has them as [std::strstream](http://en.cppreference.com/w/cpp/io/strstream)) * POSIX file descriptor streams * compressed (gzip/bzip2) streams * tees all that can be done with standard streams, of course, but it requires some work, which boost did for you
Good to know, but I was hoping to do it without docker builds.
So if you really wanted to access a private data member of a class in a precompiled binary it would be something like: ClassType c; MemberType m = *static_cast&lt;MemberType*&gt;(static_cast&lt;void*&gt;(&amp;c) + offset_of_member); right? Figure out the offset of the member in the body of the class, and just memory-access from that point? Obviously this is implementation specific, and `offset_of_member` might have to accommodate a vtable, but if we have a precompiled binary, we're in implementation specific land anyway. EDIT: Actually, (this might be implementation specific) but the compiled binary doesn't know public/private right? So you could just make a new declaration of the class with the variable public instead of private and just reference the existing binary...it's gross but I *think* it should work. EDIT 2: In retrospect, that's very implementation specific, so the approach mentioned in the EDIT above is a solid *probably*. Anything that's declared inline (which is data members, inlined functions, etc) aren't compiled into the binary (it's declaration information, not definition information), so we can technically redeclare them as we please. However, I don't think there's any sort of ruling on the order variables have to be defined in a c++ class, so it's possible that changing something from public to private will change the order of variables and screw up the offsets the compiled binary expects. In practice though, I'm pretty sure all major c++ compilers just stick the vtable first (if necessary), and then the variables in the order they're defined, so just making a new header with the variable public instead of private (in the same order) should still work.
When I write something, you have absolutely no idea of my state of mind when I write it. I'm arrogant if you make me sound arrogant when you read. You have to know that english in not my primary language and I try to use simple, direct sentences because I can't do otherwise. I am a very nice person! And if you say that Ubisoft is arrogant as a company, please explain because I don't see it.
What kind of data do you think a compiler produces that could be viewed graphically?
The text output is a list of warnings, errors and completed tasks. That comes from the compiler's parsing and compilation of source code. Why/how would you like to see that graphically? 
&gt; I'm not sure if I like implementing this via inheritance, but I think that "views" would be great. I thought this originally too when a colleague of mine suggested this (the "this is not how modern C++ is written" argument), but after several days of stewing I couldn't come up with a good reason why not, which is why I created this post. Most of the arguments I can see immediately are completely overshadowed by the advantage that you can transparently bind to a reference (although maybe this is a disadvantage? I know there was some kerfuffle about whether or not `std::string`should be implicitly castable to `std::string_view`).
Compilers don't really produce text output, either. Do you have a specific example in mind?
No, the text output is the console output of the compiled program.
You can use Clang (combined with dot to do the actual graphical part) to produce [call graphs](http://stackoverflow.com/questions/5373714/generate-calling-graph-for-c-code).
I'm actually not a big fan of integrating 3rd party builds into my build system (such as those using ExternalProject)...In my experience, maintaining those sort of trees can become a source of technical debt. I've had much more luck managing dependencies with a provisioner in some sort of virtual environment, either something like vagrant with a VM, or docker, or even just a bash script to download some code. Do what works for you though :-)
To be fair, Herb Sutter was saying that at cppcon 2014...the passing by value style nonsense (well at least we know it to be nonsense now ;-) ) was sort of before the standard was even released.
You don't need inheritance to enable this; you can simply have implicit conversion from a container to its view. Or, really, you don't need to do things implicitly at all. There are advantages, like making it explicit at the call site that a view is being passed. The only real question is if this results in some kind of major performance cost, but it's hard to say. It's not even clear if these views would be passed by value or by reference. A view for a vector is only two pointers, for example, and iterators are passed by value. These are all issues that would need to be rigorously worked out. But that's why I wrote that I'm not sure, it's too hard to say at this point what the correct implementation details are.
IIRC, he said to pass-by-value for just constructors &amp; by reference for the rest. Now I'm confused which is the correct way to pass values.
That's a great point about the technical debt of embedding 3rd party dependencies.
He means text written at runtime to std cout/cerr
What you're asking about is simply an iterator written in C. C lacks member functions and operator overloading, so things like move-next need to be standalone functions. A search for 'c iterators' should yield lots of further reading material.
**Short answer:** Pass by const-reference if you don't need to modify it, pass by reference if you do, pass by value if it's small or you're making a local copy. Same as before c++11. **Long answer:** It depends on a class by class basis obviously, but in general: If you're not making any kind of copies, pass by const-reference if the thing is large, or pass by value if the thing is small. This hasn't changed since the good ol' days. If you're changing the input variable, pass by reference. This also hasn't changed. If you're making a copy inside the body of the function, pass by value. class Cat1 { public: //Bad: Both l- and r- values passed to eat call Food's copy constructor, no //type elision possible. void eat(const Food &amp; f) { Food local_f(f); } }; class Cat2 { public: //Good: l-values call Food's copy constructor, r-values call Food's move //constructor. Copy elision is possible. void eat(Food local_f) { } }; If you're copying the input parameter into a class (or global) variable, then pass by const-reference and copy and then optimize (if desired) by having a r-value operator overload. A single function with pass by value is actually less efficient (see below). class Cat1 { std::string my_name; public: //Bad: L-values call string's copy constructor and then it's move assignment. //R-values call a move constructor and then move assignment. Note that for //string, copy construction is LESS EFFICIENT than copy assignment (as in //copy assignment, the buffer can be reused). (Moves are assumed to be mostly //free) void give_name( std::string name ) { my_name = std::move(name); } }; class Cat2 { std::string my_name; public: //Good: l-values call string's copy assignment. r-values call string's //move assignment. void give_name( const std::string &amp; name ) { my_name = name; } //Note that this overload is optional for performance benefit void give_name( std::string &amp;&amp; name ) { my_name = std::move(name); } }; Now, constructors are a different beast. Notice that above, the problem was that we had to do a copy construction instead of assignment. However, in a constructor we *always* have to do construction. So we don't lose out on the performance benefit we see above: class Cat1 { std::string my_name; public: //Good: No benefit from separate r-value constructor anyway. Cat1( std::string name ) : my_name{std::move(name)} {} }; ***** BONUS PROBLEM: Note that instead of doing the overloads, you can do it in one with perfect forwarders, but you lose a lot of readability in trade off. Probably not worth it for short functions: class Cat3 { std::string my_name; public: template&lt; class StringType, class = std::enable_if_t&lt; std::is_same&lt; StringType, std::string &gt;::value &gt; &gt; void give_name( StringType &amp;&amp; name ) { my_name = std::forward&lt;StringType&gt;(name); } };
&gt; but none of them have "graphical output." This sounded like a challenge, so I [found one](https://archive.org/details/msdos_borland_turbo_c_2.01)! Everything seems to be in order, too: http://imgur.com/a/2uEcb ([source code](https://en.wikipedia.org/wiki/Borland_Graphics_Interface#Example)) And it doesn't even use `rand`^*, so even /u/STL should be happy! ;-) ^* ^(well, not directly anyway, but let's leave that pesky implementation detail aside)
I think I read the table wrong but it says "cheap and impossible to copy" and "In" should be f(X) meaning that it should be passed by value. Passing by value will result in requiring a copy (assuming it won't become a move operation) so how is it possible to pass a type that's "impossible to copy" by copying?
My favorite, but it does not work with all compilers. MSVC balks. GCC accepts it. In those cases a private, hand-edited copy of the header works. However, that can introduce copyright/licensing/redistribution issues in some code.
Uh, unless I misunderstand, you found a *program*, not a compiler, that produces graphical output. Hm. Maybe that's what the OP wanted, though--an online build environment whose runtime component supports graphical output.
Obviously, if you want to pass a unique pointer to a function, you have to relinquish it (read: move). Passing a unique_ptr by const ref (if the function only wants to observe it) makes little sense, as you could have just passed a raw pointer instead.
&gt; assuming it won't become a move operation You kind of answered your question yourself. (Why would you assume that?)
Yea basically. If you're making a copy anyway, pass by value. If you're not, pass by cost-&amp;, implying you also can't change the object.
See also: https://github.com/ome/ome-cmake-superbuild/blob/develop/packages/gtest/superbuild.cmake along with https://github.com/ome/ome-cmake-superbuild/blob/develop/ExternalProjectHelpers.cmake This keeps all that nasty downloading (and local caching of sources) outside the source tree of your individual projects. This keeps your actual code projects free of any knowledge of this nastiness; they will use what's locally installed or build by the super-build. Individual projects use https://github.com/ome/ome-common-cpp/blob/develop/cmake/GTest.cmake GTest is one of the most ugly libraries to deal with due to how they crippled its installation for no really good reason. The above was what I came up with as an alternative to embedding in the source tree of every project, but without needing to download it every time. It's nasty, but portable. I can only hope the developers of gtest realise that it's just a regular C++ library and not a "special snowflake" library like they treat it at the moment. If a new test library came along which was equivalent in features but was header only or saner about installation, I'd definitely consider switching. On the CI side, we drive it all via Jenkins, e.g. https://ci.openmicroscopy.org/view/Files/job/OME-FILES-CPP-DEV-merge-superbuild/
Cool!
agreed with the header-only mantra view as trade-off.
Do you want a copy and don't want to modify the original? Value. Do you want to just view the original and not change it? Const ref. Do you want to modify the original? Ref. If you want to keep a copy and change the original, pass by ref and make a copy anyway.
One of the reasons I see there is performance - are there really so many systems for which the compiler doesn't yet support zero-cost exceptions?
Hi, spdlog author here. It doesnt use std::string so much. Actually internally there is a lot of use of something similar to string_view (fmt::StringRef). std::string mostly used in the intialization API. Anyway, since when std::string is a bad thing? Regarding exceptions, agreed, and this is a popular request - to remove them (at least when actual logging takes place, as opposed to the initialization phase, where exceptions do make sense). There is a work in progress about this and hopefully will be released soon.
&gt; I came across conversion of 64 bit integers to a double part which I couldn't seem to wrap my head around. Maybe you could link to that, to help clarify your question, or so that people could explain it. &gt; How could different implementations of conversion exist in different engines? There are an infinite number of ways to do any computation, especially when there's not a exact mapping of inputs to outputs. If all you specify is that 64 bit input values are mapped to `double`s in the range [0, 1) then there are a lot of ways to do that.
&gt; Avoiding 15 minutes of setup to get a library building/precompiled in exchange for months of lost productivity waiting for slow builds Honestly, I lost months of productivity trying to handle the compilation of twenty libraries on X different platforms with Y different link flags, with X and Y both &gt; 10
That doesn't do it to a double "between 0 and 1" For that, you'd basically have to divide an unsigned value by the maximum value that type can hold. For a signed value, if you want to represent the whole range, you need to shift and scale the value. That general sort of operation is pretty common in graphics when moving from, for example, an 8 bit value read from a graphics file to a 16 bit float used on a GPU where the 8 bit int represents something from 0.0 to 1.0 in float. Dunno why it's an important task in JS. That's not really my domain.
"Zero-cost" exceptions are a misnomer. There's no such thing. Just enabling exceptions penalizes the optimizer and requires larger binaries. Both SG14 and the previous embedded groups put out some papers on the topic. Don't have links or paper numbers offhand, but they should be easy to find. There were also some good CppCon talks on the topic iirc.
You could use [conan.io](https://conan.io) package manager. It integrates well with CMake and CI like travis and appveyor. You could check for example the [imageflow project](https://github.com/imazen/imageflow), which is using conan to depend on several existing packages, and building/testing on CI (travis, appveyor) with coverage (lcov, coveralls). Be aware that the CMake version of travis is quite old (2.8) compared with the latest 3.6, so you might need to update the CMake version in your .travis.yml script. I recommend the lines from [Boost.Hana travis script](https://github.com/boostorg/hana/blob/master/.travis.yml#L234). Conan.io has 134 different precompiled binaries for Gtest for different platforms: https://www.conan.io/source/gtest/1.7.0/lasote/stable but it can also build from sources for other platforms or just if desired. It also caches things locally, so it is good for development too. 
 &gt;Hi, spdlog author here. It doesnt use std::string so much. Actually internally there is a lot of use of something similar to string_view (fmt::StringRef). std::string mostly used in the intialization API. Anyway, since when std::string is a bad thing? Yeah but isn't that a dependency? &gt;Regarding exceptions, agreed, and this is a popular request - to remove them (at least when actual logging takes place, as opposed to the initialization phase, where exceptions do make sense). There is a work in progress about this and hopefully will be released soon. I've never like the C++ exceptions solution so I'm too biased to say much. In any event getting rid of them would be a good thing. 
&gt; "Header only" is an anti-feature. Fast compiles are important. PCHes only fix a fraction of the problems of header bloat. Avoiding 15 minutes of setup to get a library building/precompiled in exchange for months of lost productivity waiting for slow builds is a pretty bad trade off. Respectfully, I disagree. Header-only libraries save a lot of setup stage time and they were a real breeze to work with when it comes down to cross-platform development. Some may argue that CMake solves that problem, but I would argue that CMake is a problem itself. As for slow builds - I think it really depends on an amount of C++ features selected library uses. I saw the numerous header-only libraries that were quite fast to compile and not so fast libraries with proper cpp\hpp separation (boost thread comes in mind, also POCO). Most of the HEAVY header-only libraries that use a big amount of compile time contains numerous amounts of "meta-programming magic" which IS slow. spdlog doesn't seem to be in this league. I agree with PCH argument tho. But I'm willing to make this tradeoff - others may not. Currently, there is no proper answer to this question. I hope that modules TS when they get significant adoption - will allow us to solve this problem. One way or another. 
Why is your example surrounded entirely by a try-catch? Now that you can have custom error handlers (which makes this actually usable for me) you should provide an example, since any code surrounded by a big try-catch will turn people off.
I'm not sure why exceptions aren't handled using something like a gadt in ocaml or a varient in Qt. That's probably not the right terminology, but should be able to be reduced to a struct with an index and a union with the various types reduced to their pointer types. Of course, this should be elided during a call outside a try-catch block. Of course, according to this [stackoverflow](http://stackoverflow.com/a/4986415) answer, most compilers will not produce exception handling code that adds a cost at runtime. It does seem likely to produce larger binaries, but I'm not sure that's a real factor. The reason that I've read against using them comes from the Google c++ style manual, in which it is discouraged due to old compilers not supporting exceptions very well and therefore not using them at all throughout their code base. That's not really a fault of the exceptions, it's a pragmatic decision that is used to try and maintain the sanity of their code. 
[MCF](https://github.com/lhmouse/MCF).
&gt; You could use conan.io package manager. Not meaning to be rude to the conan.io folks, but what reason do we have to think Conan will succeed where BiiCode failed? It's my understanding that it's the same people behind it. If anything, they've already proved that there isn't a viable market for a commercial C++ package manager. 
&gt; Respectfully, I disagree. Header-only libraries save a lot of setup stage time and they were a real breeze to work with when it comes down to cross-platform development. Even without CMake, and I've just never found it to be all that complex to add a library dependency to a project. Very big and complex libraries with an intricate build system, perhaps, but they (a) typically have their own build system that handles this and (b) there's no reason to recompile the whole library all the time so just check-in the binaries to source control and stop worrying about it. e.g. we have just shy of 30 GB of libraries and symbols for both MSVC and GCC/Clang and both 32- and 64-bit x86 checked in for the middleware we depend on (both proprietary and FOSS). Which seems ludicrous, until you realize that building all those libraries adds up to around 20 hours, and we all but never change them (and when we do, it's mostly version upgrades to newer vendor-supplied binaries). :) On the FOSS stuff I tinker with, it's a similar story. I'm not going to build SDL or Qt every tiem I want to do a clean build. I just check-in the binaries and matching headers. Full rebuilds of the largest game I have is maybe 12 seconds. Even when I'm deep in C++ code, I can iterate on changes fast enough that I don't get distracted and starting posting on Reddit like I do when working on software with less care put into its build time (... like now). &gt; Some may argue that CMake solves that problem, but I would argue that CMake is a problem itself. Then we definitely agree here. :) CMake is this generation's autotools.
Nice. Perhaps we should add "copy &amp; move are both impossible" to the right-hand column?
When passing by reference to const, there is no copy made. The value of the parameter is just the value that was passed as an argument (assuming no implicit type conversion is required). So get rid of "copy in callee". That's the main issue. But also, passing by value does not do a copy followed by a move. It does a move if it can; otherwise it does a copy.
import import import pls
In the table, that means that the value the caller passes as an argument, is not modified by the call. In such a case, you would never want to do a move, as that leaves the caller's version of the argument unusable. So the cost of a move becomes irrelevant. And in any case, it remains true that passing by reference to const will not copy. I take it you're thinking of a situation where we always want the callee to work with a copy of the argument? (EDIT. Switched incorrect use of caller/ee.)
&gt; I take it you're thinking of a situation where we always want the callee to work with a copy of the argument? Yes, I've been emphasizing this exact point all the time. Simple example: Setter method.
Just double checking that the Windows folks don't have a separate concept or pattern? The Windows programmers I work with consistently call it an enumerator, and the Win API documentation uses the word "enumerates" and even has "enum" right in the function name.
I've used spdlog for over a year before moving on to a home-made solution. spdlog is very convenient and nice to use so I would recommend it 99% of time. :) However, if like us you have low latency requirements, be aware that the formatting of log messages is done at call site (even in asynchronous mode). If this is not acceptable, you may want to check Mattias Flodin's [reckless](https://github.com/mattiasflodin/reckless), which is similar to spdlog but performs formatting in the background thread. This is also the strategy that we use and it works well.
Links: V8 double conversion : https://github.com/v8/v8/blob/master/src/base/utils/random-number-generator.h#L93
 &gt; If all you specify is that 64 bit input values are mapped to doubles in the range [0, 1) then there are a lot of ways to do that. I'd like to know how there could be a lot of ways to do this. Can you expand on that? Even it's a reference to a book or a topic, that would be great. Links: V8 double conversion : https://github.com/v8/v8/blob/master/src/base/utils/random-number-generator.h#L93
Latest version in C++ Core Guideline contain updated version of that image. Check [rule F.15](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#a-namess-callafcall-parameter-passing)
So that sounds really logical... even like you would do it pre-C++11. Does that mean nothing changed with C++11/14?
Hunter is good, also you can use [conan.io](https://www.conan.io/)
&gt; Very fast - performance is the primary goal (see benchmarks below) Those numbers are based on completely unrealistic workloads ([related article explaining some pitfalls](https://shipilev.net/blog/2014/nanotrusting-nanotime/)) &gt; Extremely fast asynchronous mode (optional) - using lockfree queues and other tricks to reach millions of calls/sec. [`mpmc_bounded_queue`](https://github.com/gabime/spdlog/blob/master/include/spdlog/details/mpmc_bounded_q.h#L57) isn't lock-free: 1. Assume: \- there are two threads, A &amp; B \- queue = {empty} 2. Thread A calls `enqueue(TA)` ‚Üí gets suspended in [L.105 or L.106] (https://github.com/gabime/spdlog/blob/master/include/spdlog/details/mpmc_bounded_q.h#L105-L106) ‚Üí queue = {empty} or {TA} 3. Thread B calls `enqueue(TB)` ‚Üí queue = {TB} or {TA, TB} 4. Thread B calls `dequeue()` ‚Üí returns {empty} ...*wtf?!* 
I feel like certain applications forbid use of eh because they don't require it rather than that they can't have it.
From what I've seen of the proposals, it doesn't look like modules will solve these issues. 
Ha, I didn't get that at all! Yeah that's a big ask! Maybe you could include the gl headers, compile it with emcripten and put it out in webgl.
 #include &lt;fstream&gt; int read_value() { int result = 0; std::ifstream f("my_file.txt"); if (!(f &gt;&gt; result)) { // Couldn't open file or value is not in the file. You should handle // the error here. } return result; } int x = read_value(); 
&gt; full coverage of the guidelines. the guidelines aren't even complete
This reference has a good overview of iterators in C (as mentioned by u/dodheim), [C Iterators](http://www.cs.yale.edu/homes/aspnes/pinewiki/C\(2f\)Iterators.html). The Windows Enum* functions are examples of Option 3 in that link.
Done, i hope it helps you to improve
&gt; pass by const-reference if the thing is large, or pass by value if the thing is small. and cry if you want to have generic code that works in both large and small types. (Boost.CallTraits is not really helpful in that case either... it adds a lot of boilerplate code)
Well to be fair they are never meant to be declared complete and finished for all time. They're meant to evolve. But that doesn't mean having a linter that catches all of current rules is undesirable. ;-)
The downside of that is that you have to null-check the pointer, but you wouldn't have to null-check a (non-const) ref. While I personally like the distinction, it becomes a bit unwieldy when you work somewhere where null-check of pointers are always required. 
Use ifstream, this isn't C.
The reality is that exceptions don't solve all problems. But some error handling conditions are quite elegantly solved with exceptions. I was not a believer in this until I was forced to use an exception enabled system API and I am now converted. The major benefits I found, over passing error codes around, was that it was a lot harder to silently swallow an error and my code was much simpler without having the error handling interleaved with the actual code that was doing the actual work. It was great. Now, I wouldn't use them everywhere. In many cases, assert is still the right choice, and rule of thumb I've come to use is: if the user can check ahead of time, it should be an assert, otherwise consider an exception.
Should probably say "no *external* dependencies".
While g++ does not have the support checker built in, the guild support library from Microsoft does support g++ 5.1. It might support as low g++ 4.7 if it only need c++ 11 support. Also, the GSL is also a header only library so you do not need to build the runtime. To get the library go to https://github.com/Microsoft/GSL
What do you think of the stb library approach?
Yes, but you can often avoid extra allocation and copy directly into the output buffer while in the other case you copy twice. In addition to that there is a copy and allocation of the argument array itself.
There are trade-offs. The implementation you linked discards a whole pile of precision. The problem is that the double representation has: - 2^52 numbers in [0.5,1) - 2^52 numbers in [0.25,0.5) - 2^52 numbers in [0.125,0.25) - etc. To do the conversion for maximum distribution, you need to have a bunch of special cases: Case int &gt;= 0x8000000000000000: Use bits 1 to 52 Else int &gt;= 0x4000000000000000: Use bits 2 to 53 Else... Else int &gt;= 0x0020000000000000: Use bits 11 to 62 Else Use bits 12 to 63 This uses 12x2^52 bits of the 64-bit integer, or 1.5x2^55 bits, which means roughly 55.5 bits worth of randomness survive into the double. But this is slow. The implementation you linked uses a shortcut that makes it fast, but means that only 52 bits worth of randomness from the integer survive in the double. Now, if you want to have not only a linear distribution of numbers, but also a linear distribution of numbers of numbers, then the fast version you linked is actually better. So it depends a bit on the final application. 
If you copy the string directly into the queue there is a single copy and no extra allocations.
You'll need to grow the queue which in general allocates and I'm not sure how this generalizes to arguments of different types if you plan to store strings directly in the queue. The main point, however, is that if you are copying arguments anyway there is little or no advantage to not doing formatting at the call site unless you do very sophisticated formatting.
You need to grow the queue in either case. My point is that there is no reason for any *extra* allocations as you claimed, or more than a single copy of strings. I also strongly disagree that there is little advantage in formatting off the call site. This is a very common and beneficial optimisation done in HFT.
I find [catch](https://github.com/philsquared/Catch) to be much more hassle-free than GTest
There is no queue if you format at the call site. The queue is needed if you want to pass arguments to a separate thread that does formatting and this adds overhead. And yes, there are plenty of extra allocations if you want to capture arguments. Have a look at Boost Format implementation.
I'm no expert here, but he's a few things to consider. Know that if you ever _stop_ asking how to improve your code (or any skill, really), something has gone wrong (and everyone feel free to help _me_ improve here)! Good luck! - I don't see a reason to prefix method names inside the geckoStep class with a 'g'; e.g., geckoStep::enable() instead of geckoStep::genable(). - I much prefer stdint types with known sizes instead of the platform-varying types like 'long' (e.g., int64_t, uint32_t, etc.). - Typically I'd keep filename/classnames consistent. For instance, you declare the geckoStep class inside geckodrive.h. - Documentation is extremely important not only for others, but for yourself in the future when you look back at the code and trying to figure out... what values does geckoStep::pos take on? What _is_ that variable doing, how to interpret it, what's the range of validity, what are the units, etc.? Consider checking out Doxygen even to get into a coding/documentation style even if you aren't going to build the Doxygen for a small project. - You can use static initialization in your constructor implementation if you desire: geckoStep::geckoStep(int a, int b, int c) : disablePin(a), dirPin(b), stepPin(c), pos(0), (then your other members) { ... - Be consistent in terms of tabs/spaces; you mix+match those throughout. Just choose one format, tell the internet your choice, and wait for the flamewars to start. - You could use an enumeration for your "direction". It makes the code much easier to follow. class geckoStep { enum Direction { FORWARD, BACKWARD // Or whatever makes sense to name these states. } m_direction; } void geckoStep::gdir(const Direction new_direction) { if (m_direction != new_direction) { if (new_direction == FORWARD) digitalWrite(dirPin, HIGH); else digitalWrite(dirPin, LOW); m_direction = new_direction; } } of if the write is cheap and it doesn't hurt to write again: void geckoStep::gdir(const Direction new_direction) { digitalWrite(dirPin, new_direction == FORWARD ? HIGH : LOW); m_direction = new_direction; }
Boost format isn't relevant, I'm not sure if you understand what the original commenter was talking about. And a queue is needed in either case because you can't do I/O at the call site if you have LL requirements.
My argument is no *extra* allocations. Zero allocation is possible with a fixed size queue though. I can't give any examples, sorry.
I'd love to use catch as well, but the integration with GMock isn't that nice and I haven't found any other similar powerful mocking frameworks. Would love to learn better!
This is definitely the wrong sub to ask this of. Try /r/spotify ?
I've also seen ```.imp``` for implementations of templates. I generally use ```.h``` for C code, ```.hpp``` for C++ code, and ```.tpp``` for template functions.
&gt; However, the sum of two evenly-distributed random bit-sources isn't evenly distributed so I'm not sure what's going on there. Can you elaborate or provide some reading material on this?
Note that there are strategies to avoid allocation (as long as you are ready to truncate large strings). The allocation-less asynchronous strategy I would go for is: 1. Based on a ring-buffer of messages to be logged 2. Have each message to be logged containing a fixed-size array of arguments (thus limiting the maximum number of arguments) 3. Have each argument be either a `variant` or a *scratch-pad* I'll leave the ring-buffer as an exercise to the reader (many different implementations, a non-blocking one for producers would be preferable for logging). The rest can be done as described below... and the trick to avoiding allocations is going to be to create a child class of `Writer` and a special `make_writer(std::string const&amp;)` (and other allocating ones). If you are careful so that `WriterT` only compiles for "simple" types, you get a compile-time error if you have not provided a suitable `make_writer` for your type. I've used `std::is_trivially_destructible` here to enable it for all types with no held resource. class Writer { public: virtual ~Writer() {} virtual void write(char* buffer, size_t size) = 0; }; template &lt;typename T&gt; class WriterT: public Writer { public: static_assert(std::is_trivially_destructible&lt;T&gt;::value, "Reserved to trivially destructible types"); explicit WriterT(T item): mItem(item) {} virtual void write(char* buffer, size_t size) { ... } private: T mItem; }; template &lt;typename T&gt; WriterT&lt;T&gt; make_writer(T item) { return WriterT&lt;T&gt;{std::move(item)}; } template &lt;std::size_t Size, std::size_t Align&gt; class Argument: private NoMove, private NoCopy { static std::size_t const PtrSize = sizeof(void*); static_assert(Size &gt;= PtrSize, "Cannot store less than a pointer's worth of data"); static_assert(Align&gt;= alignof(void*), "Cannot store aligned less than a pointer"); public: Argument() { // Hackish ABI-dependent trick, the setup memset(&amp;mScratchPad, 0, PtrSize); } template &lt;typename T&gt; explicit Argument(T item) noexpect(true) { using WriterType = std::remove_reference&lt;decltype(make_writer(std::move(item)))&gt;::type; static_assert(std::is_nothrow_move_constructible&lt;T&gt;::value, "T not nothrow move constructible"); static_assert(std::is_nothrow_move_constructible&lt;WriterType &gt;::value, "Writer type not nothrow move constructible"); static_assert(sizeof(WriterType) &lt;= Size, "Size of item too high"); static_assert(alignof(WriterType) &lt;= Align, "Alignment of item too high"); new (this-&gt;access_writer()) WriterType(make_writer(std::move(item))); } ~Argument() { // Hackish ABI-dependent trick, the usage // (where we rely on the fact that the first pointer-size word is the virtual pointer of the Writer struct, // and thus null if no Writer was stored and non-null if one is stored) static char const Zero[PtrSize] = { 0 }; if (memcmp(&amp;mStorage, Zero, PtrSize) != 0) { this-&gt;access_writer()-&gt;~Writer(); } } void write(char* buffer, size_t size) { this-&gt;access_writer().write(buffer, size); } private: using ScratchPad = std::aligned_storage&lt;Size, Alignment&gt;::type; Writer* access_writer() { return reinterpret_cast&lt;Writer*&gt;(&amp;mScratchPad); } ScratchPad mScratchPad; }; template &lt;std::size_t Nb, std::size_t Size, std::size_t Align&gt; class Message { public: template &lt;typename... Args&gt; Message(char const* f, std::chrono::nanoseconds t, Args&amp;&amp;... args): mFormat(f), mTimestamp(t), mArguments() { static_assert(sizeof...(args) &lt;= Nb, "Too many arguments"); this-&gt;write_at(0, std::forward(args)...); } private: using Arg = Argument&lt;Size, Align&gt;; // the clever ones have multiple sizes, because logs often have numbers... template &lt;typename A, typename... Args&gt; void write_at(size_t index, A&amp;&amp; arg, Args&amp;&amp;... args) { Arg* arg = &amp;mArguments[index]; arg-&gt;~Arg(); // it's UB to write on top of a living argument; fortunately, this destructor is a no-op here new (arg) Arg(std::forward(arg)); this-&gt;write_at(index + 1, std::forward(args)...); } void write_at(size_t) {} char const* mFormat; std::chrono::nanoseconds mTimestamp; std::array&lt;Arg, Nb&gt; mArguments; }; 
Sometimes I wonder how games (or these engines) do even successfully run, with this many bugs.
Interestingly, the formatting part doesn't require C++11 but I'm not sure how much work it is to make the rest compatible with older compilers.
The sum of independent uniform random variables follows an [Irwin-Hall distribution](https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution) An easy way to illustrate this for two variables is to take two dice and write down all possible sums and their probabilities.
High-school math text-book? It's really the same issue as when throwing two dice - for each individual dice, all 6 outcomes are equally likely, yet for the total of the two dice, the outcome 7 is most likely because there's more ways to form 7 (1+6, 2+5, 3+4...) than e.g. 2 (only way is 1+1) or 12 (only way is 6+6). Maybe there's a specific named discrete probability distribution that this is a special case of, but I can't name one to look up. With two variables to add the distribution is a stepped triangle with it's high point in the middle. IIRC with increasing numbers of variables being summed, the distribution approximates a Gaussian distribution. In that sense, I guess the binomial distribution is a special case of this - one where the evenly-distributed random values to add are only two-valued. That particular random remembering comes from a time I was playing with simple digital audio algorithms. I'd assume something about the state means this doesn't apply - those two states aren't independent evenly-distributed random numbers - rather than assuming the code is wrong. Either that or the triangular distribution is actually what's wanted. 
Oh, I see. By "retain copy" they mean that the caller retains the object for use after the function call?
Yes, I"ve been using the GSL from Microsoft. But what I am after is a checker, not the library itself. Microsoft has made the option available for Visual Studio, but apparently there is nothing as comprehensive running under Linux yet, which I find a bit odd considering the age of this initiative. 
Examples?
... that joke went right over someone's head. :p Also, while coroutines (P0053) are not going into C++17, they're on track for C++2x (with a pitstop in a TS, most likely) with strong committee interest (likely incorporating P0073 after the review in Oulu), so I'll just "await" on the TS landing. ;)
A core guildlines checker is really a static analysis tool that check if you are following the C++ core guildlines principle. The GSL an implementation that you can use to put some suggestion of the core guildline in your code. gcc and g++ are lacking in static analysis tools as gcc and g++ were design to give you highly optimized code, but LLVM and Clang have plenty checker, therefore clang-tidy is you best tool for Linux. I not sure if gcc would put any static analysis soon. http://clang.llvm.org/comparison.html to prove might my point
Yeah, I have no problem using clang-tidy, but i just don't get the feeling that they've got full coverage of the core guidelines yet. For instance they don't seem to do any of the required lifetime safety checks which are available with Visual Studio[1]. I just really thought by this point there would be a fleshed out tool. I'm sure it'll happen eventually. [1] https://blogs.msdn.microsoft.com/vcblog/2016/06/03/c-core-guidelines-checkers-are-now-in-a-single-nuget-package/
&gt; The strength is that each error can be a different type so you can carry error specific diagnostic information with watch type. Certainly, which some of the other techniques also handle. :) &gt; Corrupting user data is. Whole-heartedly agreed. &gt; In development, I would argue crashing should be avoided as much as possible. "Crash" in this context is perhaps not quite precise enough; a good approach is actually to pop up a "crash" dialog with diagnostic information about the failure with options to ignore, ignore always, ignore all, report bug, break in debugger, etc. The important part here re: exceptions is that you want to trigger as much diagnostic, tracking, reporting, etc. as possible at the point the error is detected rather than at the point that the error is handled. C++ exceptions (out of the box, anyway) don't allow this; at best some debuggers can break on any `throw` statement, but only if the debugger is already attached, and then it's still the user's job to dig in the callstack and extract diagnostic information.
Mostly reasonable advice, but this part doesn't seem to come with a good justification; or any justification at all. It's just a "shall not": &gt; Using exceptions for normal code-flow There are two main justifications for this: * If you wrap up execution of a task using an exception as the normal order of business, you have no way of handling errors that may occur between the normal-wrap-up exception being thrown and caught. Maybe you don't care about such errors... but maybe your requirements will change, and then you're married to an architecture that will prevent you from handling them. * Performance. Not really an issue unless you're throwing exceptions in an inner loop (which you of course really should not do).
Again read what they have posted in the read me, the contradictions are stark. I'm not trying to be a pain here just that your comment highlights the fact that it in fact does depend upon other libraries or code if you will.
Neat, but a maybe minor, maybe critical nitpick: Using a union like that is undefined behavior. Proper code can only read from the union field that was last assigned to. (cf http://blog.regehr.org/archives/959)
I thought it was undefined behaviour to put a value into one part of a union and read it from another?
Is there a language where exceptions are an acceptable means for anything other than error handling? 
+1, except with an enum for the "k" values and dense switch statements. enum k_code{ OP_CODE, X, Y }; ... auto parsed_input = ParseInput(data); switch(k){ case(OP_CODE) : op_code = parsed_input; break; case(X) : x = parsed_input; break; case(Y) : y = parsed_input; break; default : std::cerr&lt;&lt; "Invalid k_code"; } All around, the variable names were the most immediately (and easily) improvable aspect of the program. Only a tiny, tiny fraction of writing code is spent doing the literal typing. Informative names take a slightly longer time to type, but they are immensely easier to understand later.
As I recall, in Java, InterruptedExceptions are used to kill threads that are blocked. https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#interrupt()
[class.union] 1. In a union, at most one of the non-static data members can be active at any time, that is, the value of at most one of the non-static data members can be stored in union at any time. 
The `async`/`await` coroutines will not be going into C++ ever. They're terribly designed and are merely an attempt by Microsoft to 'make the syntax work'. It's been explained time and time again why they would be a massive step in the wrong direction for so, so many different reasons. 
I had one co-worker that loved to use exceptions for normal code-flow, like you ask for something in one database, and if the number of elements is 0, throw an exception, instead of returning an empty vector/set/list or whatever you want to use, because you know, looks like in his mind was cheaper to throw an exception instead of let the input container(empty btw) passed by ref like it was, and handle outside the method the result with something like: if (!container.empty()) {} else {} I just had to fix yesterday one bug related to this, feels bad man.
Something like that. I'm not sure exactly what it means; I imagine there is some talk somewhere that would give this phrase the proper context.
Nitpicks: 1. It is possible to turn on alignment checking on x86 too (the AC flag in EFLAGS register; accessible in user-mode and checked in user-mode (ring 3) only). 2. It is possible to load/store AVX/.. types from unaligned addresses, but with explicit "unaligned" instructions. 3. It is completely pointless to use a union in the implementation because, if `uintptr_t` exists on the given implementation, it's possible to cast between it and pointers w/o loss of information. 
While I wasn't at the Oulu meeting, the meeting notes tell quite a different story. :) The syntax is not under debate. It's very useful and handy for some domains and use cases. The underlying mechanism for how it works and whether it's layered over this library abstraction or that library abstraction is up for debate. If nothing else, `await` just becomes a library function. `await` is a feature that any language with any complete form of coroutines (or even just generators) can trivially supply.
Maybe try boost::multi_array?
Lisp's [condition/restart system](http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html) may be used for other things, but it works slightly differently from exceptions: it does not immediately unwind the stack and it makes a distinction between handling and recovery, which provides a bit more flexibility that affords other uses. It also allows manual interactive condition handling when in a REPL, as opposed to an error message and a failure, so I'm not sure whether it's immediately comparable.
 spd::set_level(spd::level::info); console-&gt;debug("This message shold not be displayed!"); it should not be displayed but the arguments still get evaluated and if I'm compiling a release version, I don't even want these strings in my executable. If your log line would have been a macro, both of these problems could have been avoided.
I haven't really kept up on the perf investigations, honestly. Last hard data I recall saying was late last year and from a micro-benchmarks; the results were essentially that "exceptions in this case have no overhead if you leave them on but don't ever use them, but have a large perf hit if you ever throw one." Those numbers were being contrasted with C-style return code error handling only and not any other error-handling strategies. We all agreed that we need hard numbers in non-micro-benchmark circumstances (e.g., a real game) but that this is hard because just turning them on doesn't tell you an accurate story if the game already has some other pervasive error-handling mechanism in place and isn't actually using exceptions. A lot of the SG's discussion on the topic since then has focused less on performance and more on the other problems with exceptions re: reliability, "determinism" (ugh that term is so misused), nested exception problems, explicitness, etc. Performance is everyone's favorite part to pick on with exceptions, but it's so far from being the only or even worst problem with them. :)
I'm sorry for any confusion, but you really should know that "I'm not sure, this is stuff I'm remembering from a long time ago, here are the bits I can tell you, maybe you can fill in the gaps I didn't" doesn't mean "you're an idiot you should magically know this". For me, "high school" was 30 years ago and I don't really remember in all that much detail. I guess maybe the bit with the dice sounds patronizing, but the point really just is that this is the same thing, just with much bigger "dice". As for an internet reference - I have no more responsibility to know where to find one than you do. I did try Google, and that's how I know that the binomial distribution also approximates the Gaussian but is not the correct distribution in this case. 
http://stackoverflow.com/questions/675817/how-do-i-create-an-array-in-c-which-is-on-the-heap-instead-of-the-stack
I think they sum the two random sources because it's an upgrade over the basic xorshift generator. And the actual implementation in V8 takes things up a notch by using a 64-bit generator instead of a 32-bit generator which makes the generators more random. You can read up on it here: http://xoroshiro.di.unimi.it 
&gt;Mistake # 12: Throwing exception in an exception class constructor Citation needed.
mingw-w64 gcc 5.3 and whatever version of libstdc++ it ships with.
There is an SPDLOG_DEBUG macro IIRC.
If it makes you feel better all the constructors of `std::bad_alloc` are mandated to be marked `noexcept` by the standard (¬ß18.6.2.1 [bad.alloc]).
Awesome. Thanks for the informative replies.
Except that everybody just drops it on the floor and blocks on the next wait, or the same wait in a loop.
This is from last year in June, so this paper is really out dated...
Your post is in violation for the subreddit rule that is on the side bar to your right. The rule says: &gt; Discussions, articles, and news about the C++ programming language or programming in C++. &gt;&gt;For C++ questions, answers, help, and advice see r/cpp_questions or StackOverflow.
Wow, clickbait posts in /r/cpp... This is new.
No. [It is undefined behavior in C++](http://stackoverflow.com/questions/11373203/accessing-inactive-union-member-undefined-behavior). The key wording is `active member`. An union can only have one active member at a given point in time, non-active members are "uninitialized" in C++, and reading from "uninitialized memory" is undefined behavior. That is, one **cannot** use an union for type punning in C++ without invoking undefined behavior. To do it correctly, one would need to use `memcpy` for type punning, but [that does not require an union in the first place](http://stackoverflow.com/q/17789928/1422197). &gt; If this changed it would break nearly every piece of low level code ever written. Type punning using an union is valid C, but undefined behavior in C++. C is not C++. C++ is not C. As long as you just use it in C code, it is perfectly fine. One might think, "who cares", most C++ compilers are C compilers, undefined behavior allows the compiler to do "the C thing here", and most compilers actually do exactly this. However, keep in mind that there is at least one major platform whose C++ compiler is not a C99 compiler... If you want to write portable and/or optimization stable code, "this is true until it isn't" is not very reassuring.
Well TIL, 30 years of embedded C/C++. Believe me it would be easier to change compiler than change all the code that uses this artefact of the 10+ compilers I've used over the years.
&gt; does stacks actually refer to stacks or is it being used to indicate a calling convention? If the committee feels the urge to ask this question, I would have to agree more work is needed.
Indeed, the article has not really addressed this very well. &gt; However, it is critical to understand that the compiler does not check the noexcept specification at compile time. What is critical to understand is that `noexcept` is the *programmer's guarantee to the compiler* that the function will not try to throw an exception. As you say, the compiler can if it wishes try to do some optimization based on that. At one point the draft standard for `noexcept` simply left the behaviour of an attempt to throw an exception as undefined.
Still outdated. Coroutines are being put in a TS, and the "kinks" discussed in the paper are mostly solved right now. Kind of makes me wish that coroutines would have made it into C++17, but at the same time without this paper the kinks wouldn't have been resolved. 
So you prefer nothing ? until now I've used m_Value in base classes and mValue in derived to differentiate between the two when there was the possibility of doubt. I'm using SFML(a C++11 lib) and I've just checked, all the private member variable have the notation m_value, so I feel like I'm at least in sync with the lib's I use. But like you said each his own. 
The logic handled 0 length container, but his logic didn't handle an exception based on a result with no valid entries within the database but valid SQL syntax. Srly, no excuse on this, I have seen this previously and he had the same mistake multiple times(even I advised him not use that approach because he had had mistakes in the past), it is a pain in the neck to debug or trace the problems when the flow is completely messed up with exceptions. Really, been doing this a lot of years(+16) and for me, this is a mark that the code will fail...eventually, it is a sign of someone that is learning a new feature of the language and uses it everywhere, like if you learn lambda expressions and start using them for everything making the code absurdly hard to read and understand.
Well, one can argue about that, reading Herb Sutters Tripreport from Oulu (last committee meeting): https://herbsutter.com/2016/06/30/trip-report-summer-iso-c-standards-meeting-oulu/ Herb writes that Coroutines is heading into a TS of its own or into concurrency 2 TS: &gt; Coroutines: These are being targeted for a new TS (possibly Concurrency 2 or their own TS) so that we have additional time to finish investigating an alternative proposal. I expect this to settle out within another couple of years and then make progress in some form (either the current proposal, or the alternative one if it pans out equally well, or possibly both) into the following C++ standard. So the paper you link to, has already happened.
Something in between I feel. We'll never see a standard like C++11 again though I think, as its more or less the work of a full decade which was released with C++11...
... Yeah. That's just "expectable behaviour is never exceptional".
That is shitty.
While a neat little trick, I'm trying to find an actual use for a tagged pointer. Except for saving a couple bytes of memory - anything obvious that I'm missing? 
s/probably/specified to be /u/HowardHinnant had a nice post about it here: http://stackoverflow.com/a/28013886
I'm not doubting, but the proof is in the pudding as they say. Have you any examples where the noexcept is better optimised? Blog posts/GCC godbolt examples would be fantastic
One "common" case is to represent types on dynamic programming languages. It can also be used on atomic lock free data structures or to store a few bits of metadata on a garbage collector examples: * [javascript](https://nikic.github.io/2012/02/02/Pointer-magic-for-efficient-dynamic-value-representations.html) * [java](https://blogs.oracle.com/jrose/entry/fixnums_in_the_vm) * [emacs](http://stackoverflow.com/questions/106597/why-are-fixnums-in-emacs-only-29-bits) * [lock free data structure](http://kukuruku.co/hub/cpp/lock-free-data-structures-the-inside-memory-management-schemes)
Thanks for your response. The input works don't get me wrong, just the mouse doesn't know that it worked and keep trying to correct it (due to it seeing that it's still same place it was before) 
You have to check the return value of fork() to know whether you are in the child or in the parent process.
fork() is the way new processes are created in Unix. execve() is the way a program is run in a process. When you run `ls` in your shell (assuming your shell doesn't have some sort of builtin functionality for ls), your shell calls fork(). In the parent, fork() returns the PID of the child, in the child, it returns 0. The parent's codepath then waits for the child to complete (or for various control signals) and the child calls execve() with the path of the executable to run and the arguments and environment. execve() doesn't return.
Unfortunately parts of PHP (functions, methods, keywords) are case-insensitive.
Thank you for this. I thought it would be impossible to use sharedptr and the like. I'll check out the spawn family of functions.
Don't forget to cuddle after you fork(). Your computer will appreciate you more for it and will feel more respected.
In OCaml exceptions are used for normal control flow. In fact, there is even a predefined *Exit* exception which is used to break out of loops (there is no *break* keyword) and recursive calls.
Boost is a collection of very high quality, peer-reviewed libraries which act as a sort of second standard library. See: http://www.boost.org/ One of those libraries is the Boost Multidimensional Array Library which does exactly what you need: http://www.boost.org/doc/libs/1_61_0/libs/multi_array/doc/user.html
Why? Meaning of "exception" is simply different in Python.
Just an object that does nothing even if you do stuff with it 
&gt; Let's say I need to move to Coord 100:100, and my mouse is locked at 1117:655, it would keep trying to move to the top left corner and basically spin my character around because it see that my mouse isn't at 100:100 yet, until it never see the color it is looking for of course. Just move to 100:100 once then?
Yeah I don't see how the code in question could ever have a problem - even theoretically [ducks]. The standard says this: [ Note: A union object and its non-static data members are pointer-interconvertible ([basic.compound], [expr.static.cast]). As a consequence, all non-static data members of a union object have the same address. ‚Äî end note ] The two elements in this union have the same address and are the same size. How could it not return the same data from the same address?
Found out the problem. So I'm doing 4 threads, which does the action 4 time. The thing is mouse movement is relative in the game to the mouse sensitivity setting. Meaning every real mouse movement doesn't translate into exact movement in game. So I have to find the multiplier given no acceleration 
I get the impression you don't yet understand copy-on-write. The forked programs share memory only until one of them writes something. Think of it this way: * Threads share all memory *by default* except for data that is explicitly marked thread-local. * Processes share all *un-written-to* memory except for data that is explicitly marked shared. Data that is written to is duplicated before the write so that nothing in the parent is affected. Copy-on-write means the two PIDs have a separate view of the world while retaining performance. Now, /u/ben_craig points out correctly that file descriptors can be an issue, as they are duplicated. A program must be designed to fork correctly due to this. That said, forking can be a performant and reliable way get parallelism, certainly safer than un-guarded threads all spinning on the same shared memory. 
And do 1/4 of that every movement so correlate to 4 threads. 
&gt; fork() is terrible. I think this is still underselling the reality.
Yes, definitely. It's a trade-off between throughput (copying once or twice) and latency. This approach chooses the latency of the producer over all other considerations, and therefore minimizes the work of the producer, not the work of the overall system.
OK, but *why*? Just so the child inherits all parent resources?
It wouldn't be out of the realm of possibility for the optimizer to do something like this: union { uint64_t x; double y; } t; t.x = 5; t.y = sqrt(some_number); t.x + 5; // compiler inlines t.x == 5 here because reading t.x with t.y as the active member is undefined. I'm not sure if this is actually still valid when you take into account all the other rules governing optimizers, but that's basically what "undefined" behaviour is: escape hatches for the optimizer to re-write your code in a weird way that follows (because there's nothing forcing the compiler to emit code that actually reads from memory).
+1, was immediately thinking about training a classifier too ;-) I'd probably go with JohnMcPineapple's approach though, unless you really need human movement to for example fool a bot-detection algorithm or something like that.
You would also want to add random small amounts of random noise around your ideal path to simulate that humans don't move in straight lines.
My perspective is from an application developer. Exceptions make sense for libraries for sure. 
&gt; fork is the only thing that allows you to have in unix shell &gt; &gt; &gt; &gt; gzcat bigfile| grep somethin| sort | cut -d ' ' -f 7 | gzip -c &gt; out.gz Strictly speaking, this does not require fork(); spawn() will also do.
I wander what it's doing in C++...
`fork` is a tool in a toolbox you can use if you find it useful. It's not "evil" or "terrible". You may think that a std::thread is a small contained piece that executes concurrently. In reality, your thread will manipulate global resources. For example, if your thread creates a std::fstream or socket, a file descriptor will be allocated, which in many Unix variants will be inheritable by default (O_CLOEXEC is a recent invention). This means, if another thread does a concurrent `system` or `exec`, that process will inherit your file handle. This is especially annoying when you're doing socket programming, because that means the child process might keep the socket open even if you wanted to close it to signal the other side. Thus, everything in your program will have to be aware of whether there can be parallel threads. In this case, `fork` would have helped you: at the start of your program, before you start getting busy, make a controlled environment (for example, with a socketpair for communication), fork, and have the forked process take care of all `system` and `exec` you need. That aside, `fork` is very local knowlegde. Other than the few lines of code involved in the actual forking, nobody else needs to know whether there is a fork. Sure, you'll have all your code mapped in the child address space, but as long as you don't use it it will just lay there.
Define exceptional behaviour 
Perfect. Exactly what I wanted. Thanks! 
&gt; Exception are for when you need to be informed that something went wrong, and why it went wrong 
I have question to ask, I'm coding my stuff in c++, would like an answer that is related to c++. Got my answers from the smart people here. And you, what are you commenting for? 
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I don't think you know what "clickbait" means. The title accurately describes the content and everything is contained in one page. Nothing clickbaity here, unless you consider any instance of a list "clickbait".
Not necessarily, errors like double-frees, dangling pointers, use-after-free, and uninitalized memory can still affect a C++ program. While rare, c++ programs can still directly call malloc and are susceptible to the error described in the `Type Mismatch` section. 
I can only think of two sane uses of `fork()`. If you need to daemonize your process, you have to use it as part of the procedure to detach from the controlling terminal. In that case, the parent process should immediately exit; so, there's no issue there -- there's only one copy of your program running. If you want to launch another process from within your program, you have to call `fork()`, but then the child process should immediately call `exec()`, which replaces the process image with a new one. The end result is, again, only one copy of your program. Before pthreads (and long before `std::thread`), you did have to use `fork()` if you wanted any form of multiprocessing. Fortunately, you haven't had to do that for 20 years now. 
Yes, but that undefined behavior is often useful, so that's basically the reason that unions exist.
Feedback in general, not only in particular to this one. This webinar pest has to die. Everywhere 'free' content, when you are willing to provide your data... ... also often I don't see the value when those webinars get shared recorded later on youtube. And don't get me wrong, I think we need more and different, but open formats discussing C++, such as CppChat and CppCast. But they need to be able to reach an audience and be interesting, not locked up behind login pages and data mining.
&gt;&gt;Using pow(-1, x) for toggling int math is inefficient and a bit risky. I forgot about that. I had to write my own int pow function because the floating point math wasn't giving me the precision I wanted for an assignment. Should I just use a if/else statement instead? &gt;&gt;Rather than documenting the parameters for the geckoStep methods in comments, you could just name the arguments in the declarations. So like `geckoStep(a, b, c) m; // function A does this, B does that` ? &gt;&gt;Watch your boundary cases.. You're right, it overflows when I put in a 6 digit number. Thank you so much for your input. Most of the points I didn't respond to were over my head and are exactly what I was looking for in this post.
Nobody gives a shit about monads and homomorphisms. "This much, much better way of doing things sucks because it's less theoretically pure, despite being better in literally every way."
Yes, arduino's ints are 16 bit, so I've been using long to take the &gt;30000 step counts. I didn't know you could manually specify the variable though, I've just been using ints, chars, doubles, and now longs. What do you mean by class variable notation? Is it some sort of consensus on how they should be named? If so, can you point me to an example?
If you read the sidebar, you would know &gt; For C++ questions, answers, help, and advice see r/cpp_questions or StackOverflow. 
But why would they? If you're writing your own code why use C style memory allocation? If you're using C++ you won't have any `Type Mismatches`.
How about using fork to avoid heap fragmentation?
threads or processes: choose ONE, because you CANNOT use both. 
Most of the problems around threads &amp; fork have to do with posix semantics that were established before threads were supported. Modern OS's have quite sane semantics for threads &amp; fork, but you do have legacy apps that don't know about the changes...
This is the most ridiculous thing I have ever read. fork() is a tool. When used properly it is incredibly powerful and fast. When used improperly it will deadlock your program - JUST LIKE A HUNDRED OTHER TOOLS. If you know what your programs are doing, fork() is just fine. OOM is something every OS has to handle. It is not "motivated by fork". It is motivated by the realities of demand paging and virtual memory. If you don't like those things, feel free to go back to DOS. Wow, I just...wow. In 20 years of programming, I have never seen such a poor response to a legitimate question.
No. The correct way to do it is by using `std::memcpy` like /u/millenix pointed out.
Is it valid C? I am not particularly familiar with the C standard, but I am still willing to go out on a limb and say it isn't. Edit: I stand corrected. It is valid C99.
&gt; I thought it would be impossible to use sharedptr and the like. ? sharedptr works fine with fork. I mean... really fine. It does exactly the right thing.
There are several other sane use cases. It's very handy for having a pool of worker processes all accepting connections on a shared socket. In general, there a lot of cases where one might be tempted to use threads, but in reality you don't want to share any memory from *after* the thread is spawned, and that's exactly what fork() will give you.
I thought this was an interesting application of variant types, so I thought I'd share it. Can you think of situations where something like this would be useful?
Only a Sith deals in absolutes. A little explanation for your bold assertion might help.
Hope that someone in the know can add them before too long; it's a bit of a drag being jealous of visual studio ;-)
&gt; OOM is something every OS has to handle Poppycock! Windows does not, no language spec does delegate OOM to the OS and on UNIX one can turn OOM killer off. OS can simply return an error to the application when it can't satisfy memory allocation request, and that is not handling, but reporting. 
Your program's pre-fork atfork handler acquires all of the mutexes, and the post-fork child atfork handler releases them! Mmmmmm. better^hope^that^thread^doesn't^have^any^mutexes^locked^tho
Not on all POSIX operating systems. For example, QNX, and (I think) cygwin.
Maybe what you want is a `std::map&lt;std::tuple&lt;Args...&gt;, R&gt; myNDimentionalArray;`. The key of the map is a tuple of all the parameter sent, and the value type of the map is the result of the function. It's sort of a n dimensional array.
I'd much rather use std::future
Couldn't this be an issue if on the application side you also depend on (a potentially different version of) fmt?
Most of those are features, not bugs.
"I don't understand monads and why they are useful, so I don't think anyone cares."
Definitely - i'll work in a link to it in my next update. Thanks for pointing this out.
yep - i've had that before - very annoying. Unfortunately, if you're using C++/CX - there is no avoiding doing that - it seems that language was designed to have a long tail of catch blocks.
good one :)
As a 'non pro seasonal hobby programmer' I see a chance to to get semi serious feedback on a related subject. *Tagged Pointers:* (Unknown word until today, reading wikipedia on the subj. ok smart pointers must be tagged pointer then). Watching Bjarne Stroustup talk about putting C arrays out of business because they where a source of errors and buffer overflows, coming from the lack of size/number of elements build into the construct. I was kind of surprised to discover that smart-pointers did not have the possibility to have that kind of information build in. I mean std::make_unique takes number_of_Elements in its constructor, so why not use it? Some time ago I played with the idea and kind of ended with my Fanzy_ptr that has the basic and can stream to disk, calling usefanzy(filename) produces a 10Kb file filled with 5x2KB blocks containing the right data as it should. (I had a screenbuffer of RGBA pixels that I wanted to save to disk to open in Gimp .data - raw format) This C++14 use of returning a private struct prevents me from using it in a function declaration, so I should make it into a template class I guess. What do you think about my Fanzy_ptr concept shouldn't I at least get a +1 for the name lol. // first attempt auto GetMemory(uint32_t numbytes) { struct mblk { std::unique_ptr&lt;uint8_t[]&gt; ptr; const uint32_t numOfbytes; uint32_t size(){ return numOfbytes;} }; return mblk{ std::unique_ptr&lt;uint8_t[]&gt;(new uint8_t[numbytes]) , numbytes }; } // use of.. auto memblock = GetMemory(1024); for(uint32_t i=0; i&lt;memblock.size();++i) memblock.ptr[i]=0xFF; // 2nd. attempt ----------------------- template&lt;typename T&gt; auto makeFanzy_ptr( const size_t Number_of_Elements ) { struct fanzy_ptr { std::unique_ptr&lt;T[]&gt; ptr; const size_t number_of_elements; size_t size() { return number_of_elements;} size_t Sizeof() { return sizeof(T)*number_of_elements;} size_t Sizeofelm() { return sizeof(T);} T* begin() { return ptr.get();} T* end() { return ptr.get()+number_of_elements;} auto beginCast8s() { return reinterpret_cast&lt;char*&gt;(ptr.get());} auto endCast8s() { return reinterpret_cast&lt;char*&gt;(ptr.get()+number_of_elements*sizeof(T) );} }; return fanzy_ptr{ std::make_unique&lt;T[]&gt;(Number_of_Elements), Number_of_Elements }; } // use of.. struct pixel { uint8_t R,G,B,A; pixel() : R{0},G{0},B{0},A{0} {} pixel(uint8_t r,uint8_t g,uint8_t b,uint8_t a) : R{r},G{g},B{b},A{a} {} }; // void usefanzy(std::string filename) { auto Fptr8 = makeFanzy_ptr&lt;uint8&gt;(2048); auto Fptr16 = makeFanzy_ptr&lt;uint16&gt;(1024); auto Fptr32 = makeFanzy_ptr&lt;uint32&gt;(512); auto Fptr64 = makeFanzy_ptr&lt;uint64&gt;(256); auto pix = makeFanzy_ptr&lt;pixel&gt;(512); std::fill(Fptr8.begin(), Fptr8.end(), 0xB1); std::fill(Fptr16.begin(), Fptr16.end(), 0xF2F1); std::fill(Fptr32.begin(), Fptr32.end(), 0xA0B0C0D0); std::fill(Fptr64.begin(), Fptr64.end(), 0x0809A0B0C0D0E0F0); std::fill(pix.begin(), pix.end(), pixel{255,10,128,255}); std::ofstream fileStream( filename, std::ios::out | std::ios::binary); if(fileStream.is_open()) { fileStream.write( Fptr8.beginCast8s(), Fptr8.Sizeof() ); fileStream.write( Fptr16.beginCast8s(), Fptr16.Sizeof() ); fileStream.write( Fptr32.beginCast8s(), Fptr32.Sizeof() ); fileStream.write( Fptr64.beginCast8s(), Fptr64.Sizeof() ); fileStream.write( pix.beginCast8s(), pix.Sizeof() ); } } 
According to https://youtu.be/Jd8MI4b_AUc?t=2m36s it is not valid C99. It could be wrong, but I would like to see an actual standards citation or another credible source that states so.
[N1235: C99 TC3](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1235.pdf) (Technical Corrigenda): &gt; 6.5.2.3#3: 78a If the member used to access the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called "type punning"). This might be a trap representation. 
Are you 12 years old? You sure seem to be acting like it. 'Salty'? Really?
Are you really trying to create an illegal cheat program for a game?
If you believe that being a grad student is proof of someone understanding mathematics, well, I have a very nice bridge I would to sell to you.
When I last checked, C++ support was lacking, it was mainly for other languages (JS, Python, ...) and it was more of a "text editor" than a programming IDE. Have things improved so much in the last 6+ months?
It seams that its a big subject with pros/cons check: http://stackoverflow.com/questions/1228161/why-use-prefixes-on-member-variables-in-c-classes _C (underscore &amp; capital letter) is also a reserved word so don't use that, - I had forgot about that one, ever thou I did only suggest _v. You could also just put arduino.h in a namespace to avoid confusion.I'm nitpicking now I know, -the code size in mind, but I think the m notation is a great help when scanning a large hpp file, one quick look at the private member variables section is enough so that when you go through the cpp file you know anything with m is class local, and m_ is a variable that derived from a base class, what's left is either declared in the member function or coming from a .h file witch hopefully is in a namespace. Well that's my opinion anyway. But I love strong coloured syntax highlighting I've just made all my const variables aliases red, witch made my hpp file light up in red for all the const read only stuff and and blue for the read/writeable stuff. Witch made me say Why is this variable or vector not red since I'm only setting the value once or not writing to it. uint32C is const uint32_t so it works when no highlighting. It looks like this http://i.imgur.com/xhT4blD.jpg It's properly not for production or pro use but I like it for it enforces const, something I was to lazy to write before. 
[removed]
You can get overcommit from Windows APIs, but you have to ask for it, and you don't get it from any malloc implementation on Windows (I dare you to find one). That's the difference from Unix. Mmap, by the way, is not where it's at, are you just trying to "win" something?!
Yes, I don't have formal training in CS, programming is a hobby. Your post and reading the COW wiki clears up some stuff. Thanks!
Much appreciated
Depend on what you count as illegal. And sure. I know programming language to make my life easier. If that provide me fun and shit why not? And yes i do have fun cheating. 
Usually people just use `std::decay_t` when `uncvref_t` is needed.
I know but that is wrong because it doesn't work. For example, `std::decay_t&lt;char(&amp;)[3]&gt; == char*` and not `char[3]`. The standard type traits that work are `std::remove_cv_t&lt;std::remove_referece_t&lt;char(&amp;)[3]&gt;&gt; == char[3]`, but people still prefer `decay_t` in this case because it is shorter even though it produces the wrong result. The `std::decay_t` trait is useful, but it solves a different problem than `uncvref_t`. It is just similar enough to be dangerous. 
I have used this pattern before, and in my opinion it works well. One case where it worked out fairly well is implementing generic piecewise paths that can contain lots of different segment types (straight lines, arcs, splines, etc.). I preferred for the path to hold each segment by value as it dramatically simplified management of the entities. Further, there's a common interface that all one-dimensional continuous segments can support (start/end point querying, parameter evaluation, tangency/normal evaluation, distance queries, discretization, etc.). So making a polymorphic variant over the segment types just seemed to make sense and IMO worked very well, it provided a clean, simple interface that's easy to reason about.
I think you are missing a "," in the example, behind the first lambda.
Hm, I guess I don't know how to do it easily using such approach without concepts. Maybe you can write `perfect_forward` function template&lt;typename T, typename Func&gt; auto perfect_forward (Func func) { struct helper { Func func; template&lt;typename Args, typename = enable_if_t&lt;std::is_same_v&lt;T, std::decay_t&lt;Args&gt;&gt;&gt; decltype(auto) operator (Args &amp;&amp;args) ( return func (std::forward&lt;Args&gt; (args)); } }; return helper {func}; } and use it like this: visit(overload ( perfect_forward&lt;A&gt;([] (auto &amp;&amp;) {std::cout &lt;&lt; "A" &lt;&lt; std::endl;}), perfect_forward&lt;B&gt;([] (auto &amp;&amp;) {std::cout &lt;&lt; "B" &lt;&lt; std::endl;}) ), v); I'm not sure it will work (not even tested if it compiles), but something like this may work. 
Default case is easy - overload ( [] (const A &amp;) {std::cout &lt;&lt; "A" &lt;&lt; std::endl;}), [] (const auto &amp;) {std::cout &lt;&lt; "default" &lt;&lt; std::endl;})); /// default case There is similar function (but harder to implement) - `overload_first`, that behaves practically like if\else switch (i.e. not using overload resolution, but using first function that matches). 
&gt; Without knowing what effect your trying to achieve Breaking the new reCAPTCHA? It asks you to move the mouse and click on a checkbox.
Now combine default case + perfect forwarding to achieve maximum FUN ! :D (just think the worst, suppose somebody passes you a move-only type like an `unique_ptr` that you want to handle in the default case) &gt; There is similar function (but harder to implement) - overload_first, that behaves practically like if\else switch (i.e. not using overload resolution, but using first function that matches). There is something like this in Boost.FIT. Its pretty nice. /u/tgolyi Note, however, that `first_overload` selects the first overload that matches, which might introduce object slicing (in particular since `B : A`): first_overload( [] (const A &amp;) {std::cout &lt;&lt; "A" &lt;&lt; std::endl;}), // B always gets sliced here [] (const B &amp;) {std::cout &lt;&lt; "NEVER GETS PRINTED" &lt;&lt; std::endl;}), [] (const auto &amp;) {std::cout &lt;&lt; "default" &lt;&lt; std::endl;}) ) I don't know, when you deal with perfect forwarding, and a default case with perfect forwarding, and move only types... Do you still think that using `overload`/`first_overload` is easier to understand than `constexpr if`? 
I merely intended to point out how silly the "fork() is terrible" argument was, not to discuss the finer points of the Windows kernel, about which I know next to nothing.
At least in range-v3 `Same&lt;T, U&gt;` requires two types, but /u/caseycarter should know.
Cool, thanks!
Well of course if you use first_overload, you need to be careful with position of functions (you need to switch first two arguments). I guess default case + perfect forwarding should work just fine too. Of course, using `overload` gives you less flexibility that `if constexpr`, but in most cases it's simpler. Using perfect forwarding is not the most common situation in user code anyway (especially with variants, never seen it before)
Yeah as long as you are careful and don't have to deal with corner cases `overload` results in really tight and readable code. &gt; Using perfect forwarding is not the most common situation in user code anyway (especially with variants, never seen it before) When writing generic code that use variants, you might want it to work with both rvalue and lvalue variants, and perfect forward whatever the variant contains to some other code. For some reason I end up writing code like this a lot. The first example that comes to mind is `std::visit` which needs to handle rvalue variants and move out the type they contain. 
Oh I assumed it did. IIRC there was a different `std::visit` interface that used to take one variant but multiple callables `std::visit(variant, f0, f1, f2...)` and that performed overload resolution, but that got ditched because `std::overload` covered that case and it allowed `visit` to take multiple variants instead `std::visit(ternary_visitor, v0, v1, v2)`. I wonder whether omiting `overload` was an overlook or something deliberate. 
X-Post referenced from /r/mongodb by /u/GoogieK [Introducing Mangrove: the MongoDB C++ ODM](https://www.reddit.com/r/mongodb/comments/4wb07v/introducing_mangrove_the_mongodb_c_odm/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Yes. `std::expected` and `std::optional` are for those people who currently use exceptions as control flow. Having something separate that can't be ignored will always have application.
I use boost::optional very heavily, and still use exceptions in a few places. * Quitting the program from the UI. I throw QuitException(), catch it main(), clean up and return. I don't know how to do that without exceptions in a moderately large GUI program. Calling exit() is not a good option. * Retrying a non-deterministic function call that can fail deep in the callstack. * Catching an error for many calls at once, like in this example (sorry, I don't know how to format this): try { int paramA = parse&lt;int&gt;(field[0]); float paramB = parse&lt;float&gt;(field[1]); ... } catch (const ParseException&amp;) { printError(...); } 
`Same&lt;A&gt;` is a *partial-concept-id*; it will match any type `T` such that `Same&lt;T, A&gt;` is satisfied - which in this case is only `A`. The signature `[](Same&lt;A&gt; &amp;&amp; val)` will match only rvalue `A` expressions. If you want to match when `Same&lt;uncvref_t&lt;T&gt;, A&gt;` holds, you'll need a more complicated concept definition a la: template&lt;class T, class U&gt; concept bool UnCVRefsTo = Same&lt;remove_cv_t&lt;remove_reference_t&lt;T&gt;&gt;, U&gt;; 
Linus hates C++ for a lot more reasons than exceptions. 
I would recommend giving a shot at the 'C/C++ extension' shipped by [Microsoft!] (https://blogs.msdn.microsoft.com/vcblog/2016/04/15/update-your-visual-studio-code-cc-extension-now/). I work on this team and currently it offers a basic code navigation, heuristic based auto-complete experience along with a debugging experience for all platforms. This would be an improved experience vs. the basic text mate bundle experience. We don't support CMake yet as a part of this extension but there are other extensions which you are most likely already using. We Would love to hear your feedback and appreciate if you can give this extension a shot and help us improve it for C++ developers.
Stack unwinding and exception propagation are done automatically. That means learners (like me) could write exception-safe and fail-safe codes without explicitly dealing with exceptions. For the (hypothetical) std::expected and std::optional, we must explicitly propagate the error message, which at least requires some knowledge of these type and their usage.
yep! This is similar to how constructors will still throw exceptions.
 Indeed, thanks! I copy-pasted it wrong from range-v3. I fixed it above.
&gt; If you fork while you have some library in a state where it is holding on to some system resource, you're going to have that library have all the other state associated with that resource as well. Say the parent process has a log file. You fork. Then both the parent and child continue to do things to the log. You can get corrupted logs easily in this scenario unless you use system-wide locks and/or lock-files to prevent these kind of issues. A pthread_mutex won't do, because those are local to a single process. &gt;&gt; fork() effectively disables a very useful security mitigation (Address Space Layout Randomization) because the copied process doesn't get re-randomized &gt; ...until exec happens. If you were just going to exec() after fork(), why not just use spawn() in the first place? Yes, you can paper over the issue, or you can just use a better API. Real servers like OpenSSH, Apache, and Nginx have run into this problem. &gt; That's way overstating it. There are many other scenarios where you have copy-on-write pages, and that isn't even counting the scenarios where you just want delayed allocation of pages/address space... There are other copy-on-write scenarios, but fork() will generate a whole bunch of copy-on-write pages at once. If it weren't for fork, backing memory for copy-on-write pages might have been set up such that the memory was committed (though not paged in) in advance. &gt; There really are a lot of ways that fork makes things more elegant than spawn. The spawn family of functions tend to get complicated, because they have to cover all the permutations around fork(), exec(), and a few other primitives. This is reinforcing my point. Part of the reason fork() is terrible is because it makes 'good' APIs (like spawn) more complicated in order to accommodate fork().
Writing strong exception safe code is pretty tough, and in practice pretty rare. optional/expected don't make this easier (since exceptions still exist), but avoiding accidental state corruption/bugs during errors is much easier IME if the error doesn't unwind. There's a little bit of tedium for propagating optional/expected but honestly its not that bad (If you have to do it too far then maybe you do want to use an exception). And as for having to know the types, I mean, that's true for everything.
&gt; I don't know how to do that without exceptions in a moderately large GUI program. Calling exit() is not a good option. Generally I've done that with some piece of state to which anything needing to quit is given access. Using exceptions limits where and how you can trigger the quit action (e.g., must be on the main thread, must be in a callstack off the point in `main` where it's caught, etc.), and makes it harder to compose quit triggers/filters/dialogs/etc. as exceptions just smash through everything rather than filtering through pre-registered callback chains. &gt; Retrying a non-deterministic function call that can fail deep in the callstack This is one of the only reasonable uses for exceptions, and only in languages that don't give you better tools. When your only options are return values or C++ exceptions, you use C++ exceptions when you have these sorts of problems. Exceptions are, essentially, the lesser of two evils (in this case, at least). I've generally just avoided those sorts of problems as I find that for (most) code a deep callstack is indicative of a design problem. That isn't always true, of course, so it's more of a guideline than a rule. :) Basically just an application of KISS. &gt; try { int paramA = parse&lt;int&gt;(field[0]); float paramB = parse&lt;float&gt;(field[1]); ... } catch (const ParseException&amp;) { printError(...); } Interfaces like that are poorly-design IMO. If you have a ton of individual statements that can fail, you might want to rethink how the code is structured. Any interface that pushes errors to clients unnecessarily is creating complication and a potential source of bugs. Especially in languages like C++ where you can forget to catch an exception and there's no compile-time diagnostic that it'll be uncaught and crash the application. This is true of C++-style exceptions, C-style return codes, FP-style monadic values, nullable pointers/references, etc. While there are some error-handling approaches that are more reliable, in general I prefer to avoid having failure points where you don't need them. For example with parsing, I generally take an approach where you pass in an error callback for printing parsing errors with diagnostic information. These callbacks - being invoked at the point of error - can often provide the best diagnostic. Further, the code calling the parsing doesn't need to care about individual errors. The individual data items can usually use safe fallbacks (e.g., `0` or something for numeric types) and then check whether any errors happened just once at the end of the process. Not always an option, granted, but there are more capable variations of this approach that almost always will. Extra bonus for parsing because then you can grab all the parse errors instead of just the first one, which can be more user-friendly in some cases. And while it's slower to finish parsing without stopping on the first error, it's an error case, so who cares if it's super efficient? Exceptions tend to cause more problems than they solve and they tend to be sub-par solutions even in the cases where they don't cause problems. There's better options. Not necessarily in C++ at times, though, which is the really sad part: sometimes an exception is just the best of the bad options available to C++ programmers. Fixing this is hard because too many folks are lacking the wider experience they need to really have a meaningful discussion on the topic, and a good number of those folks are committee members. :/
At first I thought your works/doesn't work list would be pros and cons, but those both sound like pros to me. I might give this another try even though I am normally rabidly anti-microsoft.
https://github.com/Microsoft/vscode &amp;nbsp; ^^Did ^^you ^^even ^^try..? ^^;-]
&gt; Linus hates ~~C++ for a lot more reasons than exceptions.~~ 
I did, but It was mostly me looking around the site and download page. Thank you.
The language is one big one that _everyone_ complains about. The entire fact that it's a procedural configuration language leads to an awful lot of very unmaintainable CMake build systems. `IF` statements spread throughout a codebase is a very common problem. It's many of the worst part of coding in C ported into a build system, mixed with the inconsistent and bewildering syntax of PHP, and topped off with a lacking set of built-ins to make up for the first two items. It's over-complicated, incomplete, and lacking in holistic design sense. The procedural approach to build definition also leads to a lot of annoyances and duplication. For instance, specifying source files with IDE "filters" requires putting all the sources into separate groups of variables, then merging those groups for defining the project, then making groups of calls using the variables to set the filters. Same goes for any other source file properties. It's a build system for C++ that doesn't have native PCH support. You have to roll your own (difficult because CMake's language sucks) or use something like cotire (which doesn't even work everywhere because CMake is missing key sets of functionality for common build systems necessary to supporting PCHes). A C++ build system lacking PCH support is like a car that's missing a gas pedal; it's not complete. It can't decide if it wants to impose directory structure or not. You get all the annoyances of needing to conform to CMake's preferred structure (or work around it if you have a large codebase you need to port) without the benefit of knowing _for sure_ that everyone adheres to its structure. You lack free definition and haven't even gained semantic tooling. CMake can't be used easily with sub-module style project structures. The official recommendation is to make your project an "external project" and then make a root project that has both your project and all dependencies as external projects. This has its own set of issues I could go into at length; suffice to say, it sucks. The build files it produces are typically inferior - and vastly so - to what a simple Python script can generate for you. The Makefiles it creates are _sloooooow_, the Ninja builds it generates are neutered and buggy, and the MSBuild files it generates are unnecessarily non-idiomatic (and slow). Near every time there's some feature specific to a backend that people clamor for loudly enough, the CMake engineers build it in a one-off fashion (or just incompletely implement it for only one or two backends). The codebase is a pile of hacks. Trying to fix backend bugs or add features is a pain. It's not the worst codebase I've suffered through, but it's in the top 5. Design choices in CMake have hampered extensibility. It has built-in support for backends that can support multiple build configurations (but of course, only some backends support that) but no support for backends that can support multiple architectures/platforms. Generators seem like a generalized fix but they're incomplete and ineffective, and neither the variable suffixes nor generators eliminate that need for spaghetti `IF` statements in the build definition for complex projects. Related to the above, CMake can't generate a single build tree that supports multiple architectures. This is a huge pain for IDE users that might want to regularly build their code on both x86 and amd64, for instance. Features like CMake generators are hacked into the language and inconsistent. Some functions use them, some don't, and it's never obvious. Generators then typically output code into build files which further results in slow and difficult-to-debug builds, if not just outright bugs. I've yet to work on a non-trivial application using CMake without running into at least one CMake bug that needs working around. For such a commonly-used tool that evolves so slowly, it sure seems rickety. Important features like "source libraries" are missing. Transitive dependencies are difficult to get right. Backends are half-complete. I could go on for a bit, but this is already getting long. Extra short version: writing CMake builds is harder than it needs to be and the CMake output is worse than it should be.
The type mismatch being referred to is not a *static* type mismatch, but a run time one. They're also definitely not uncommon in C++ (based on the production data we have). For example, you have some complex type hierarchy and incorrectly manage memory associated with it. Now, memory that is assumed to point to type A, is actually associated with type B. This is the example that is the cited in the blog and the type of thing that can be detected. C style allocations were used here (as also used in C++ behind the scenes in many cases) for simplicity.
&gt; [logging example bits] Yes, you can make logging work with fork(). If you know you are going to fork, you basically do what you said. If you usually don't fork, but you have to guard against the possibility that someone, somewhere might fork, then you have to pessimize and complicate your code in advance. I don't want to make all my mutexes process shared mutexes, and I don't want to make all my file i/o atomic. &gt;&gt; If you were just going to exec() after fork(), why not just use spawn() in the first place? &gt; If you weren't going to exec(), how would you want ASLR to take place? I would want every processes memory layout to be unpredictable. With the previously mentioned web servers and the current fork+ASLR model, an attacker can slowly learn the address space of the parent process (and subsequently spawned children) if they find a buffer overflow. If each child had a different address space layout, then crashed children wouldn't leak that information about the parent. &gt; But it is a very common model to want "give me another process that has the full context of everything up until now, but is oblivious to what happens next". The use case exists, and having an abstraction for the model is convenient for those use cases. The users of the model tend to be high profile, but I don't think it is a very common use case. I don't think the abstraction is worth the costs that it imposes elsewhere. &gt; I think you misunderstand what I'm saying. I did misunderstand your point. I will agree that the number of options for process creation is very high, and that splitting that load into multiple functions could be useful. I don't think that split should be fork / exec though :)
I'm sorry I was making fun out of the title. The post offers nearly 0 for C++, except that C is a subset of C++. No mention of new/delete, and also smart pointers aren't mentioned. From C++ perspective that makes this article not really interesting. Even the demonstrated code in C is only safe, if exceptions are off. If the person list would be used in C++, and an exception occured, the person_free function would not be called, while smart pointer still could handle the resource clean up.
I have something similar in concept but different in practice (it uses customizable small-buffer optimization and allow non-owning reference types). Not ready yet for production but you can take a look there: https://github.com/Klaim/polystorage (I just tried to isolate the common part of all my hand-written value-semantic types and it resulted in this - start at the definition of lol::Foo) Also you might want to read the work-in-progress papers "Virtual Concepts" which is somewhere on github. It also points to other similar attempts.
&gt; If you usually don't fork, but you have to guard against the possibility that someone, somewhere might fork, then you have to pessimize and complicate your code in advance. I don't want to make all my mutexes process shared mutexes, and I don't want to make all my file i/o atomic. You might not *want* to make all your file i/o atomic, but your logging *really* ought to be done in an atomic fashion, particularly since with logging you commonly aren't fully in charge of who writes to the logging destination. In reality, this argument could just as easily be made about libraries not knowing about threads. If you write stuff properly, you are okay. If you don't... it'll be a mess. &gt; I would want every processes memory layout to be unpredictable. With the previously mentioned web servers and the current fork+ASLR model, an attacker can slowly learn the address space of the parent process (and subsequently spawned children) if they find a buffer overflow. If each child had a different address space layout, then crashed children wouldn't leak that information about the parent. That's great for when you want it. Go ahead and do a fork &amp; exec, or write a linker that dynamically relinks and readdresses memory in an atfork (it'll be about as fast as doing it any other way). There are a lot of use cases though where that is actually undesirable behaviour. &gt; The use case exists, and having an abstraction for the model is convenient for those use cases. The users of the model tend to be high profile, but I don't think it is a very common use case. I don't think the abstraction is worth the costs that it imposes elsewhere. It's a lot bigger than that. Many use cases with threads and async tasks actually fit that model better and mitigate a lot of risks by following it.
RAII is not a silver bullet unfortunately. Yes, if person_free was not called in that manner, then there would be no issue üòõ I could come up with another case where RAII fails. Regardless, I will work on a more C++-oriented post for the future! Thanks for the feedback.
In the examples here, there's no reason whatsoever to inherit from the template parameter T in the first place. Even leaving aside the fact that the mixins have no data and could have their methods be static, you could have the T as a member variable instead of inherit from it. You never use the interface that the animal classes inherit from T externally (the intelligentComment method), so why is it allowed to be part of the interface of the Animal classes? You should read Chapter 1 of Alexandrescu's Modern C++ Design, he goes over this technique in much more depth with better examples (he calls it policy oriented design). Also, don't use new, use make_unique.
Totally agree with this, you put way more effort into this answer than I intended to :)
depends on what you're doing, but typically you're going to be more productive doing small little jobs in a higher level language. Not always, but more often than not. Where C++ excels is in being low level, performant, and statically typed (more maintainable for long term/large projects).
It's not so much about the size of the program as whether or not C++ is the right tool for the job. It usually isn't. A good way to find the right tool is to look for similar projects and see what others have been using. Read their code, build it, step through it under debugger, try to understand it "all the way down". Consider contributing instead of writing your own. If you really have no idea, use Python.
What's an easy way to see [toplevel] posts chronologically?
With some of the stl one liners and generic code of c++14, c++ has Python magic at times
he? Did you read his (author) comments? Ones that he deleted. He deleted them for a reason.
I use Python/Bash/C++ depending on the job. The only annoyance of C++ for super little jobs is the compiling part, but that's enough to get me to use bash/python for a 100line prog. Bash is great as you can use compiled tools in it as well.
I don't believe that contest mode permits that for non-mods.
C++ is the language for things that need to be done perfectly, or which may eventually need to be done perfectly. It's for when you plan to invest not just the 20% of the effort for 80% of the result, but 100% of the effort for 100% of the result. If it will never have to be perfect, it's okay to use a language where mediocrity is easy (but perfection is impossible). Of course, the result will be mediocre. But usually easy, as long as you don't later try to solve problems that the "easier" language, and its platform, are not designed to easily solve. If you ever try that, you may find you have a bigger problem than if you just started in C++ to begin with. Then you may end up writing things like PHP compilers. Still, writing that first version was easy, and maybe that helped you make billions, eh? :)
In the last few years I've found javascript-firefox to be very handy. Let's talk about mangling infinite precision numbers, *libgmp* much? No thanks. GUI? Ouch. A few months ago while writing a workflow tool for my Android app I had to decide what to use. I initially went with C++ because I had all the libraries ready to go (*rapidjson*). The whole program just loads up every `.json` it can find in the current dir and compiles it to binary protobuffer. It was less than a day of work so I wouldn't say there was anything to gain in using python. Looking at the [introduction](https://developers.google.com/protocol-buffers/docs/pythontutorial) it seems to me language choice was basically orthogonal to what I had to write - there's no apparent 'python magic' going on, I just couldn't see any benefit.
I use C++ as a high level language, so your first statement applies to C++ for me. I _could_ use C++ as a low level language, but why would I want to?
I just use python for simple stuff because it's so easy to use. File IO in python is just with open() as f: C++ I need to work with fstream, iostream.
You're abusing words. I don't really give a crap what you consider high or low level, you're going to be more productive in the small with Ruby, Python, et al than you will C++. 
Got any good examples? (Genuinely curious)
Beginner questions should be sent to /r/cpp_questions.
The only issue C++ has lower level than those languages is memory management, and even then, since C++11 there is an official GC API as part of the standard.
what does GC have to do with anything I said?
&gt; I was wondering if C++ for small programs is rational, other than just for learning purposes. Yes, perfectly rational. With the wealth of libraries available, it's usually an easy way to get the job done. I also think that the smaller the project, the less it matters which language you pick... with a few exceptions. If the focus of my program is to have a nice GUI and the rest of the code will be pretty simple, I tend to use Visual C++ or [LiveCode](http://downloads.livecode.com/livecode/), and if I just need some glue between Linux utilities, I write bash scripts. But generally C++ just as easy for me to get a small project completed in as it would be in any other language.
Only at times. At other times the syntax is slightly more bloated than Python (but slightly more general): ex: how would you do a list comprehension easy to read?
While RAII is not perfect, its much better then the alternatives in C++. So when you do C++ today, you should avoid malloc/free and raw new/delete in your code, smart pointers take care of the memory issues. So from the C++ POV your article is just like coming to a gun fight with a knife.
I know that this python can be "compressed" into some pretty fancy one liners. Read a file, sort the lines, and print them: import sys lines = [line for line in open(sys.argv[1])] for line in sorted(line): print(line) . #include &lt;list&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; int main(int argc, char *argv[]) { std::list&lt;std::string&gt; lines; std::ifstream ifs(argv[1]); std::string line; while (std::readline(ifs, line)) lines.emplace_back(std::move(line)); std::sort(lines.begin(), lines.end()); for (auto &amp;line : lines) std::cout &lt;&lt; line &lt;&lt; std::endl; return 0; } Well, my point was it's not that much more code or more difficult to write. That's down to opinion, there they are. If I had been asked to write this in order to solve a problem, I probably would've used python unless: * The input file is several million lines * The code will be reused for a long time (Although, you know, realistically I'd just use `#!/usr/bin/cat $1 | sort`.) 
You should never use ``open`` this way. In your code you are leaving the file handle unclosed. Just use ``open`` always combined with ``with``! Untested I would suggest the following: #!/usr/bin/env python import sys with open(sys.argv[1]) as f: for row in sorted(f): print(row)
Is there some way to detect that process has been forked? Quick googling didn't return anything meaningful.
Basically I prefer C++ but if I have to build a simple windows tool with ui and stuff i awalys use C#. 
I prototype in python but then mainly develop in C++. The most recent example is a program to fetch and list the films and showtimes of all the cinemas near me in London.
I had an example or two with some remove_if and generic lambada using auto&amp;&amp; but the other two comments provided much more interesting examples I think. 
Minor nitpick: make_unique is C++14, and he targets C++11.
Come up.
There is no benefits using emplace_back instead of push_back, as you are already std:: moving string, right? Of I'm missing something?
What's the state of Boost.Http ? Can I use it for small, almost static web sites ?
Sure. Or perl. Or go. Or shell. Or, sometimes, SQL. C++ is seldom the best language for glue code, unless there are some other constraints (available library, performance or bounded memory constraints) but it's seldom a terrible choice either.
It is usually used as an argument of a language being high vs low level.
Actually Herb Sutter still argues for improving the situation, as it would be handy for lock-free algorithms.
Ok, thanks for the reply. While I have you here - do you know why unordered_map is implemented in VS as a hash table with bucket chaining? I made a open-addressed hash table with linear probing and it's a lot faster than std::unordered map. The semantics are not exactly directly comparable but I think you could implement unordered_map in this way and get a good speedup.
Our implementation is *extremely* old and shared with the non-standard stdext::hash_map, which I deprecated in VS 2015 as a prelude to removing it outright soon (which will make it possible to reimplement std::unordered_map without going crazy). Note that unordered_map's iterator validity guarantees require a node-based implementation. There are definitely other possible implementations than ours and I'm aware of a good blog post that I'll be looking at when the time comes for a rewrite, but most "hey I can do way better than unordered_map" implementations cannot meet the Standard's requirements, which is why I don't pay attention to people saying that.
Modern C++ is OFTEN the right tool for the job.
This can certainly be "compressed" more ;) #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;fstream&gt; #include &lt;iterator&gt; #include &lt;algorithm&gt; int main(int argc, char** argv) { std::ifstream file_in(argv[1]); std::vector&lt;std::string&gt; lines; std::copy(std::istream_iterator&lt;std::string&gt;(file_in), std::istream_iterator&lt;std::string&gt;(), std::back_inserter(lines)); std::sort(lines.begin(), lines.end()); std::copy(lines.begin(), lines.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, "\n")); return 0; } \[edit] I now realize this doesn't work if there are spaces on the lines :) Still, iterator copies are fun in C++, especially with `istream_iterator` and `ostream_iterator`
You can register callbacks for fork with [pthread_atfork](http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_atfork.html)
 std::unordered_map find then insert: 0.013959 s, final size: 65536 std::unordered_map just insert: 0.022715 s, final size: 65536 std::map find then insert: 0.044450 s, final size: 65536 std::map just insert: 0.051227 s, final size: 65536 Compiled with gcc 6.1 ("g++ -O3 -std=c++1z ./map_insert_test.cpp")
Eigen! They should get those French guys on the podcast, really cool library. 
Well MATLAB is a 4GL. It has not just the language to program, but also special support for arrays and a wealth of math functions taking those arrays. So it's not a fair comparison to C++ in this regard.
Thank you for this! Just wondering why this is being down voted? 
No idea why it's being downvoted; it looks like reasonable, though subjective advice. I think you're on a good path. There is a demand for C++ developers, and you may not need a degree if you can show off good skills. Note that learning C++ well generally takes several years, but it seems like you might already be on a good way there.
Yes, that's basically it. Essentially, std::unordered_map provides similar guarantees to std::map. This means inserting and removing elements (and rebucketing) cannot invalidate iterators to elements. This is why std::unordered_map is often implemented as a std::vector&lt;std::list&lt;T&gt;&gt;.
I think you meant "Cracking the Coding Interview".
&gt; What's the state of Boost.Http ? It's still pretty basic. The main change since last Boost review is the addition of this HTTP parser. I'm being funded so I had more time to invest in the library. I plan to collaborate more with Beast.HTTP, so I think I should focus on higher-level layers later, but a great step after HTTP/1.1 would be to support HTTP/2.0. &gt; Can I use it for small, almost static web sites ? Yes, and Boost.Http file server abstraction is really flexible. I think you'll have trouble trying to find something as good in the C++ land (it can really adapt itself to any need you have, be it in terms of async model you want to use like callbacks vs coroutines, be it in terms of simply serving files or customizing path resolution algorithm and still use its implementation to solve partial download for you, or just applying a filter to hide/reject/protect some files from all/some viewers). Please take a look: https://boostgsoc14.github.io/boost.http/reference/file_server_header.html I hope you enjoy it.
You can do better. Although, again, doesn't work with spaces :/ #include &lt;set&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;iterator&gt; #include &lt;string&gt; int main(int argc, char *argv[]) { for (auto &amp;line : std::multiset&lt;std::string&gt;(std::istream_iterator&lt;std::string&gt;(std::ifstream(argv[1])), {})) std::cout &lt;&lt; line &lt;&lt; "\n"; } EDIT: The following will handle spaces. I think you're not really supposed to inherit from `std::string`, although I think this is ok as long as you only ever pass Line as a template argument to istream_iterator. struct Line : std::string { friend std::istream&amp; operator &gt;&gt; (std::istream&amp; is, Line&amp; line) { return std::getline(is, line); } }; int main(int argc, char *argv[]) { for (auto &amp;line : std::multiset&lt;std::string&gt;(std::istream_iterator&lt;Line&gt;(std::ifstream(argv[1])), {})) std::cout &lt;&lt; line &lt;&lt; "\n"; }
Yes.
One of the common mistakes with `unordered_map` is forgetting that value type is actually `pair&lt;const Key, Value&gt;` and not `pair&lt;Key, Value&gt;`. If someone calls the methods with the wrong type, the implementation has to create the right type first. 
Ah, but if you come to us with pair&lt;const K, V&gt;, we can't move the key. If you bring pair&lt;K, V&gt;, we can still compare the keys in place, and then move-construct. If we metaprogram properly, that is. Constructing a node is unavoidable if you emplace from (X, Y) where X isn't the key type. We need to construct a key and we might be able to do so only once (if the key type is noncopyable/nonmovable).
Why?
C can have GC.
Indeed, I forgot about this.
afaik it is this http://flyingfrogblog.blogspot.ca/2013/10/herb-sutters-favorite-c-10-liner.html Interesting to note, that in the context of this discussion, this 10-liner, well, it doesn't really *do* anything. It is for *managing* things that do things you want to do. This thread is about using C++ to do small things quickly. This 10-liner re-enforces the fact that with C++, you have to spend a lot of time building up some fairly complex infrastructure to support what you want to do. The blog I linked to is about finding a probable bug in this so-called awesome 10 liner which was put forward as an example of how awesome the language is at doing small simple things quickly. The fact that it takes world class C++ experts to write, read and fixed so called "awesome short snippets" should really be telling about the suitability of C++ for short little programs to do specific tasks.... just saying.
Other than using `endl`, your edit nails it perfectly! (Unless Python flushes upon every newline (I have no idea) then ‚Äì just like 99% of the rest of the time ‚Äì `endl` is a wrong way of saying `'\n'`.) In particular, that is one of the few very acceptable use-cases for inheriting from one of the standard library (pseudo-)containers. That said, I think it reads slightly better using `std::copy` rather than `for` (no new scope): std::multiset&lt;std::string&gt; const lines(std::istream_iterator&lt;Line&gt;(std::ifstream(argv[1])), {}); std::copy(lines.begin(), lines.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, "\n"));
in the C++ world some background in data structures/algorithms is important (certainly when you interview). there are online courses for that, free or inexpensive
Absolutely. There is so much demand that many people working in this field that a lot of people with barely any skills get hired, you'll do fine.
I started learning Python when I was about 21, self taught and a field in a completely different degree. I got a job with a startup at 23 and have been working in the three years since. It's definitely possible, it'll just take a constant drive to keep learning and applying to smaller companies thirstier for talent. I feel like C++ probably has a tougher time finding devs than Python, so it'll help your chances. I've heard that Silicon Valley is desperate for talented devs, so if you've got the passion for it, in a year or two, start applying anywhere you can. If you've got a good github with a bit of a variety of sources you've written in there, I think you'll be in much better shape. I'm not sure about the UK market though.
It's shown literally less than a minute into the video.
Started a bit late? There is no such thing. Let's eradicate this elitist attitude that people have to start learning programming as kids in order to be a decent programmer. Most kids who learn programming are not that serious about it and not really learning the right way things are done. You can catch up quickly at any age. Don't listen to this "you started a bit late" bs. 
Not sure if this is a troll post. I am certainly not an elitist. Becoming a really proficient programmer takes many years (took me about 10). And it is proven that the human brain starts loosing elasticity around age 25. It is also an age where someone is expected to have a modicum of independence, thus reducing free time as well. OP if you interpreted this statement as discouraging, I apologize.
&gt; And it is proven that the human brain starts loosing elasticity around age 25. I'd never written a computer program before I was 25. At 28 I was writing C++ (and C and Python and occasionally some Fortran) for a living. Age has nothing to do with it.
 for (auto&amp; l_Item : m_Items) For iterators.
Absolutely you can do it. Find an open source project you care about, contribute to it as much as possible. You will land a junior programming gig no problem
That's why I have C# xD
Do you plan to land game-related job? I mean why SFML as practice? To get a junior job as C++ programmer you just need to know basics. Read Meyers effective C++ books Read Exceptional C++ and More Exceptional C++ by Herb Sutter (or just read all his guru articles) Finish coursera algorithm course (Standford one) With this 3 you can get junior/mid-position no problem For gaming you need more specific knowledge tho 
I've got a bachelors degree in computer information systems but I took a few courses in C++ and C# in college. The job I landed out of college is as a Java developer. I'd never written java code before. Most companies are looking for someone who has a good understanding of concepts that transcend languages. Understanding of OOP, recursion, revision tools, class diagrams, XML, ORMs, differences between primitive and complex types, memory management, abstraction and why it's useful, patterns (factory, singleton), and picking up a few popular libraries (maybe look into things like loggers and ORMs) would be useful. Also research some programming interview questions before you apply (Google search "fizz buzz") and solve them yourself on paper and then test your code. Some companies care about things like reputation on stack overflow so you might want to start an account there and ask some well thought out questions and post some answers to topics you are knowledgeable about. A degree doesn't matter that much. Other programmers I know have degrees in completely unrelated things like anthropology and statistics.
The fastest way with std::map (not unordered_map) would be, of course: auto i = m.lower_bound(key); if(i == m.end() || m-&gt;first != key) m.emplace(i, key, value); 
That should be `emplace_hint`. Also, C++17 makes this a one-liner with `try_emplace`.
Mode detection? 'More dedication'? 
There are loads of games companies that are either based in the UK, or have offices in the UK, mostly concentrated around Guildford and Newcastle. Personally so far I've worked for Midway, CCP, and Epic, and there are definitely more. They won't all hire juniors, though. Apply anyway! The code is excellent, but looking at it you still have a few things to learn: Algorithms: std::find would be perfect for your collision detection function. Lambdas: Also known as anonymous functions, they are the easiest way to use algorithms like std::find. Dynamic memory allocation. I love the design, most C++ books are too quick to teach new/delete, but you will need to know new/delete, and the newer unique_ptr / shared_ptr / make_unique / make_shared. You also have a bug: In your collision detection, when you find a collision you remove the last apple, _not the one you hit_. When you have one apple that's fine, but if you had two you'd have a bit of a bug when you ate whichever was first in the list. If you change to std::find to find which apple was hit (instead of the for loop), it returns an iterator which can be passed to m_apple.remove(it) to remove that specific apple. If you want a qualification the University of Teesside do some great games courses that are respected in the industry. Also get some experience with a public games engine, e.g. UE4 (which is free and C++)
I would debate this. It completely depends upon the game company. The big ones are giant corporations and mostly hire from top universities, successful projects, and companies they buy out. Smaller game companies are very different; not just from the big companies, but from each other. Some will love a self trained person. Others won't even look at someone from a lesser university. There are many game sweatshops that are resume gold. What they do is sub-contract to the big ones to make the lesser platform versions of the blockbuster games. So they take the game and cram it onto mobile or other such grinding. These companies are easy to spot as they are usually away from the core game concentration points. So if a small rural town has a game company with 50 employees and has worked on a blockbuster game, then it is one of these sweatshops. Some are very corporate, some are looking for you to just grind out code. 
&gt; And it is proven that the human brain starts loosing elasticity around age 25. That's old information which has been proved wrong. Please read on neuroplasticity.
You say that most old programmers are not familiar with C++ after 11. I know many 20 somethings (with solid degrees) who aren't yet familiar with 11. 
&gt; Let's be honest-- nobody likes working from the console I love working in the console. I even use it to write software. There are many usecases, even for costumer related software, to rely on the console. If you need a GUI than use what /u/zom-ponks suggested
I started my career when I was 29. I didn't know too much about C++. I had some C and Java knowledge. In my case being familiar with design patterns helped a lot.
I think [the example in one of the link is pretty good.](http://www.thinkbottomup.com.au/site/blog/C%20%20_Mixins_-_Reuse_through_inheritance_is_good) In the end, is it still inheritance, or is it optimized by the compiler? 
Oh absolutely agreed, use/create command line tools where appropriate. Then you make it possible to create pipelines and batch files to automate tasks. 
There is a difference between what is true and what is being perceived as true. I believe parent was operating on the former.
https://stefanoborini.gitbooks.io/modelviewcontroller/content/02_mvc_variations/variations_on_the_triad/46_data_binding.html Sorry, I haven't finished that section yet. 
Don't forget the "auxilliary" skills, even more so since you don't have a CS degree. Stanford algorithms lecture, and, especially since you're interested in games, watch [this](http://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/) linear algebra course - it should be doable without degree and it's really fun and enlightening! Also doing the first 10 or 15 lectures for a start is enough and then continue with the rest later. Second recommendation, go to meet-ups, there's no C++ usergroup in London atm, but I think there is one in Bristol... maybe you can go there from time to time. I wish you all the best, I think you have good chances!
I'm just curious, why do you build cmake and not just fetch a (or the latest) binary tar.gz from cmake.org? Works perfect for me. Also similar for boost, why not use the prebuilt binaries? Though in this case I'm not sure how it works on Linux.
Chromium embedded.
Right, at work I have to write custom models and while they have decent amounts of boilerplate they really make it easy. Also I don't even have to connect anything if you are using a default Qt view that can be backed by a model like a table or list. All you have to do is call setData() on the index range. It's great 
That's what I was thinking. Java and .net companies also tend to be traditional and want either many years of experience or a degree.
I have a degree and currently work in web dev, but am planning on switching. Do you think side projects would be necessary for me to land a junior job in southern california or will strong/algorithms and data structures be enough? One day I want to work in the game industry, but I would take any C++ gig paying a market rate at the moment. Any recommendations for side projects? Most complicated things I have are a compiler (but it is in python) and a basic interpreter in c++.
&gt; What do you think about my Fanzy_ptr concept shouldn't I at least get a +1 for the name lol. - You should get a -1 for the name. - It's basically a vector without the resizing capabilities. With the added antifeature of streaming the object representation. - It's completely off topic.
Yes, there are small game companies in Europe that will hire if you can code. The salary is basically 'for food', but the experience worth it. He'll probably have to go to London. And if there is no degree in computer science, there may be at least some theoretical questions on the interview.
Yes. But it would be quite hard to do the same in windows - a lot of code - mark all memory copy-on-write do new thread do something exit thread remove copy on write... and now surprise! you already was in copy-on-write state - so you have bug now. I can implement with interactive fork - incremental scenarios: do something fork do more fork, try some code, did not like - exit fork, try some other code did not like - exit do code that is ok fork try some newer code ..... and e.t.c - it is much harder to do with threads! fork again 
Could be better if it took a reference to the weak_ptr on the first look up and assigned to it instead of to the map directly. Single lookup ftw.
I use exceptions when they make sense. To signal a situation, that on average propagates up at least 2-3 layers and that typically does not terminate the program as a whole. If you have the former, use error codes. If you have the latter just std::terminate directly. Most of these are complex algorithms running on a can-fail input or output. The in/output that fails is an exceptional but possible case - file with error input, short read on a socket - and in that case the entire algorithm output is useless, so I just want the least intrusive way to quickly exit the algorithm and throw away all output, from any point that it may read. So this applies to all file parsing, writing, socket reading and writing, and RPC mechanisms. And sometimes other algorithms too that can find a logical error at their bottom, to quickly abort the algorithm. Other than that, you shouldn't need exceptions. Don't bother using exceptions for fatal errors (because they're fatal anyway) and don't use them for expectable error cases (because then error codes are much cleaner). In a kernel you should expect errors in any direction. That's why exceptions don't make sense in a kernel.
According to the standard, plain `new` must either succeed or throw `std::bad_alloc`. If the caller wants it to potentially return `nullptr` on failure rather than throwing, they must call it with an additional argument `std::nothrow`. More practically speaking, if your low-level memory allocation fails, there is pretty much nothing reasonable most user-space applications can do besides give up. Unless you have some cache that you can immediately `munmap` or a process that you can just `exit`, the world has basically ended. Even worse, on most Linux systems, the kernel is configured to go way past the point where there's no more actually memory available, and overcommit virtual address space relative to memory. By the time some access fails to fault in a new page, the kernel has to arbitrarily kill something instead - the dreaded "out of memory killer" (OOM).
You can use CMake and then use VS, Xcode, etc.
&gt; reading about the need of a degree has made me just feel like I'm going to be really upset when I can't get a position Have you considered getting a degree? It's totally possible to get a junior position without one, but it's much easier with one (not to mention the value of what you'll learn). I was in my early 30s when I decided to switch careers (I was a banquet manager) and I opted to go back to school and get a degree (and am now a software engineer at a pretty big name in tech) so you shouldn't feel at 24 that you're too old for college. If cost is the bigger concern rather than time or age have you checked out any coding bootcamps? They're usually focused on web development so probably wouldn't lead to a gaming job initially but without a degree you're probably more likely to get the kind of job you want with a few years of actual/professional experience (even if it's not in games). You also may want to research what it's like working in the gaming industry. I'm an avid gamer so it's obviously tempting to want to work on games for a living but everything I've heard has been bad - long hours, bad pay, not treated as well (in comparison to working as a dev at software/tech company). Lastly, check out [Hacker Rank](https://www.hackerrank.com/), some of the companies will give you at least an initial phone screen (regardless of your background) if you solve one of their programming puzzles.
I embrace exceptions, but only for fairly serious errors. I think they combine particularly well with RAII...
VS Community Edition is free. Read the EULA, but basically only enterprises need to pay for VS because they can't use Community.
yep, for instance a singleton, but the pointing is going to be via a form of global variable (such as a static member).
For better and worse typically the software industry does not rely too much on credentials. Build a strong portfolio in GitHub, contribute to other open source projects, read as many good CS books as you can (SICP, Code Complete, The Pragmatic Programmer, some Tannenbaum) and you will be competitive with most CS grads. You seem to have passion for the field and that really is the most important thing. The rest is, unsurprisingly, discipline and hard work. Commit and you will be able to do anything you want.
They even acknowledge it in the style guide itself that it's mostly for legacy code reasons. Didn't know that they even ban `noexcept` which can give open up some optimizations possibilities.
It is **forbidden** to replace plain new with a null-returning version. People do it anyways, but they're not conforming to the Standard. (nothrow-new obviously returns null, but you can see that at compile time.)
http://sciter.com - embedded HTML/CSS UI engine. Designed by C++ programmers for C/C++ programmers (though used also in Go, Rust, Delphi and Python). Has simple plain C and C++ API (20-30 essential functions). The whole UI is made of uniform "DOM lego bricks" - defined by single API class sciter::dom::element. "Good-looking user interface" is of course subjective. Check screenshots on frontpage for UI examples if any of them are good looking. Essentially: Sciter provides declarative way of defining UI as a collection of markup, style, svg, png and optionally script resources that are embedded into C/C++ as resources / byte[] literals. Script-behind-UI could be used as a "configuring glue" connecting one native function or event with others. GUI as a rule uses quite complex and unknown upfront ownership graph thus embeddeded script engine uses GC. Sciter C++ API is quite simple: one and essential sciter::dom::element class to communicate with UI and sciter::dom::event_handler that allows to receive DOM events and expose native functions to UI. The Sciter and technologies behind it are in production since 2006 when Norton Antivirus and other their products started using it. I am an author of the Sciter so you can ask questions here. Update: Sciter introductory article on CodeProject: http://www.codeproject.com/Articles/859098/Sciter-multiplatform-embeddable-HTML-CSS-scripting
Was it always that way? I've seen old C++98 code check whether it was 0.
Immediate mode in GUI makes sense in quite limited and simple cases. Most of algorithms in UI are O(N) complex - UI layout, rendering, etc. It is simply too expensive to do that with 60 FPS rate. As an example: to render a path you need to tesselate it first - break it to the set of triangles for GPU to render. It absolutely makes no sense to do tesselation on each frame - waste of resources. AFAIK Unity3D, that started with something similar to imGui, is working on alternatives. Truth, as usual, is in between: you need a system that allows you to use both approaches: retained/cached rendering tree with an option to use immediate mode drawing as in some cases it is more effective than alternatives. 
Its not. QtQuick uses a scenegraph. http://doc.qt.io/qt-5/qtquick-visualcanvas-scenegraph.html. And to add to the answer, the main reason why I like QtQuick is because my views are totally decoupled from my data. Actually, most views are purely declarative QML.
I'd say that scenegraph is an implementation detail. You never touch it unless you create a new widget type in C++.
Paging /u/STL :)
Hard to tell precise numbers but it is definitely faster. In some cases 10 times or so. Sciter is a single dll of 3-4 mb in size without external dependencies (yet it can be linked statically). Loading of single dll is faster than to load full Chromium infrastructure. Yet, on Windows for example, Sciter uses Direct2D - hardware accelerated graphics that is really fast. Especially with modern 4K monitors that have 9 times more pixels than ordinary 96 ppi monitors. Chromium uses Skia that does mostly CPU rasterization/rendering. Sciter from the very beginning was designed as an embeddable engine. That means when it needs for example some resource from native side it simply calls supplied (by the host application) callback function directly. In Chromium case UI is run in separate sandbox *process* so marshalling through process/thread boundaries is required - that's quite slow as you can imagine. And there are other features that simply not available in Chromium but are needed for modern UI. Like ability to render DOM elements in popup windows: http://terrainformatica.com/w3/sciter-tooltip.png Just download Sciter SDK and run /bin/sciter.exe ( source of this exe are in SDK ). Makes sense to load in it samples from /samples/ folder ti get an idea of its speed.
Yup. And even for relatively complex widgets, using QPainter via QQuickPaintedItem is impressively effective - alot of operations are translated to gl draw calls automagically. I've implemented some relatvely complex timeline displays without ever bothering with the scenegraph.
Crazy, seeing that C++ 11/14 brought much joy to writing C++. It pretty much killed my having to build these horrible bastard iterators filled with begins and ends. 
I really wish there was a better way to handle out-of-memory errors. My current project at work uses a memory pool that occasionally runs out of entries. We could override new/delete and return NULL if that happens but then the constructor would still be called with a null 'this' pointer. I believe nothrow will still try to call the constructor. Instead we use the memory pooler, then do placement new with that. It works but it's ugly IMO.
This looks really promising, thank you, I'm gonna go through it tonight
Yes, even in 98. But evil was rampant back then.
Fair enough. I don't think we have a bug for this, I'll file one when I get into work on Monday. Easy enough fix for the unique containers, but I'll want to think about making multi smarter.
Go for it. You can do it.
- Why the fuck is `ptr` public? - What the hell is the point of that `makefanzy` member function and the in_use flag? `ptr` is already nullable. - Copy constructor takes non-const reference - No copy/move assignment operators. - Move constructor makes a fucking copy. - Raw memory dumps still aren't portable. - It's still off topic in this thread.
&gt; Of course, in practice, you often don't get to receive the bad_alloc exception due to overcommit, Yep, so even if you could handle OOM, you can't, because kernel says fuck you. Honestly, this is one of the most aggravating things about coding for Linux -- even if I know I can handle a bad_alloc, I can't anyway.
&gt; The main reason to not use exceptions in a library is that your library can be used in projects that require no exceptions to be thrown. Once you add exceptions it's a one way street. This is the same argument for/against `const` ‚Äì IMO it is not very persuasive. &gt; Any project that uses the standard library uses exceptions as far as I know. Any part of the standard library that allocates (esp. containers, excepting `std::array`), for sure; but most algorithms and utilities can be used without concern.
Besides some bridge code, not really. So 1/2 a wrapper.
Looks very interesting, looking forward for next posts.
&gt; There's new(std::nothrow) but if I recall correctly, at least in MSVC, it's implemented by wrapping a try/catch block anyway so it's like the worst of both worlds. Sadly this is still the case, as of VC++ 2015 Update 3. :-[
Interesting series of blog articles you're starting here. You seem to be using VS and Clang on OSX - have you thought of looking at some other STL implementations? GCC's and Dinkumware are the two other main ones that spring to mind.
Since you are collecting links, you might want to have a look at the [Rust hash-map](https://doc.rust-lang.org/std/collections/struct.HashMap.html) which itself references [Robin Hood hash: backward shift deletion](http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/). I just implemented a hash-map with Robin Hood hashing and it's relatively simple. It's open-addressing scheme, of course, which presents some challenges, some of which (notably complexity guarantees/iteration) might prove insurmountable... ... but it has some sweet properties: - it is actually relatively simple - unless Cuckoo hashing, there is no "wall", even with collisions: you can completely fill up the buckets up to a 1.0 load factor - the "buckets" are contiguous, and implementing forward iteration on them is thus simple 
You have to measure to be sure. The overhead of zero cost exceptions when you're not throwing should be zero, which is less than the overhead of checking error codes. But you have to measure to be sure. As for bad_alloc, you're generally looking for a clean way to shut down after that. Older methods involved pre-loading a dialog box for the error at startup. These days, flush your buffered files to disk and get out cleanly. Hopefully with a good log message.
Hum... might be a bit complicated to fix in the case of `multimap`/`multiset`: for `unordered_multimap` the standard only mandates forward iteration, so finding the end of the bucket may indeed require a second search through the bucket and depending on how full it is (collisions and all that) this may be slightly costly.
Interestingly, as mentioned in the OP, V8 does not use exceptions. This means V8 does not consistently handle memory allocation failure and can crash the entire process if memory is not available. I wonder if ChakraCore is more robust in out-of-memory situations.
I do have a couple of installs of GCC (somewhat) handy. Mostly I'm just testing with what I have to hand immediately, which is VS, Clang 3.6 on Linux, and Xcode on a Mac.
POCO uses exceptions. A lot. It's very java-like in its design, but it does make a pretty great foundation for higher level c++ programming.
C++17 demo put together by committee member Thomas K√∂ppe // Desired semantics of f: If there is currently no item 'id', install // 'foo' as item 'id'. Otherwise, put 'foo' on the standby list for later. //------------------------------------------------ // Before C++17: 7 lines + 4 pitfalls // void f(string id, unique_ptr&lt;Foo&gt; foo) { auto it = items.find(id); if (it == items.end()) { auto p = items.emplace(move(id), move(foo)); p.first-&gt;second-&gt;launch(); } else { standby.push_back(move(foo)); standby.back()-&gt;wait_for_notification(); } // Notes: // * Variable 'id' can no longer be used (moved-from); or... // * ...would need to pass by 'const string&amp; id' and force copying. // * Map lookup performed twice. Ordered map could use lower_bound + // hint, but unordered map cannot. // * (Cannot emplace unconditionally, because it might destroy *foo.) } //------------------------------------------------ // With C++17: 4 lines + none of those pitfalls // void f(string_view id, unique_ptr&lt;Foo&gt; foo) { if (auto [pos, inserted] = items.try_emplace(id, move(foo)); inserted){ pos-&gt;second-&gt;launch(); } else { standby.emplace_back(move(foo))-&gt;wait_for_notification(); } } 
[cinder](http://libcinder.org) uses them in a pretty subtle way. Most classes will have a few derived `Exception` types like these from their [OpenGL FBO wrapper](https://github.com/cinder/Cinder/blob/master/include/cinder/gl/Fbo.h#L347)
 // Create a window auto win = kit::Window::create("Foo", kit::Window::Windowed, glm::uvec2(1280, 720)); // Create our text auto txt = kit::Text::create(kit::Font::getSystemFont(), 14.0f, L"Hello, world!"); // Place our text in the exact middle of the screen txt-&gt;setPosition(glm::vec2(1280.0f / 2.0f, 720.0f / 2.0f)); txt-&gt;setAlignment(kit::Text::Centered, kit::Text::Bottom); 1. Why the need for smart pointers+factories? As a comparison point, SFML do not need smart pointers and factories and let the user decide how is allocated the object representing, for example, a window (even if other kinds of allocations happen inside it). To me it looks like a design flaw. 2. The explicit use of glm namespace might be a problem in the long-term if you end up changing library. I would have either made the code agnostic to the math library (that you are currently imposing - not everybody use glm) OR made it a detail of your own namespace (like `kit::math{ using glm::vec3; /*...*/ }` ) so that you can potentially change it later (but still impose one implementation at least to be used with your library). 3. You might want to switch to a cross-platform (meta)build system in the near future to help with adoption, like Premake or CMake (CMake is said to be more popular but is truly problematic when you manage complex projects, in my own opinon). Other than these points, the examples looks fine. I am interested in seeing actual documentation.
Post number 3 in this blog series is done: http://www.forwardscattering.org/post/39 I'll just put the link here to not spam this subreddit too much. 
spam away, it's quite interesting read :)
Do you use std::string ? Did you know that if it can't resize, it signals error by throwing an std::exception ?
This is really important. Only use and pass shared_ptr if everyone involved actually owns the instance. For non-owning calls (which is generally 95% of all cases), just pass a regular pointer/reference. If the original owner really might go out of scope before whoever he passes it to does, then you have true shared ownership and it makes sense to use shared_ptr.
[Another](https://www.reddit.com/r/cpp/comments/4wh5jd/an_apparent_performance_bug_with_some_stdmap_and/d678tvk) branch prediction benchmark? == sequential keys == (updated) std::map count: 341675 ticks std::map find: 177075 ticks std::unordered_map count: 59937 ticks std::unordered_map find: 28669 ticks == unpredictable keys == std::map count: 765574 ticks std::map find: 509550 ticks std::unordered_map count: 67593 ticks std::unordered_map find: 43466 ticks x64, VS2015, Win 8.1, i5-2400
At work we build on at least five very different platforms. Header only libraries are a blessing. 
The title is a bit misleading -- the bug is specific to Microsoft's implementation of the standard library. The `libstdc++` implementation (default in Linux, your local implementation can be found at `/usr/include/c++/${VERSION}/`) has looked like the proposed fix as far back as 4.8 (probably longer, but I don't have anything older on my machine): size_type count(const key_type&amp; __x) const { return _M_t.find(__x) == _M_t.end() ? 0 : 1; } For the `multimap`, `equal_range` and `distance` are still used, but `equal_range` does not perform two separate tree searches. The `unordered_map` and `unordered_multimap` share the same implementation (which does not use `equal_range`), which means you get an extra comparison test, even if the policy is one value per key. I'm not sure why there isn't an `if (_M_t.__unique_keys)` test in there. Might also be worth noting the _set_ associative containers (`set`, `multiset`, `unordered_set` and `unordered_multiset`) have the same performance characteristics as their _map_ counterparts, as they share implementations (or were copy-pasted, in the case of `libstdc++`'s ordered associative containers).
&gt; biggest issue is dependencies That's exactly why you _should_ use cmake and not a manual .sln :-) Your project doesn't look overly large or complex to be any hassle to generate a cmake file for it. But anyway, to each his own.
Do clang or gcc do it differently?
Not to mention inconvenient. If this were a web app, I'd be all over it; as it is, I can't access it on mobile, and by the time I get to a desktop I'll have likely forgotten about it.
CCP has a UK office? The Eve CCP?
No, see [new_opnt.cc](https://gcc.gnu.org/viewcvs/gcc/trunk/libstdc++-v3/libsupc++/new_opnt.cc?view=markup) for the implementation.
Boost/non-boost ASIO. It, or something similar to it, will be in the standard eventually. Links: [boost.asio](http://www.boost.org/doc/libs/1_55_0/doc/html/boost_asio.html) [asio](http://think-async.com/) Edit: ASIO is not easy. :(
Yea, my bad. Edited my comment.
In general, I will perform optimizations that avoid unnecessary allocations/deallocations, tree traversals, predicate invocations, etc. If a potential optimization isn't clearly a win for some scenarios while leaving the rest unaffected, then I won't do it unless there's clear profiling evidence. The insertion thing is a slam dunk because metaprogramming can recognize when we don't need to allocate a node.
&gt; Am I Writing C++ Right? &gt; uses tabs no
Yep. It's in Newcastle. When I was there it was a programming house working on DUST514.
&gt;&gt;Am I Writing C++ Right? &gt;no Fixxed.
Additionally his account was created 12 hours ago.
I have built the library at our company that reimplements nodejs in C++ using similar concept of "modules". Decently sized projects build in seconds using this approach and everything is very clean. Back in the days I have been inspired by [JUCE](www.juce.com) framework that uses this approach extensively.
So convert ````file_extension```` to an integral type and do a switch on it? The string compare is case insensitive, I wouldn't be able to keep that functionality if I convert the string to an integral type for comparing.
&gt; Making the variable static also makes the variable a global variables and this automatically makes the class thread unsafe since access to this global variable is not guarded against simultaneous access. If this is ok or not depends on how the class is used. Codebase is single threaded, no plans for multithreading. &gt; This function looks suspicious,it is declared as "static" meaning it cant access local variables of the class but it is accessing "m_banners" which looks like a local variable of the class. This is possible because "m_banners" is not a local variable as i mention above. This variable looking like a local variable when its a global variable is not a good thing. ````m_banners```` is a private static vector that I mentioned earlier.
&gt; There's no reason you couldn't use emplace_back there. Why do you think you can't? IIRC, I was getting an error when I tried using ````emplace_back````. &gt; It's six and two threes, but people seem to prefer singleton classes like AdBannerComponent over statics, it's easier to expand to having two later. I don't even understand this sentence. 
Instead of statics, have another class which has the static variables/functions in, accessed through a single global instance. This seems to be what AdBannerComponent was.
This might be a bit off-topic but I never understood the appeal to use HTML/CSS for UIs. It just seems like a horrible idea to me, like trying to design a space shuttle in Microsoft Word. HTML is a document markup language horribly abused to build web applications for the sole reason that nothing else runs in the browser. Things as fundamental to UI design as CSS grid layout is still just a working draft from W3C, stuff that should be trivial to do like centering is so awkward that there are [whole websites](http://howtocenterincss.com/) dedicated to it and it does not support system themes so the UI will never look native on any target platform. It just seems like completely wrong tool for the job yet people insist on building desktop applications with it. What am I missing? What makes Sciter (or Electron) a better choice than Qt/QtQuick for example? Genuinely curious and trying to be open-minded (despite rant-ish tone of this comment).
I wonder how std::optional will change STL's api once it will be part of the standard... 
Modern OS's like Linux never fail with malloc, the system allows overcommiting, figuring that in real world scenarios the app wont use everything it allocated. Checking for malloc errors is now pointless.
No you're right of course, it was just an auto correct from Swype (where those two words are similar). Corrected, thank you.
&gt; but this should read "if you're not using CPython ..." I disagree! We are talking about **Python** - *CPython* is an implementation. From the code you can't infer the runtime, so better not *optimize* your code in this way. Imho that is unpythonic and should be corrected even within an example. So I wouldn't call it nitpicking... By the way: I like your comment overall! :-) 
Gotcha, just wanted to make sure your point was clear!
There's nothing wrong with using tabs dude. Opening curcly braces on their own lines on the other hand...
You can use libc++ on Linux.
At least is a good sample to test my advanced thread detection tool... sadly the stupid Jar contains 5k+ files that must be scanned one by one with a max of 5 per min... This is going to take a while. I should have used my lab to download it /sadface. EDIT: The file looks "ok", there is no weird thing/logic in the .class files, sadly the jar/zip is soo big our initial threshold of 10MB rejects a direct simulation. /doge
That's not so bad, but using emacs to edit the source code...
This function looks completely wrong to me. For one, [this line](https://github.com/pvpgn/pvpgn-server/blob/master/src/bnetd/adbanner.cpp#L159) is superfluous - the preceding lines are already a boolean expression that will return true or false. More importantly however: Unless I'm missing something, you are creating a vector of copies of ad banners (which in itself seems wasteful), but then you completely ignore that and select a random banner from the original vector after all. Given the usage in this function, I would also consider another data structure that would fit the use case better, e.g., an unordered_map&lt;AdBannerSelector, vector&lt;AdBanner&gt;&gt;
Every time I had a `static something` where `something` was not a constant I ended up having problems and replacing it with dependency injection later instead
About 1), I do not see any case where this is useful, here is why: most of the management of the resources that actually need a factory or some special acquisition/release code is already hidden in the constructor and destructor of these types. You also preven the user to use (for example) the stack, which in high performance cases can be a huge issue. Your types already wrap the work, there is no need for (most of) these factories.
You can't have string as switch argument. There are ways to work around that in case you are working on perfomance-sensitive parts. That's not the case here so I would pass that part on code review with comment "Why did you choose if-else-if instead of std::map?"
That's looks pretty good code, you can be proud of it! Thus said, you should check problems found by /u/LordAn I can provide some input too: * It would be better to follow advice of /u/TheThiefMaster and move static members in a separate singleton class. * Even if you don't feel like doing it you should remove `static std::vector&lt;AdBanner&gt; m_banners;` and create `m_banners` as static variable in your CPP file. This will clean up interface slighlty. * I would rewrite https://github.com/pvpgn/pvpgn-server/blob/master/src/bnetd/adbanner.cpp#L103 as std::map lookup * Change `empty` method name to `is_empty`. I personally think it was a big mistake of STL architects to name it so (explanation from static analyzer devs: http://www.viva64.com/en/b/0391/#ID0EEITO ) * What is ternary operator doing here: https://github.com/pvpgn/pvpgn-server/blob/master/src/bnetd/adbanner.cpp#L189 ? It will work just as well without it. * In AdBanner::find ( https://github.com/pvpgn/pvpgn-server/blob/master/src/bnetd/adbanner.cpp#L178 ) you already have an iterator named `result` and still call `m_banners.at()`. Why? Once again, good work!
All that sounds really great :) Do you have any plans for WebSocket or HTTP Session Management ?
I just usually write my own "getter" function that returns a pointer to the mapped_type (allowing a simple if not zero); the std::pair&lt;bool, Iterator&gt; always feels like bad form, don't really know about about std::optional&lt;Iterator&gt; and how it would work for something so simple.
The preprocessor definitely shouldn't care about file extensions. I've never seen it actually cause issues.