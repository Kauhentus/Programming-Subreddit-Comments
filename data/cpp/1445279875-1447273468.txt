&gt; You should not even expect that a client built with one compiler version works with another version of the same compiler. &gt; &gt; The correct thing to do is to build your library for the client compiler. Can you explain how this is the correct thing given that previous assertion? 
If you know about `std::ref()`, you're already not a beginner anymore. You're quite advanced. Likewise, if somebody is not already **very** good at C++, he would not have a need to even know about `std::ref()`. A beginner doesn't even need to know about rvalues.
Isn't that kind of the point of the talk, to skip those concepts and start with the simpler stuff, with which you can make a perfectly good program. What situation do you find yourself in that you absolutely need std::ref() and can't do without?
I meant: Use the same compiler for both builds. I am exaggerating to press a point, which is that **absolutely nothing** gets binary compatibility in C++ language, except using the same compiler (practice is more lax than that, but still).
You could use the diceware word list. There are some non-words included, but I believe they're at the end and can be easily excluded.
&gt; If you know about std::ref(), you're already not a beginner anymore. You're quite advanced. FYI, this topic gets covered in C++ Primer, along with many other concepts that I found relatively hard to grasp (at first), and I've written a lot of code over the years. Though I do follow what you're saying about std::ref() being (somewhat) advanced, since few newbie devs will be using it. Which makes me wonder, do most C++ beginner books teach this?
std::bind takes args by value as well.
I had no idea how much C++ I don't know. 
The reason Clang exists boils down to Gcc switching to GPL 3, Apple hating that license with a passion and them throwing their weight behind an implementation with a less restrictive license. Gcc and Clang are pretty much the same from an end user perspective. Sometimes one produces better code, sometimes the other. Sometimes one compiles faster, sometimes the other. Each supports some minor subsection of the C++ standards that the other does not. The main difference from a user point of view is that Clang has more user friendly error messages. 
This is a very complicated question. For a comparison, you can see http://clang.llvm.org/comparison.html although it's fairly old. It does give an indication of many of the reasons the project was started. GCC switching to GPLv3 is a major reason (same with libc++ vs libstdc++). As for popularity, the reason is: 1. Modern codebase written in C++ 2. Modular compiler separates frontend from codegen very cleanly. 3. Usable a standalone library - can be integrated into any other tool 4. Performance is competitive with GCC (LTO is currently the only place GCC is leading significantly at this point I believe) At this point, there's also a lot of momentum since it's the default compiler for iOS &amp; OSX development, &amp; really the only one unless you're building GCC yourself. Additionally, Google is investing heavily in it as well due to the modular architecture, meaning they can build tools to process C/C++ code on an automated large scale. GCC has been making strides in making itself competitive (switching to C++, trying to make itself more modular, etc). GCC currently is more portable than Clang (Windows support being the major hole currently in clang) &amp; more popular in the Linux world. Clang is popular on BSD. GCC or clang are both great for C++ development as they are conforming C++14 implementations. Visual Studio is a little bit lagging but it's catching up. I would choose the default toolchain for the platform you are on. On Linux, GCC. On OSX (&amp; most/all BSD variants) clang. On Windows, Visual Studio.
The argument is don't teach C first, and then teach "C with Classes" as it confuses students more than it helps. Go straight to Modern C++. Don't teach printf, pointers, naked arrays, indexed for loops, new/delete, etc in a beginner course. 
Sure, I would as well, however I do see why you would opt to use a function rather than write the same lambda 20 times...
Yes, now if you start from C you need to teach all the way through the C++ evolution to not to loose the link (to be able to mentally translate any C++ idiom into the C equivalent).
That's the option I'm actually trying to avoid, to not clutter things up to much. Like I said, 'I would probably create a pseudo-include files containing an ifdef switch', so it will be ```#include &lt;mstdio.h&gt;``` which contains the example you provided. From what I can tell in the proposal, including a proxy header with an import statement inside will still provide the benefits of the module system.
I don't know the book, but amazon says it covers C++11, which introduced lambdas. bind was introduced before lambdas were available. Stephan Lavevej is the maintainer of Microsoft's STL, and posts in this forum under "STL". He goes through the disadvantages of bind in his talk.
How do you mean?
Yeah, that's what I found curious, the book covers lambdas *then* it covers bind(), specifically as an alternative to lambdas, with no mention that bind() should be avoided.
Just that you have to worry about object lifetimes when passing references to threads.
It is fairly recent advice :-)
I think particular questions like this are better suited for [r/cpp_questions](https://www.reddit.com/r/cpp_questions) Generally to link dll in a nice way you need to have `.lib` file which was built with it (and usually distributed in packages for developers), then you reference this `.lib` in your project the same way you do with static libs, then if you have headers you can use functions from dll fine. If you don't have headers and/or `.lib` file you will have to rely on runtime linking through functions like `LoadLibrary` and `GetProcAddress`. But you would still have to know the function signatures from somewhere.
Not sure if it's helpful but [Phoronix](http://www.phoronix.com/scan.php?page=home) regularly publishes benchmark tests between GCC and LLVM/Clang for various processors. The last one is from [September 2015](http://www.phoronix.com/scan.php?page=article&amp;item=gcc-clang-skl), I think. Some past benchmarks, for reference: [August 2015](https://www.phoronix.com/scan.php?page=article&amp;item=clang-37-gcc52) [January 2015](http://www.phoronix.com/scan.php?page=article&amp;item=clang-gcc-broadwell) [April 2014](http://www.phoronix.com/scan.php?page=article&amp;item=gcc49_compiler_llvm35) AFAIK none of the tests use LTO though.
Don't spend too much time reading through guidelines, without sufficient knowledge you won't even know many of the terms used (hell even I don't know everything they're talking about) and you won't understand why they're suggesting what they are and in what situations their recommendations are appropriate. NASA guidelines are way overkill for anything you'll be writing at this stage and Google's are certainly not the norm where I work. For example they ignore the use of #pragma which has been supported in all common compilers for the last 5 years and instead recommend wrapping everything in #ifndef checks. I would instead have a look at the gang of four: http://www.blackwasp.co.uk/gofpatterns.aspx practice some of the patterns there, if you can implement an Abstract Factory in a library with concrete implementations contained within separate plugin dlls which are loaded by an application through a function within the core library then you're well on your way to understanding 90% of what's used in every day programming.
Cool thanks for the referall! I have made the .dll and it ran without errors on build so I should be able to find the .lib file in the same folder? I have header files for the dll and the solution I am trying to implement it in. I just could find the reference method in visual studio. As all the tutorials I have seen/read are over 3 years old.
I will give loadlibrary a go.
I haven't read the primer. But a lot of books are didactically quite awful. For example, I bought Stroustrup's _A tour of modern C++_ for a friend to help him get into modern C++, and I didn't like the book at all, it doesn't teach in an understandable way. I was really surprised by this, as Stroustrup is an extremely brilliant speaker and his talks very well thought-out and understandable.
I chose C++ Primer because all the reviews were pointing to the book as a good start for someone who isn't new to development. I've found the book pretty good so far, but certain parts have been worded in such a way that I had to re-read paragraphs several times before I could make sense of what was being said. In several sections the author explains how to do something, then tells the reader not to do it, since it's bad form... he didn't do that for bind(). :(
There needs to be a book like "Accelerated C++", but for C++14.
Listen to what she Sed.
I think remote Linux debugging with the Visual Studio debugger is a thing that's going to happen soon. Not to mention that LLDB should make its way into Windows the same way Clang is.
Also, given this is c++, consider using the new[ random number functionality from the standard](http://en.cppreference.com/w/cpp/numeric/random)
Right but my point is that knowing that knowing the alignment size may give optimization opportunities to the underlying allocator. If you know (via template parameter) that the allocation is always a (small) cache line multiple you can design much more efficient algorithms then assuming it could be as small as 8 bytes. In general we want to be able to pass additional information to the type of the allocator to make the most efficient code as the alignment restrictions could change the class/structure layout. Merely knowing the alignment at runtime is not enough for high performance code, which is half the reason for using allocators. (As a trivial example with a set of allocators depending on size there is no reason to have allocators whose maximum size is less then minimum alignment). 
If /fp:integer shows up in the compiler, I know who to blame. Floating point math does at least have rounding and degrade gracefully at extremes. Integer/fixed math, which faster and easier to predict, tends to blow up when exceeding range instead. 
Nope, now you can just use a lambda that captures by reference.
I prefer not to have death by a thousand paper cuts while using the bafflingly bad visual studio UI.
Just a note: His description of the "counter example" is incorrect. The reason /fp:fast is closer to the actual result is a combination of random luck together with poor construction of the summation loop in the test program resulting in something similar to catastrophic cancellation (something which is generally very important when using floats and which is not discussed in the blog post).
Take a look at c++ primer 5th edition, it at least includes up to c++11. Barbara Moo is one of the authors, and was one of the authors of accelerated c++. Similar style, though slightly more in depth. 
Apple hating the license is one half of the story. The other half is that Stallman does not want GCC to export the full AST in a machine-readable format. People who tried to use gcc to build intelligent IDEs have gone the Clang way. Clang seems to be the future of C++ development, although, to the end-user it does not matter yet.
In most cases the lambda is a lot less syntax than `std::bind` + `std::ref`. Maybe not if you have really long typenames in your lambda parameters.
I guess this is a good time to throw in a thought that has been floating around my mind. What if clang compiles faster than gcc becaues gcc has a lot more/harder optimizations going on that have minimal performance difference. GCC has been around a long time so it has had a lot of time to create a expansive list of compilation optimizations whereas clang could target the lowest hanging fruit of optimizations that make the largest difference. No idea if this is the case and I have no idea about the actual optimizations on either of them. I've only heard that clang compiles faster but with neck and neck performance these days.
After creating hello world I dove into creating a window using #include &lt;window.h&gt; and because of my interest in openGL took a look at libraries for gaming like [SFML](http://www.sfml-dev.org/) I didn't do much at all in c++ really as I started getting curious in the size of my exe and ended up diving into that. I still would like to know how to create a tiny EXE like [1k Mandelbrot](http://www.humus.name/index.php?page=3D&amp;ID=85) but I don't program all to often.
&gt; std::bind I mean perhaps, I'm certainly not advocating for this use case all of the time, I'm just saying that I often find explicit functions much more readable. Lamdas seems better for very specific times, like find_if and things like that. I haven't yet started any threads with genuinely trivial things to do that I could fit into a lambda I'd be comfortable with. I mean it's not like the ones I wrote are that complex, but they're running in a different context and I think it's important to be able to look at them on their own.
Well it's worth keeping in mind that the language and the use of the language constantly evolve, so even if a book is regularly updated, it will always lack behind and not update some of the stuff. Conference and talks are there to help you stay up-to-date :-)
What is the current state of clang on windows? Its usable without greater hacks??
&gt; Clang seems to be the future of C++ development, although, to the end-user it does not matter yet. While the progress that clang has brought to the C++ world is quite valuable, there are many more compilers out there than just clang, gcc and VC++.
What's wrong with GPL 3?
Why doesn't stallman want to export the full AST in a machine-readable format? What's at stake?
Microsoft it self is now working on Clang for Windows. So Clang for Visual Studio 2015 could be available in November if everything work well. http://blogs.msdn.com/b/vcblog/archive/2015/05/01/bringing-clang-to-windows.aspx
I may be wrong, but from my limited understanding I think many companies' issues with GPL is that it is 'copyleft', meaning that if you want to release any work derived from some other work under the GPL 3 license you have to release your derivative under the same license. That means you can't have proprietary code based on code under GPL. While this is great for consumers, large tech firms like Apple want to reserve the right to keep anything they do hidden for competitive advantage.
This! Both compilers are good, but they both have subtle quirks and subtle non-correctness here and there.
Ah, makes sense. Thanks.
I am still waiting for a compiler implementing the techniques described in this paper: https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetimes%20I%20and%20II%20-%20v0.9.1.pdf
For a given source code position, `__LINE__` always expands to the same number regardless of the translation unit. `__COUNTER__` does not because the actual numer it expands to depends on how many times it's been used before in the TU (which can depend on previous `#include`s, potentially different in each TU).
For free you mean. Compiler vendors have been licensing EDG for years.
He doesn't want GCC used as a library in non-GPLv3 code.
Maybe that's part of it, but clang also compiles significantly faster than gcc (a similar margin IIRC) with optimizations off. 
I always prefer precise defaults to fast ones. Least astonishment and all that. You could move the switch to a more easily acessible place in the project configuration though.
You most likely want to use the hoard allocator, or one that uses the techniques that it developed. In regards to issues with loading dlls are you loading them during runtime using loadlibrary? If so then the issue you are probably running into would be something to do with Windows not setting up thread local storage as one expects in the loaded library. This response is based on assumptions so I could be really wrong.
Use VirtualAlloc to allocate a pool of memory as large as you like/need. Then you can implement your own allocator within that pool, or, for example, use Boost.Interprocess memory allocation algorithms, like http://www.boost.org/doc/libs/1_55_0/doc/html/interprocess/memory_algorithms.html#interprocess.memory_algorithms.simple_seq_fit Or just use managed shared memory from boost.interprocess. You'll get memory allocated from a pool that no other allocator knows about, and the underlying memory is obtained directly from the OS, so there should be no obstacles to it working.
&gt;You may get a compiler warning that not all code paths in sum2_cons return a value. The compiler just isn't smart enough to figure out what is going on. You can ignore the warning, or if that bugs you, put a return statement after the call to sum2_cons. it will never get there and doesn't hurt. But please put a comment or people will wonder 'how did he expect it to get to this point?'. If you leave off the return, it doesn't get optimised as a tail recursion, and in fact results in invalid code: http://goo.gl/dlO5Jb Note that the last instruction in sum2_cons is a "call", not a goto. When a return gets executed, it will return to the instruction after the call instruction... which is the start of main! sum2_cons should be a void function - the return value is not used or meaningful. If it's made void then there is an implicit final return which satisfies the tail-call optimiser: http://goo.gl/F7AJ2t (note that the compiler can now fully analyse the function and actually eliminates it entirely, main contains `mov eax, 5` instead of calling sum2 and both sum2 and sum2_cons contain an `imul` and no `call`s) Failing that, the correct way to represent a tail call in C that *does* return a result is to use: **return** sum2_cons(...); (http://goo.gl/CNy8CZ, again the function is now eliminated entirely) If you put a return after the sum2_cons recursive call, not only is it no longer tail-recursion, but it *does* actually reach that return. Your information there is just wrong. (http://goo.gl/xA944X, note no tail recursion optimisation has happened, sum2_cons contains `call sum2_cons`) 
These type of question belong better to /r/cpp_questions
How is fp:precise actually more precise? I understand that is more precise in the sense that it executes exactly (precisely) the code as written, but not that it will output a more accurate result. For example x*x*x*x involves 3 multiplicacions, (x*x)*(x*x) involves 2. Due to rounding error it would seem that the less operations the more accurate will be the result. I'm not really sure that this is true in general, and probably there are many counterexamples. But it would seem that fp:fasts should be actually more accurate than fp: precise in the general case. 
probably a repost to gain some views
&gt;You may get a compiler warning that not all code paths in sum2_cons return a value. The compiler just isn't smart enough to figure out what is going on. &gt;sum2_cons returns an int &gt;Its return value is unused which is why the author thought he didn't need to return a value at some point Stopped reading there. Because "*the compiler* isn't smart".
I haven't and that is a good tip. Right now I haven't defined an explicit dll entry point (mostly out of ignorance surrounding shared libraries). Can I just define an arbitrary cdecl function and make it my entry point in the linker or is there something more complicated?
&gt; most of the time you're hiring to fill a skill gap Maybe in a very small company; in even modestly-sized companies you're more likely to need headcount, not skills.
I wish Phoronix had an Android app.
What specifically scares apple about the GPLv3 (as they were relatively happy to include GPLv2 software in their OS, and still do) is likely that it requires they license any patents they own which are relevant for the software they release under the GPL to anyone who wants to use it (for the purposes of using the software). They are worried that someone will get access to one of their patents by claiming it's relevant to some GPL software they happen to have released.
EDG is not a full compiler like clang or GCC but a compiler frond end only. I think it is possible to create more complicated tools using clang that edg. Refactoring tools for example. REPL just like Cling and so on. 
It's precise floating point arithmetic: it gives the correct answer given the rules of floating point numbers. Conversely, 'fast' mode may not give the correct answer. 'Precise' mode isn't claiming to be more precise with respect to real number arithmetic.
Just out of curiosity: how old are you?
It's simple. fp:precise follows IEEE 754 exactly. fp:fast doesn't and thus is free to do any optimizations that may produce faster code but less accurate calculations (here 'less accurate' really just means differing from IEEE 754). eg. if you need to have the same calculations give the same results on different platforms, you need to use fp:precise.
Should have clarified. LTO is better in GCC than clang. Optimization in general in the Intel compilers has always been at the head of the pack &amp; MSVC tends to have very good PGO &amp; LTO too.
I think the answer is to have automation validate both at once. Even switching every week is going to have significant problems supporting both platforms.
I wasn't talking about C++ allocators. I think your best bet is to use managed shared memory from boost.interprocess.
http://llvm.org/builds/ The installer creates a full toolchain for clang, directly usable from VS and/or msbuild
You are pretty invested in this whole thing for an adult. 
So predictable. I'm guessing teenager then.
This just in: CppCon 2015: Michael Wong - "C++11/14/17 atomics and memory model: Before the story consumes you" https://www.youtube.com/watch?v=DS2m7T6NKZQ :-)
`std::ref()` is useful with more than just `std::bind()`. Often in cases where you could use a lambda with reference captures you can use `std::ref` without any lambda or any bind expression. For example: void worker(atomic&lt;int&gt; &amp;state) { ... } atomic&lt;int&gt; s; \ auto x = std::async(worker, std::ref(s)); vs. auto x = std::async([&amp;s] {worker(s);}); 
I'm not getting worked up, and I'm not bitching, I asked a simply question.
&gt; Are there any techniques that you have used to confront this problem? Change the design to not require so many dynamic memory allocations (e.g. pre-allocation and free-lists) or roll your own problem specific allocator. Doing this in a plug-in DLL is going to be harder, because you can't use neat helpers like Window's TLS/FLS callbacks.
Yeah that's undefined behavior and an absolute non-starter for any code I have review authority over. 
The answer is a qualified yes. Signed left-shift is undefined. Signed right-shift is implementation-defined (in practice, usually an arithmetic shift). Bitwise operations are all well-defined, but they may result in trap representations if you're not careful on certain (e.g. ones' complement) platforms.
Under the current standard, left shifts are well-defined if the left operand is not negative and the result "fits properly". Right shifts are also well-defined (vs. implementation-defined) for non-negative left operands.
For practical (rather than theoretical) purposes, it's a way to express a search *pattern* in a string instead of just text. For example, instead of only being able to search for "abc" in a sentence, you could search for *an f or a g, then one or more vowels, then a digit (0-9), then y*, which can be expressed by the regex `(f|g)[aeiou]+\dy`. Once you have a regex describing the pattern, there are lots of tools you can use to make use of that. For example, you might have a function available to check whether that pattern is in a string, or to find where it is in the string, or to mark parts of the pattern where you want the matching text (like if you want the actual matched sequence of vowels in the above), or to replace parts of the text with something else (e.g., replacing all yyyy-mm-dd with mm/dd/yyyy).
Thanks for the answer. Sounds complicated.
&gt; I also want to point out Clang's great error messages. Clang produces much more clear error messages compared to GCC They are at least on par: https://gcc.gnu.org/wiki/ClangDiagnosticsComparison
Hi, Hyperscan lead here. The source code is out there already; we are working on releasing some performance data but we have very strong rules about how to make performance claims so we can't just put up off-the-cuff numbers. For a pattern which could be handled as a straight-forward A-C automaton, we are typically much faster, although corner cases exist. Don't take our word for it - download it and see! Regex is sufficiently complicated (with so many different workloads - 1 vs 10,000 patterns? Simple patterns vs complex patterns? Large writes vs small writes?...) that we usually fall back on the "why don't you try your own use case and see if we're fast or not" approach.
I'll take a look at the video thanks. I'm not sure there are many places for arena allocators and using those techniques isn't going to solve the fundamental concurrency issues I'm facing. The places I'm using memory allocations are specifically because the sizes of the allocations might be wildly different. For the extra allocators my concern is that I won't be able to get them to work in my shared library. I would love to use tcmalloc if I was in control of the whole program, but so far I haven't been able to link anything together and still have the dll load.
&gt; For a pattern which could be handled as a straight-forward A-C automaton, we are typically much faster Now I'm definitely gonna build a test harness and give this a bash. We'd love to expand the types of operators available in our parsing system; At the moment we are using AC with a few cases/operators added on-top of it, for many-to-many matching. Regex would simplify a lot of operations. I do notice one slight issue in our test case: In your perf docs you indicate that `start of match` info is rather expensive; how expensive are we talking relative wise (in non-streaming mode)? Also, are there any plans to support fuzzy matching?
Maybe take a look at [*Scalable Lock-free Dynamic Memory Allocation*](https://www.research.ibm.com/people/m/michael/pldi-2004.pdf) (PDF). I've had good experiences with a similar design, but it's somewhat hard to implement correctly.
You deserve a chocolate. Next time he should make people come to a mic to ask questions and someone next to it can hand out the sweets.
And you can have fun doing it with [Regex Crosswords](https://regexcrossword.com/)! Disclaimer: I found out about these after being familiar with the syntax. I don't know how easy it would be to learn the basics through these, but it doesn't use too many features and it has a small how to play section.
Sometimes you want to have a value type that nevertheless contains a reference (e.g.,to some "context"). You cannot write `operator=` in this case. 
owner&lt;T&gt; is exactly an alias of T. Not an actually smart pointer. its sole purpose is to actually "flag" the pointer, for tools to track the ownership. In most cases you will indeed want to use an unique_ptr. owner&lt;T&gt; still ~~behaves like~~ is a naked pointer
The V2 version I found [here](https://isocpp.org/files/papers/n3740.pdf) contains some interesting alternative names for observer_ptr (or as it's called in that document, exempt_ptr). It's not relevant anymore but at least it's still good for a laugh or two.
Thanks for the open source. I'm really looking forward to the write-up on how you've approached the implementation. Are you able to divulge any hints ahead of the planned blog posts? In particular I am interested in what strategy you have taken for multiple regex matching, and whether you evaluated any alternatives.
&gt;I would choose the default toolchain for the platform you are on. On Linux, GCC. On OSX (&amp; most/all BSD variants) clang. On Windows, Visual Studio. I tend to disagree with this, I'm writing my project on Linux with GCC and Clang and it works on windows with MingW (MSYS2) with almost no changes. However, trying to port it to Visual Studio gave me a lot of problems with dynamic libraries, such as not being able to access static memory allocated in a library from the host application. But both GCC and Clang think this is no problem. I solved that by statically compiling it, but then I got in a threading problem and from there I simply said to myself, "Fuck it, this is not worth it" and ditched the MS compiler. I'm sure it'll work out for other people with more programmers on their team, but for me personally, I'd rather go with GCC on Windows, especially because it's so little work to port it. However, that said, I was surprised I got it compiling so fast, considering I'm writing my project in C++14 and none of the problems I had (during compile time) were related to me using C++14, MS' compiler has come a long way.
You're so lazy, that history will never be deleted/freed. Maybe read up on Meyers Singleton.
I'm totally agree with you. Even didn't think in a way that I need to delete this variable after... I will edit my post, thank you) 
[complex](https://en.wikipedia.org/wiki/Gaussian_integer)
So basically it allows compilers to perform Rust style ownership tracking?
&gt; some are so hard we wind up not being able to support a pattern in SoM That is a little unfortunate =( However, I think most of our patterns are easily reducible to fixed length, "simple" patterns. The problem is the patterns we use aren't fixed set, we'd have to break a lot of stuff because a new pattern cannot support SoM. &gt; We do have a project for fuzzy matching underway right now, as it happens. This is something we are really interested in, even if it doesn't support full regex, but maybe a subset where you could fuzzily detect full words, prefixes, suffixes, prefix+suffix and the negotiation of such. Thanks for your work &amp; for releasing your code, it always helps both academics and small startups that can't afford the R&amp;D costs to make something feasible =)
Some time ago I wrote very similar thing myself. There was a complex data structure with `find` and `insert` methods. To make it look like an std container, the `find` method would return an iterator, and insert method `std::pair&lt;iterator, bool&gt;`. I could use a `const T*` as an iterator, but my data structure did not support iteration. To be on a safe side, I wanted a type like a pointer, but without arithmetic and modification. Coincidentally, I called my type `observer&lt;T&gt;`. P.S. Some time later I decided to simplify the code, and since I am the only user of that data structure, I decided that I can remember not to increments the iterator, so I changed the definition to template &lt;typename T&gt; using observer = const T* Edit: `insert`, not `find`, would return a `pair`
I use both. The major drawback of clang is that optimized binaries are, on average, slower than GCCs (just check any recent phoronix compiler benchmark). I almost never use GCC though since most of my time is spent writing code, and clang: - compiles way faster (refer to phoronix), - is more standard conforming and has better support for C++14 than GCC (so my code ends up being more portable and I spent less time filling compiler bugs), - has a lot of tools that boost my productivity: - clang-format: never think about indenting/formating your code again, - clang-tidy: never think about style guides/naming conventions/... again, - address + UB sanitizer (and thread sanitizer) catch a lot of subtle bugs (I wish memory sanitizer was easier to use), - code-completion: I use ycmd with clang for autocompletion, The one time I need the fastest binaries I can get, I just recompile with GCC. That is basically the only thing I use GCC for. If clang ever get as good as GCCs, I would probably just stop using it completely.
The problem is that in older codebases, in lower level code, or in interfacing with C libraries, there may still be pointers used for various purposes that are not observing a specific object. They could still be used for arrays, for handling memory buffers, even ownership in legacy code. If you work with such code, there's too much "noise" introduced to be quickly confident in what exactly you are looking at when you look at a raw pointer. I don't see any problem with this, to be honest. It's essentially just code-as-documentation. This is a good thing, because unlike real documentation, it can never get out of sync with code! What needs to die a fiery death is std::experimental::optional, which has pointer-like syntactic sugar even though it's not a pointer. Worse, the pointer-like syntactic sugar (i.e., the shortest thing to type) causes UB if an object is not contained. I'm pretty sure I've heard Bjarne say that the safe stuff should be easy to type, and the unsafe stuff hard...
Sounds good. I'm not sure if I will dig back into dll loading soon since I am trying to create a dependency free, header file only, thread local, heap allocator at the moment. I used both procmon and DependencyWalker but couldn't see why tcmalloc_minimal wasn't loading. Then again it is supposed to be a program wide substitution for malloc and I actually don't understand how that is possible with just linking right now. If I dig back into dll loading or explicitly define the dll entry point this will be a huge help, thanks!
I guess for the same reason we use lambdas in the first place. None of the std:: algorithms 'demands' a lambda (lambdas are syntactic sugar after all) yet they all become so much more useful when you can define functions in place. The post was updated with rationale on this example : http://coliru.stacked-crooked.com/a/94810cc7269abf7e
Iterating a tuple or visiting a variant are both use-cases where this sort of thing comes in handy. See: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0050r0.pdf
Yeah, that's one reason to use a reference wrapper. optional&lt;T&amp;&gt; doesn't suffer from that either.
I agree with you there are techniques that can be used for encapsulation. I'm just saying, there are raw pointers used for other things than "a non-owning view of one object". Raw pointers will always be the goto for these other things because of their C heritage. So why not distinguish the non-owning view case? This way when doing code review, observer_ptr is business as usual, and a raw pointer means sit up and pay attention, things are about to happen. You should throw; if optional is going to be used unsafely, what's the point? Most types have a cheap default constructor, so you can just go back to error codes in 99% of real use cases. The whole strength of optional, Expected, etc is that there is no way for the user to avoid doing the check. Maybe for performance reasons you should have an unsafe getter, but this goes back to what I said: the unsafe getter should have a long name so its clear when reading code, like unsafe_get; the safe getter should be the default and have a short name. Also, if operator() means implicit conversion, I'm really not excited at the idea of an implicit operator that can throw or have UB. It's really surprising to me looking at optional what a step backwards it is.
It's still pretty fast. I originally played Skyrim in VMWare Fusion on a Mac (2010, 2.something GHz), and while it's wasn't perfect, it was very playable running on Windows in a VM. I think today's processors help facilitate VMs now so programs run close to on-the-metal speeds.
Well, if you don't use that raw pointer (x), it's quite hard to create a null reference. You've just sort of shifted the problem - a null reference is undefined behavior, so the real error occurred when you dereferenced x. A special pointer class might guarantee non-nullability, but you can still put any arbitrary invalid memory location in if you try hard enough. The class can't guarantee that dereferencing it won't crash.
What has this to do with C++ ? lol.
That, along with the fact that std::experimental::optional::operator* and operator-&gt; don't check that a value is present, basically ensures that I'll never use std::[experimental::]optional.
After the C++ Roguebasin tutorial, the book was the one I read. I knew Python pretty well though, so not all the concepts were entirely new to me.
So you don't use std::vector or std::unique_ptr either? The above is sort of tongue-in-cheek, but the presence check for `operator*` and `operator-&gt;` would introduce additional overhead that is unnecessary in the majority of cases.
I would have expected the article to explicitly mention IEEE 754 and the impact the change could have on anyone depending on IEEE 754 semantics to do exact arithmetic, compute exact error bounds, etc. Instead it seems targeted at people who don't care about such things. If that's their target audience then I'd expect that of course there will be fewer users who are concerned about /fp:fast vs. /fp:precise.
Spirit actually generates pretty fast parsers, it's the compilation time that is slow (although getting better on modern compilers). Also it's pretty. Bison is ugly, ancient, but reliable and lightning fast to build a parser.
I guess composability using different callable objects certainly has their advantages. However, I rarely come across a situation where that is a requirement. Usually the callable object that handles the different types are closely related in terms of function and purpose, hence I find myself implementing the `FunctionObject` approach quite often. http://coliru.stacked-crooked.com/a/688ab3482ff55482 
I have written a [fairly complex parser](https://github.com/Caltech-IPAC/libadql) for an SQL92 derivative using Boost Spirit v2. This is my second major project using Boost Spirit. One of my primary complaints is inscrutable error messages. I kind of got used to the messages, so they do not bother me so much any more. The other major complaint was long compile times. I had to do a bit of work to restructure my code, because otherwise it was taking 4 GB of RAM and 10 minutes to compile. It still takes more than a minute on a monster 32 core machine to compile. X3 is supposed to help with those particular problems. I do not know if they really helped. Otherwise, it is fantastic to work with. It is well documented and easy to build up complex parsers out of simpler blocks. You get really used to the wild-and-wooly operator overloading that they use. I have only glanced at Flex/Bison parsers, but this way seems much more natural.
If you're familiar with flex/bison you might want to try flexC++/bisonC++. I found it much cleaner than bison or bison++.
Would you consider other alternatives? Our [PEGTL](https://github.com/ColinH/PEGTL) might interest you, it is a zero-dependency C++11 header-only PEG parser generator with in-language grammar. Unlike spirit, it uses normal templates instead of operator overloading, which is slightly longer to write but IMHO a more straight-forward approach. If you prefer to have the grammar in a separate file and in a more readable format, translated to PEGTL-code by your build system, you might want to check out the included [example](https://github.com/ColinH/PEGTL/blob/master/examples/abnf2pegtl.cc) for ABNF to PEGTL conversion. This is currently only an example as you can not access the whole power and convenience of the PEGTL like that, but it might help to get started.
Apparently X3 improved the compile time quite a bit. At least that was the gist I got from the CppCon talk. The difference is that it instantiates much fewer templates and uses ADL tricks instead.
&gt; X3 is supposed to help with those particular problems. I do not know if they really helped. Yes, IME, massively!
One recent account of the story: https://lwn.net/Articles/629259/
Apparently the response I wrote yesterday didn't come through, but here's a summary of what I said. I use both libstdc++ and LLVM's libc++, so I'm not just restricted to only 1 version. However, when writing the response, I got curious and booted up my Win7 VM and fired up VS to see what my threading problem actually was again. Turns out that I didn't unlock a mutex properly and it crashed on destructing the mutex, since it was busy. So, I guess you prove your point there, but my point of not having enough time to support 3 compilers and 2 build systems (I use tup on Linux, which doesn't work on Windows, yet) still stands. With regards to my issue with static memory, I can resolve that by switching to GLEW from glxw, so it should be more compatible with VS already. With regards to this claim: &gt;Additionally, the Visual Studio compiler historically could generate better code than GCC. I heard people claim the exact opposite, so I'll have to profile my code and see which compiler outputs the fastest binary. If MSVC indeed outputs faster code like you claim, I will seriously reconsider supporting VS.
I'm bald, this actually looks interesting. No.
It is an ugly license that actually takes away developer freedom. I don't blame Apple one bit for avoiding it. I make it a point to avoid GPL 3 as much as possible. 
My main issue with GCC is that when you compile with literally every warning enabled, it doesn't tell you where it comes from, just "blah blah blah -Wpedantic". Clang spews out roughly the same error, but as "blah blah blah -Wc++98-compat". This way you can turn on all warnings you find useful, but turn off those you don't find useful. If there is a way to have GCC do the same, or have a list of where each error message comes from on GCC, that would be highly appreciated.
[Ragel](http://www.colm.net/open-source/ragel/) is really nice and relatively fast to grasp if you already have notions of parser, dfa, etc.
MS must have really had a mental collapse here to actually get involved in the CLang community. Whatever happened I glad it did as MS C++ support has been crap for a long time. 
Does this mean we'll have a sane dynamic library system?
&gt; according to presentations given at the recent CPPCon 2015 event in Bellevue I think that's not entirely true then, is it? I know it's coming but did they specifically say the _next_ update? And _November_? Also: &gt; The company is also set to release a “build only” edition of Visual C++, which will install the compiler and command-line build tools without the Visual Studio IDE. I thought they're considering it. But this sounds very definitive. What's the source?
Happens to me on GCC 4.9, haven't tested the latest release.
Please ask questions on /r/cpp_questions/ in future. The x[n] operator is equivalent to *(x+n) when working with raw pointers, using this info we can see your mistake: array[i] = *twodarray; // = twodarray[0] So, in to loop you are creating an array, but then only assigning the first element into your outer array. You need to assign a pointer the entire inner array into your outer array, so your outer array need to be an array of pointers, not an array of ints int **array; array = new int*[capacity]; for (int i = 0; i &lt; capacity; i++) { array[i] = new int [twodcapacity]; } // ... do stuff for (int i = 0; i &lt; capacity; i++) { delete[] array[i]; // Got to clean up the inner array } delete[] array; // And the outer one too See how complicated this sort of stuff gets with raw pointers? Outside the world of high performance programming (and even there sometimes), it is generally considered good practice to not use the "new[]", operator and with more modern versions of c++, not to use the "new" operator either. What we need to use here instead is a std::vector. In C++11 code, this can be done like so: #include &lt;vector&gt; #include &lt;iostream&gt; int main() { std::vector&lt;std::vector&lt;int&gt;&gt; outer_array(5); // outer size of 5 for(auto &amp;&amp;inner_array : outer_array) { inner_array.resize(3); // inner size of 3 } std::cout&lt;&lt;outer_array[4][2]&lt;&lt;std::endl; // Output defualt constructed int i.e 0 } 
Happy holidays! :)
I'm fairly sure he said it's set for Update 1 in November. Edit: Here's [the slide](http://i.imgur.com/K0tqxeI.png)
You may have seen the "Microsoft promises Clang for Windows in November Visual C++ update" post from theregister. Reading the article, it is just a summary of this talk. This is the primary source for the article. Look at the talk yourself before drawing conclusions from the article.
avoiding vs's build system is only going to get harder. that's the "extend" part.
I remember reading that they are gonna fund clang devs to get it to work with windows. I guess it paid off and it's ready.
Not yet. They still gonna use their own codegen engine. Though clang is working on MS ABI. I would love if we could use clang exclusively and build binaries compatible with MS ABI.
Jason Turner is also one of the authors of an amazing ECMAScript-like scripting language called ChaiScript: http://chaiscript.com/
Express has historically had the IDE bundled with it, albeit a trimmed down version though.
Relax. Breathe. Fear is ok, but not as guide. 
For Win32 GUI programs, popen doesn't work. See https://msdn.microsoft.com/en-us/library/ms682499.aspx
What's insane or less sane than what others do?
I looked into this a few years ago and was similarly disappointed. The only ones I could find that are at all reasonable are [Boost.Process](http://www.highscore.de/boost/process/), [libexecstream](http://libexecstream.sourceforge.net/) and [pstreams](http://pstreams.sourceforge.net/). Pstreams is the only one that has seen any recent development.
I use clang with openmp and intel openmp runtime library regularly since June in both Linux and OSX boxes. OpenMP 3.1 works just fine on both. I admit it isn't straightforward to setup, but it's october already and he still hasn't figured it out.
tools only SKU won't have Clang/C2 in it yet for the reason that /u/STL mentions above (it's a separate package). tools SKU looks like it is on track. it's an installer that lays downs the necessary libs, compilers, and VC dev command prompt but no IDE. no relationship to the Express SKU. it's completely new. We are still iterating a bit on exact details of how we'll package Clang/C2. But most likely outcome is what STL outlines above.
Roku is looking for great C++ developers with experience in embedded devices, video, and Linux. We've got senior positions open in Saratoga, CA, Austin, TX, and Cambridge, UK. See https://www.roku.com/about/jobs for details. I've been on the firmware team working on our Roku TV devices for the last year and a half here in the Austin office, and it's been really interesting. We've been upgrading our codebase from C++ '03/Boost to C++ '14, so I've been able to work with a lot of the new features.
Do you happen to know if the company offers remote positions?
For the most part, no, at least in the system development site. We're doing lots with secure hardware, so working off-site is difficult.
C++ 14 with no boost. Interesting. BTW I will handcode a profile feature for Netflix in ASM for free if that what it takes. 
This is all about preventing bad or tired programmers from taking that T* (which because of backwards compatibility is fully passable to delete) and making sure that no one can call delete on it. No static analyzer, no buts no nothing. At least as far as I know.
She doesn't really elaborate except that someone asks this question and she responds that she mentions `new` and `delete` because she doesn't think someone can claim to "know C++" if they're not aware of them.
Thanks, yeah. I listened yesterday. I'm not sure how I feel in comparison to the rest of her abnormal (not in a bad way) teaching. Surely with all of the better tools available, new and delete can wait instead of being day 1. I'd say you have to know that and the C stuff to be successful with real world existing code, but not before more useful C++ stuff.
Definitely agree here as well (as someone who is currently trying to learn how to write a recursive-descent parser). The hardest part seems to be handling infix operators + precedence -- although it's a [solved](https://en.wikipedia.org/wiki/Shunting-yard_algorithm) [problem](http://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing), it's still hard as a first-timer to incorporate into a hand-written parser. That said, if you're parsing a simple enough grammar where you don't even need to worry about operator precedence, recursive descent is a good way to go.
Will it be a C++ compiler SKU only, and if it's not, can we de-select .Net and all that stuff? And great to hear!
Alright, thanks for the heads up anyway. 
This is a descriptive title
You should have at least a minimal knowledge about computer architecture.
Shame that C++ Builder is awful and VCL isn't too much better. Sure, the form designer is nice but day to day coding and debugging is so frustrating.
That is so awesome! +10000 :-) And @Ivan171 below me: I sincerely hope MFC will *not* be included. In my opinion, people that still need MFC, can very well be punished by having to install the traditional VS.
Yes.
I found this [posting](https://corporate-chickasaw.icims.com/jobs/2480/electrical--engineer-%28software-engineer%29---faa-nas/job) ;-) I'm looking for a solid self-motivated software engineer that loves C++ and likes interfacing to hardware, playing with sockets, and working with others to expand my software development team in Oklahoma City -- contract with the FAA -- to maintain existing code and, more importantly (and fun!), help with a RADAR transceiver system software refresh (redesign?) using modern C++ on a Linux platform. This is a long-term (career) position (don't let the "contract" thing scare you...). (we also have some Java stuff if you're into that) {I think I ran out of parens.} 
Just added a namespace and fixed the `return std::move(x)` issue. Thanks for taking a look!
There's only so many years we can keep saying "way to turn over a new leaf, Microsoft, but I still don't trust you" before it stops being healthy paranoia. They've been "turning over a new leaf" for quite a while now
Just use CMake, I've used that in some projects that target both VC++ on Windows and Clang on Linux without much issue.
Hey everyone, Steve Carroll here. I'm the dev manager for VC++ but I also do external recruiting for VS all up. In the various compiler teams we have a few different positions that might be of interest: Jim Radigan's team has a position working on the backend of the VC Compiler [ https://careers.microsoft.com/jobdetails.aspx?ss=&amp;pg=0&amp;so=&amp;rw=3&amp;jid=182406&amp;jlang=EN&amp;pp=SS ] Jim is the guy in the Clang/C2 [https://www.youtube.com/watch?v=TRgWJuQhkQo] CppCon video that seems to trend about once a week. :) obviously we use the VC compiler/libs/etc. If interested, please PM me here. 
As crazy as it sounds, one of the fastest way to implement this is to use boost::python, use python to do it (which has some nice popen support to do it much easier then in C or C++), and then return from python the output as a python string, and convert it to a c++ string. 
First release will not have mfc/atl but we are open to feedback :)
I thought it was a good post, I'm legitimately confused as to why it's getting more down than up voted. Would be curious to hear from someone who didn't like it. 
&gt; &gt; &gt; {I think I ran out of parens.} Try lisp ;-) (yes, that smiley was just to unbalance the parens)
doesn't Rust?
Boost Proto can help with this.
Please don't assume that SoM breaks for complex regexes - we do handle the vast majority of regexes (about 98.5% of the patterns we have on file from vendors) that we handle normally in SoM mode as well. We handle a lot more than just "fixed length patterns" or simple combinations of fixed length patterns. Fuzzy matching will support full regex. It will generally be considerably less efficient in terms of scalability than what we have now. I would be surprised if it turns out to handle thousands of patterns well at all, for example. That being said, I'm not sure if anyone else will either, so we may be your best bet.
I posted another blog entry at https://01.org/hyperscan/blogs/geofflangdale/2015/how-we-match-regular-expressions It's pretty much a summary of a summary, I'm afraid. The major strategy is that of using literal match "factors" where we can to reduce the difficulty of the task, but there are many other case-by-case things that we do (splitting and merging engines, SIMD acceleration, etc). It's been a source of some frustration over the years that we don't have One Clean Algorithm That Does Everything for this task. We have evaluated many alternative implementations to greater or lesser extents. There are clearly many ways of doing regex, although there's not that much out there that is aimed at scaling to large numbers of patterns and handling streaming correctly (at least, not that I'm aware of).
That detail is insane to you? You can't handle real insanity, dude ;-). Quite honestly, I think that the Microsoft approach (explicitly saying what is module interface) is better for giving your module clear boundaries. Without that, everything that can't be static (e.g. because used in different translation units) becomes part of my so. If you look at a typical so with ldd/nnm, you see a bunch of stuff you didn't really want. That is not cool. Also, that impedes optimizations - anything that is not explicitly exported is easily subject to inlining and whole program / link time optimization.
I understand and appreciate why C++ is what it is. I understand my ideas are not feasible. However, these my dream language ideas (lots of these have to do with inproving tooling): Features need to be removed that create complex or unnecessary parse situations. Most vexing parse is an embarassment. obselete C back-compat syntax and semantics need to go. The &gt;&gt; operator needs to die a slow, painful death. Lambda syntax needs to be made cleaner, which is possible if we remove other language parse complexity. templates are both the best thing since sliced bread and an eternal curse on the language. UB makes us cry. Initialization is a mess, and "uniform initialization" made it worse. Uniform initialization is probably the #1 misstep the C++11/14. here is a controversial one: cv qualifiers can burn in hell. Look at the specializations of std::is_function if you disagree. Access restriction and immutable interfaces solve every problem that const attempts to solve that I know of (except compiler optimizations). Having to think about whether an object is const affects nearly every line of code in a C++ program and TREMENDOUSLY affects development speed in my experience. 
I'd prefer it to be safe by default and optionally unsafe, not the opposite. To answer your question, I use std::vector::at unless immediately preceding code implies that an access will definitely be within bounds and I never have any null unique_ptrs floating around. However, most people rarely use ::at because it's extra characters. The safe way should be the easy way, not the hard way. Also, the main point of my comment was that std::experimental::optional not supporting reference types is a major flaw/deal-breaker, not the lack of a check with operator*, which can be worked around.
MonoDevelop does supports C/C++ projects but not to extent of an IDE.
The example of name mangling is actually one of the simpler areas of ABI compatibility and one in which there's very solid cross compiler compatibility. The Itainium ABI specifies much of it, perhaps all of it by now if it's been updated for the new features in C++14. And even though clang, gcc and icc track the Itainium ABI they also have been working to ensure that they're compatible on the bits that it hasn't been updated to cover yet. VC++ doesn't document its name mangling, but for old C++ features VC++'s mangling is well known (including bugs) and compilers that target VC++ compatibility have been tracking its updates as it has implemented new C++ features with additions to the mangling scheme.
What about CLion?
&gt; (yes, that smiley was just to unbalance the parens) :-( why? yes, that smiley does change the balance )
le qtcreator (however latest ver. is buggy :'( )
Not sure why this got marked down, boost::python's execution routines hide cross platform utilities, your alternatives are qt, a really heavy library, or possibly boost::process (which doesn't appear to be official? Or even possibly maintained?) Although I will add that popen has been followed by subprocess in python (embedded), same idea. Shouting use POSIX popen doesn't work very well if you need to be cross platform. In particular boost::python wrapping "just works" on windows." 
&gt; I really doubt it is a high priority for him. But then why compare them at all? The only thing this benchmark says is "OpenMP still works". Michael could have performed an interesting benchmark by enabling OpenMP in clang but decided that it was better to do a 5 page long meaningless benchmark instead (for the third time since clang supports OpenMP). &gt; Further he was waiting at one time for released code. LLVM 3.7 was released in August. That's two months ago already. Phoronix raison d'etre is discussing meaningful benchmarks. If "it is not high priority" to do meaningful benchmarks then what's the point? I'd rather have one meaningful benchmark per month than 10 meaningless benchmarks per day.
That text colour scheme is making my eyes bleed.
Is the default Vim-dark on kdevelop, once you get used to it is really nice, your eyes don't get tired. I have been coding for more than 10 hours multiple days in a row without any problem(that is easily done with dark themes as your eyes rest a lot compared with the ones with whites backgrounds). Really works for me.
I really like the ['KDE' colosrcheme](https://imgur.com/KzKr0GV)
&gt; Please don't assume that SoM breaks for complex regexes - we do handle the vast majority of regexes (about 98.5% of the patterns we have on file from vendors) that we handle normally in SoM mode as well. We handle a lot more than just "fixed length patterns" or simple combinations of fixed length patterns. Fair enough, its up to the user to test. Out of curiosity are there any examples of regexes that would fail under SoM? &gt; Fuzzy matching will support full regex. It will generally be considerably less efficient in terms of scalability than what we have now. I would be surprised if it turns out to handle thousands of patterns well at all, for example. That being said, I'm not sure if anyone else will either, so we may be your best bet. Would there be a possibility of mixing and matching fuzzy evaluation for some regexes and precise (faster) evaluation for others within the same engine? (so maybe in in every 500 to 1000 regexes needs fuzzy evaluation).
QtCreator looks great KDevelop is fantastic I also like a lot codelite
&gt; T* is supposed to be non-owning. This is not a common knowledge. Also, there are older codebases (or also a new ones) which don't follow this recommendation.
What's the one in the screenshot?
Not OP but I have used that one. Its Xamarin/MonoDevelop. Kind of Chrome/Chromium thing.
vim/emacs amirite?
I was going to try Kdevelop but it pulled a lot of dependencies with it. Including plasma-framework, krunner, okteta, kdevelop-platform-git. I'm not so sure about it :/
Cool. It looks like MS has done a lot of work here which will hopefully lead to more compliant tools. An interesting aside I wonder what they are alluding to with that new architecture in the fall? 64 bit ARM maybe. 
It'd still be an indirect call, and unless your object is a singleton I'd expect it to generally be less cache friendly.
am i the only one getting Kate Gregory's pic in the thumb of this reddit thread?
Duh? There aren't many GUI programs for any OS that display useful output to stdout.
Now all we need is libc++ for Visual C++. 
I think that Clion has a preset for keyboard shortcuts called eclipse, which does just that and works well. This largely applies to ide like functionality, for text editing emacs keybindings are often also available (things like delete line, delete word, etc). This is nice because it's the default in bash. If you're a vim guy, then many ides (and the shell) offer vim emulation, which helps with consistency, but obviously this is a more drastic change than just key bindings. This is what I use, between this and what I wrote above, switching between eclipse and clion would be relatively easy. 
Actually, the GUI programs on UNIX-like systems are written as wrappers for the command line tools. popen is the central thing there. Even when writing GUI from scratch it's extremely useful to make a separate command-line layer. This design is so important for testing. 
Looks great! I want to try it out but I only have access to RHEL5/6 and SUSE10/11 machines. No luck building so far but I'm not familiar with CMake. Hints?
Absolute biggest complaint has to be the poor implementation of Dark Theme at least on Windows. Those scroll bars kill my eyes.
Wow. That's bizarre.
I suppose that's true in some cases, but not most. Claws is not a wrapper for a command line email program, for example.
future reference, /r/cpp_questions is for problems just like this vector&lt;int&gt; a(10); This makes a vector that's 10 items long. At this point, a is essentially [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] for (int x = 0; x &lt; a.size(); x++) iterate through this loop for each item in 'a'. In this case, this loop will be executed 10 times, since a's size is 10. x is incremented each time, with an initial value of 0 a[x] = x; assign the x'th element in a to be the current value of x. Since we're incrementing x through each iteration of the loop, x will be 1 more each time this is executed. Once the loop is finished, a will have the values [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]. cout &lt;&lt; x &lt;&lt; " --- " &lt;&lt; a[x] + 1 &lt;&lt; endl; This prints out the value of x, followed by the value stored at the x'th element of a, plus one. E.g. if x is 3, a[3] is 3, so the output would be '3 --- 4' The output of this function would be: 0 --- 1 1 --- 2 ... so on ... 9 --- 10 Next, cin.get(); this line waits until the user presses enter, so that the program will not close until the user wishes to return 0; return from the main function, which terminates the program
The standard doesn't actually say anything about vtables anywhere. An implementation is free to put all the virtual function pointers in the object, or use some completely different mechanism than a vtable to implement virtual dispatch. It just so happens that (almost?) every compiler uses a vtable, albeit with different details. In order to do something like `inlinevirtual`, this part of the standard would have to be pretty much completely rewritten to specify the vtable mechanism in order to specify this different behavior. I don't see that happening any time soon. That said, this is an interesting idea for a compiler extension. I could see something like class X { [[inlinevirtual]] virtual void f(); }; using C++11's [attribute specifiers](http://en.cppreference.com/w/cpp/language/attributes), or a `__declspec(...)` or `__attribute__((...))` using the existing compiler-specific syntax.
thanks for your time spent helping me xD
~~At the beginning each element is not initialized.~~ Derp
Does that mean we can use lang features from C++14/17 that Clang supports, but MSVC does not? Like if I pick Clang, can I use C++14 style constexpr? 
I really hope that feature is standardized! I need to do some complex binary parsing with the strictest runtime overhead and minimal/freestanding environment requirements. No allocations and not linking against libc++ are killer features for me. I want to deal with system calls and stack allocation/destruction only, please. :) It sounds like heap allocations are potentially avoidable. Do you know if I will I be able to compile C++ coroutines without linking against a C++ runtime?
I second this suggestion. I've used PEGTL for a lot of stuff now, and it fits pretty well for medium-sized projects. You can easily attach validation logic to rules. In university class, we even wrote an assembler and a little C-Compiler stub with it. 
Good article, I only relatively recently learned about just how powerful the unpack operator is, especially in combination with initializer lists. The ripping on people on older compilers is a bit unnecessary though, or at least a stronger hint that you're kidding would be nice. Getting a company of a few hundred people, with many millions lines of code in production, to upgrade to 14 is not a trivial task. While 14 is great and greatly aids with this sort of thing, most code is not like this. So overall, 14 is a relatively small upgrade. People may have bigger fish to fry than working on upgrading. Incidentally, other than make_unique, which is a bit trivial to just implement yourself, the only time I've found myself really wanting 14 was for variadic lambdas.
It's packaged in Boost 1.59 already. Or did you mean "when does it come out of beta"? In which case, I don't know.
 All this discussion about a variant, like we don't already have access to 10 different versions. But no mention of pattern matching, the thing that we *actually* need to make variants 100x more useful. Rust has both of these, why not just do whatever the hell Rust is doing, and stop wasting time? Exceptions can go jump off a cliff. 
You don't need to use any kind of container for the data, just use a smart ptr, e.g: void write(std::string data) { auto msg = std::make_shared&lt;std::string&gt;(std::move(data)); async_write(socket_, asio::buffer(*msg), [msg](asio::error_code ec, std::size_t size) { if (ec) ice::log::error() &lt;&lt; "Socket write error: " &lt;&lt; ec.message(); }); } Note that there's a convenient free function `async_write` that calls async_write_some repeatly, so you don't need to do that yourself.
If you already feel like you've watched this about a week ago, don't worry, you're not crazy. I think they re-uploaded it due to audio issues.
Yes, I will clean it up and post it on GitHub as soon as I find time.
No, but there's a point in the UNIX way - each separate | separated command is a filter - the program uses the input in a structured manner, generates output in a well known format and that's fine. But if in the middle of the program you do a "cat" just because you don't know how to open a file, that's code smell. The UNIX way programs don't care about the source of their data - they work focused on that data, they don't resort to additional programs to do the job - instead, they can pass data to another program. What this guy wants is not "UNIX". It's bad code.
Have you read the existing proposals? This has been brought up and discussed quite a bit. I think anyone seriously into the topic (I am not in that category) will have read the existing proposals, know the outstanding issues there, and would expect you to address them. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3613.pdf
As a professional template metaprogrammer, I can say that this is not clearer than tag dispatch. It's more complicated to follow, especially for return values. Tag dispatch is simple to follow because *it's just overloading*. Once you learn the trick, it's just a matter of having an outer function calling inner helper functions. The true_type/false_type case is most common and easiest. Dispatching on multiple conditions is also fairly simple, once you learn how to express it properly. The highest-strength tag dispatch, on iterator categories, is particularly elegant due to the tag inheritance.
GCC provided -std=c++1y before renaming it. Their "experimental" support is robust in my experience, it's not something to be afraid of.
I'm wondering, how has the `&lt;atomic&gt;` porting (from the x86 arch) experience been so far? Has the (relatively more) relaxed memory model caused any _interesting subtleties_ -- or was it not that bad after all?
Absolutely. Coroutines are a core language feature, they do not require any runtime support. There is a &lt;coroutine&gt; header that contains definitions of two class templates: coroutine_traits and coroutine_handle that compiler uses to communicate with the library and that is it. You just need a compiler and that header.
Module imports that are in module interface files indeed form a directed acyclic graph. However, there is no restriction on the imports in the module implementation files. If your entire module is fully implemented in module interface file, then, yes, statics will be initialized in the order of that graph. If your imports in the implementation files introduce circular dependency, then for the modules involved, static initialization will be as it is today. 
Some of them are definitely the same or similar amongst many IDEs. For example: F5 to run &amp; debug the current project, F10 to step, F11 to step into, Shift+F11 to step out.
In addition to the comment I made there, I would like to mention that the SFINAE version when using conditional overloading(like [`fit::conditional`](http://fit.readthedocs.org/en/latest/conditional/index.html) or this one [here](http://pfultz2.com/blog/2014/08/22/overloading-requirements/)) is actually much shorter: FIT_STATIC_LAMBDA_FUNCTION(updatePhysicsFor) = fit::conditional( [](auto &amp;&amp; e, float delta) -&gt; decltype(e.calculatePhysics(delta), void()) { e.calculatePhysics(delta); std::cout &lt;&lt; "CalcluatePhyiscs" &lt;&lt; std::endl; }, [](auto &amp;&amp; e, float delta) -&gt; decltype(e.updatePhysics(delta), void()) { e.updatePhysics(delta); std::cout &lt;&lt; "UpdatePhysics" &lt;&lt; std::endl; }, [](auto &amp;&amp; e, float delta) -&gt; decltype(e.correctPhysicsErrors(), void()) { e.correctPhysicsErrors(); std::cout &lt;&lt; "CorrectPhysicsErrors" &lt;&lt; std::endl; } ); There was [P0051](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0051r0.pdf) that was proposing to add conditional overloading(called `overload_first`) function to the standard.
I write server-side software. Multiple services are written against a common middleware, so DLL allows saving a lot of memory as all service libraries share the footprint.
Code::Blocks is seriously underrated. It's the only decent IDE I've used that has never crashed.
Some of that is seriously unbelievable. Gives you an idea of why some people prefer to stick to C.
Please mention if you allow remote jobs or offer (international) relocation and/or visa sponsorship.
&gt;The only thing I disagree with is using namespace: The reason that I would not use it that early is not that it is hard to understand or anything, but that I advocate against it's use in general and therefore considering it as one of those things, that the beginners had to unlearn again. Put it in main?
Because obfuscated C is old news?
When distributing a library or framework in source form, that has to work on all of the weird platforms customers are interested in, feature conservatism pays. We support GCC, ICC, Clang, IBM XLC, and Cray, and have others that probably still work that we just don't hear about very often. We only just bumped our requirements to include variadic template support in March of this year, giving a current minimum version of GCC of 4.3! We don't rely on any other &gt;C++98 features, because it legitimately hinders our users' ability to deploy their applications.
Why at all? type 20 letters to save writing 5? int main() { std::cout &lt;&lt; "Hello World!\n"; } vs int main() { using namespace std; cout &lt;&lt; "Hello World!\n"; } I really don't see the advantage.
Aside from the trigraph thing it wasn't about obfuscation. It was about the poorly defined semantics of a bloated and needlessly complicated language.
VS has even different F-shortcuts for it for different IDE presets :-)
I've worked for several years using a combination of XCode and Nvidia's Visual Studio plugin for C++ on Android (recently renamed to GameWorks). It's passable. In practice we do most of our work on the Windows builds even though there is no intention to release those versions. MSVC2015's built in support for Android looks promising. But, I haven't had a chance to play with it yet. 2015's support for iPhone might be good. But, the need to remote to a Mac leaves me sceptical.
Is the benchmark used to test the speed of compilation or runtime perofrmance?
This looks SWEET!
This is not equivalent to what I wrote. The first and second case exclude each other, but the third one is an extension of the second one only in certain cases. I am not sure the way you would do that in fit. Can be done, I am prestty sure, but the code should not look flat like that. Or maybe I am missing something, I do not know.
True, though I still think it should be an option for the cases where the vtable doesn't get cached and the decision can be justified with performance data.
What about gedit?
It's clearer because all of the overloads are together, and you don't have to bounce through library machinery and lambdas.
/u/andralex
Any news on constexpr evaluation in unevaluated contexts?
Thanks for this. That site has a really good comment section.
What's the status on [this](http://www.pcg-random.org/posts/cpps-random_device.html) problem in `&lt;random&gt;`? What's the status on reflection?
OK, sounds nice on the library side, then! // Back-end devs having all the fun... :-
Yes, of course, hence the name 'conditional'. 
Qualifying GCC 5.2 C++11 support as "robust" is a long stretch. What do you mean by robust? To me robust means: &gt; One can use strict C++11 libraries in real world projects without having to fill compiler bug reports every week (which gets in the way of getting a job done). Under that definition, GCC 5.2 is not a "robust" C++11 compiler. A strict C++11 library is range-v3. GCC 4.9 compiles it fine. GCC 5.2 cannot even produce proper error messages while failing to compile range-v3 test suite in C++11 mode (one just gets different internal compiler errors while trying to do so). Two strict C++14 libraries would be range-v3 and Boost.Hana. GCC 6 (trunk) and clang &gt;= 3.5 can compile both of these libraries in C++14 mode without any issues. GCC 5.2 cannot. TL;DR: GCC 5.2 is fine for trying C++14 features on toy projects. For largeish C++11 projects either use GCC 4.9 or GCC 6 trunk. For largeish C++14 projects GCC 6 is what you need. 
&gt; And are they defined like this? They're defined to have a `bool` type, so the second is acceptable. &gt; So is this adding logical operators to integral constants? It's adding general `and_`, `or_` and `not_` metafunctions so you can do `and_v&lt;trait1, trait2&gt;`. Personally, in most cases, I find it easier to use the operators themselves (and/&amp;&amp;, or/||, and not/!): template&lt;typename T&gt; struct is_signed_integral : bool_constant&lt;is_integral_v&lt;T&gt; and is_signed_v&lt;T&gt;&gt; {} template&lt;typename Head, typename... Tail&gt; struct are_all_same : bool_constant&lt;(is_same_v&lt;Head, Tail&gt; and ...)&gt; {} Of course I find this easier with the combination of variable template traits, `bool_constant`, and fold expressions, so these new traits are probably considerably more desirable when you don't have those features.
I second this. Code::Blocks is a fantastic IDE. It also has an ultra-simple easy to use build system, and integrates debugging fantastically. CLion would be nice if the build was more automated. We work on a very large project with 100s of source files. We would waste too much time manually editing CMake files.
How to help with the reflection bit?
Every company I have ever worked at has had its own poor implementation of C++ reflection. A significant amount of the complexity in almost every major serialization library (protocol buffers, capnproto, fusion, thrift...) is dedicated to a poor reflection solution. I would gladly jettison every other paper to get reflection.
Yes, that's exactly right. I was watching your awesome talk at cppcon the other day (good job btw) and I must admit that i'm sold on `invoke()` (that's your fault I guess!). It is both really useful and really hard to get right. Nobody should have any reasons not to use `std::invoke`, so it needs to be both `constexpr` and conditionally `noexcept`. Otherwise we are back to square one "if you want to generically call something use invoke, unless...[you need to transport noexcept-ness correctly/call a constexpr function/...]".
/u/pfultz2 , we'll gladly use inline variables when they're available, but until then, the VTs for TTs aren't expected to be odr-used. Their natural use is in template arguments, like to enable_if_t, where there is no ODR concern. They were defined with ::value, but any equivalent mechanism (the conversion or call operator) is acceptable. The logical operators were renamed by LEWG to conjunction, disjunction, and negation. Notably, they derive from bool_constant when the inputs do, so they can be used directly for tag dispatch. I expect that they will prove useful even in the presence of fold expressions. (Notably, they have a form of short-circuiting behavior.) And if not, no big deal. Hiss to those quasi-keywords `and` etc., though. ;-)
There are no proposals for fixing &lt;random&gt;, so the L[E]WG hasn't spent any time on it. The Committee is staffed by volunteers and driven by submitted papers/issues. If somebody wants something fixed, they need to submit an issue. If they want to *actually* get it fixed, the issue needs a good proposed resolution, or a paper if it's big. Writing a blog post, or even developing a library, doesn't result in Committee action. Yes, we're volunteers. MS essentially donates a few weeks of my time to working on WG21 stuff, and I spend it on things that I'm deeply familiar with, like fixing nested_exception's unimplementability. To my knowledge, the Committee's only de facto "FTE" at the moment is Eric Niebler, who is working on his awesome Ranges TS. &gt; Thus asking for 64 integers may require std::random_device to make 64 operating system calls (which tend to be expensive). I don't believe that this is correct. AFAICT, random_device can buffer entropy from the OS, so it doesn't have to call every time. MSVC doesn't do this, but we probably could. (At some point I want to look into rdrand/rdseed instead of rand_s, which would really fix any perf issues.)
&gt; and_v&lt;trait1, trait2&gt; Are those operators variadic?
It may be more lines, but it's simpler to understand.
Thanks for the info on those being renamed. I'll watch for an updated paper. I think that being able to use them in place of `bool_constant` is useful, but I guess I find infix operators much easier to read, especially for longer chains of them. The short-circuiting is definitely a plus. I actually just started using those three alternative tokens very recently to see how I like that style, and I do actually like it a lot, given not having to explain them to anybody. Their lesser-known nature makes them less practical for real use. That said, though, the way I see it is that our eyes are used to reading sentences made of words rather than symbols. I think that while I'm very used to seeing &amp;&amp;/||/!, my brain has an easier time reading words. Out of curiosity, why do you dislike the alternative tokens? Maybe having to explain them, being too similar to Python, or not being pure (they *are* even named alternative)?
[Yup](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r0.html), you can pass as many arguments as you want. If you pass none, it's "`true`" for `conjunction` (`and_`) and "`false`" for `disjunction` (`or_`).
&gt; I am unsure how useful constexpr on invoke() would be. How often do you work with constexpr PMFs/PMDs? That is not really the point: the number of use cases is an open set, so closing the possibility should be given a much larger weight against it w.r.t. the cost of implementing it (similar to the seemingly arbitrary obstruction of using `goto` inside `constexpr` functions). 
&gt;There are no proposals for fixing &lt;random&gt;, so the L[E]WG hasn't spent any time on it. What about N4531 that was submitted post-Lenexa? In particular, what's the status of the two-legged overload of `std::shuffle` (not taking an URNG)?
&gt; The logical operators were renamed by LEWG to conjunction, disjunction, and negation. So we have both `std::negate` and `std::negation`, and they do completely different things? Yay...
there was a single trigraph, but it was kind of glossed over (string literal with ??! inside)
"has small size (default 4Mb);" On what combination of OS, build tools and hardware would that be? (Subtext to my comment; it's the default for some OS using some build tools on some hardware and not a universal constant)
Because with an error code, you can forget to check. One of the ideas behind algebraic data types (ADTs) is that you can force the user to unwrap the value they want, so you can't forget to check. I agree that optional lacks rich information about error type. The problem is that there's so many ways to go about this that it's harder to get into the standard. Your point about the purpose of optional is well taken, though. I have seen the talk on Expected. It's a fantastic talk (and definitely an inspiration for me on this topic), but the implementation of expected has some major issues that I don't want to get into at the moment. &gt; everywhere else in the standard library I already noted the example of vector[]. It's done this way for performance reasons. Do you have other examples? AFAIK, unordered_map (to take an example) doesn't have a single method that can directly yield UB. I agree that you shouldn't look in an optional without checking. But as i mentioned, you shouldn't use values without checking return codes either (when calling a function that uses them), but people do all the time. I think this is an opportunity for C++ to make the easy thing the safe thing, unlike how it's been in the past.
So we have both `++x` and `x++`, and they do completely different things? Yay...
It isn't necessary more precise. It is just exactly defined what the result is. Take for example a * b * c * d. This is defined as (((a*b)*c)*d), and multiplication is defined in whatever floating point model your target architecture supports. And it's the same across *all* processors that implement the same floating point model. Another example is fma/mad (fused multiply-add). On the XBOX 360 GPU, the compiler will optimize both a * x + a * b and a * (x + b) into an mad instruction when a and b are constants, and there is no way to turn this off. But on the PS3, it will only optimize the first sequence into a MAD. I haven't seen it become a problem in practice, but i've heard of a dev that did ran into great problems because of this. Another issue is that /fp:fast breaks numerical stability across release and debug builds. The article doesn't make the exact trade-offs clear, imo. The problem with /fp:fast is not the loss of precision, it is the loss of numerical stability across compiler versions and different architectures that implement the same floating point model. Only in very rare cases the precision actually matters.
&gt; It's adding general and_, or_ and not_ metafunctions so you can do and_v&lt;trait1, trait2&gt; But you can do `and_&lt;trait1, trait2&gt;` as well?
It doesn't seem likely to me that operator * is done for performance reasons. Suppose hypothetically that operator* did an if check and potentially threw an exception. Consider the typical usage: if (my_optional) { cerr &lt;&lt; *my_optional; } operator* is very short, and will probably be inlined. Once it is, you will have an if check inside the same if check. It gets optimized out: https://goo.gl/7dqwEY. In specific situations where you don't do an if check, and don't want * to do one either, you could have another method like unsafe_get. The find method returns an iterator. For better or worse, the iterator concept is like that, it doesn't have bounds checking. Iterators are a very broad concept, used in many places, might not make sense to do checking on them because in some situations there would be an unacceptable cost.
&gt; I am unsure how useful constexpr on invoke() would be. How often do you work with constexpr PMFs/PMDs? I think that is probably the worst possible way to approach `invokes()`s design (how often do you work with PMFs? do we need invoke at all?...). In my opinion the right questions are: What problem does invoke solve? How often does this problem needs solving? We need `std::invoke` _any single time we want to call an "Invokable" in a generic way_. That's actually pretty often, and IMO a fundamental problem that happens a lot in the STL. If we make `std::invoke` `constexpr` and conditionally `noexcept` we have a single way to solve a fundamental problem. We can just teach "When in doubt use invoke". With the current state of affairs we have to teach "Use invoke unless A or B". It would be very sad to have to teach that just because libc++ broke and nobody cared to fix it. 
Wait, there is an operator++(bool)?
Ah, reflection, the 1000kg-lead-weight that broke the camel's back. The feature that launched a thousand competing languages and not a few custom single-purpose C++ parses. The bottomless hole in the highway that swallowed thousands of weary travelers and millions of newbies. I remember back when it was just a joke that C++ would have a turing-complete type system before the standards guys got around to reflection. And now? Only 3 out of the top 4 posts are asking about reflection. We are falling numb to the pain.
If that's all there was to it, C++ would have had reflection a decade ago. Clearly they're gridlocked on *something*, and regardless of whether it's a divisive implementation tradeoff or a pointless philosophical squabble over whether Reflection is Considered Harmful, it doesn't seem likely that dropping an additional proposal into the blockage will unclog the pipes and get the sludge moving again.
Serialization libraries that use codegen really gets rid of the need for reflection. It'd be nice if they worked off the object declarations, but not too bad really. So far, I've been making do with std::tuple definitions that use a string constexpr + valu type struct for field names. Not great, but passable.
1) Some are personal projects that grew, some are a case of NIH syndrome, some are optimized for different goals, constraints, architectures and use cases. 2) Yes, just follow standard engineering principles, e.g. keep interfaces clean and consistent, modularize components, etc. It shouldn't be too bad. 3) Qt is probably the most common GUI framework and what I would use if starting a new project. Other common ones are wxWidgets, GTKmm, JUCE, OS-specific ones, etc
Apparently so! http://stackoverflow.com/q/3450420/462335 TL;DR: my_bool++ sets my_bool to true, while my_bool-- is not defiend.
&gt; And exceptions are better yet. I can't believe it's 2015 and some people are still afraid of them. I agree 100%.
Can you please send me a link to the good reflection paper from years ago? Thanks.
I've used Qt in the past and its pretty much the "leader" or most well known for C++ GUI
[N3951](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3951.pdf) is only from a year ago but it would be a great start. It could allow for [the eventual removal of Qt's preprocessor](http://woboq.com/blog/reflection-in-cpp-and-qt-moc.html).
&gt; I think we'll be seeing programming style evolve to use tuples as a rather than struct/class in many cases. And these already have reflection built in I think the popularity of tuples demonstrates the advantages of at least having that bit of reflection working, even if you don't go all the way to something that might help with serialization.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/hackernews] [C++17 progress update](https://np.reddit.com/r/hackernews/comments/3q8v7f/c17_progress_update/) - [/r/programming] [C++17 progress update \[x-post r/cpp\]](https://np.reddit.com/r/programming/comments/3qex6c/c17_progress_update_xpost_rcpp/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
So theoretically you could develop it for free, as they provide Qt under the LGPL. But if you want to be able to change their stuff, and not give that away, it seems to be about 350 dollars a month. If you find a more detailed page, let me know: https://www.qt.io/buy-product/?pid=7051
Its few thousads euros. But qt also comes with free lgpl licence which basicly means that your program can be commercial as long as its dynamicaly linked to qt library. On qt web page you can find rules under which you can deploy your commercial application with lgpl qt library. Sorry for not posting the link but Im on my phone so its a bit impractical.
Confirming the reflection SG did not meet. 
Here is the QT licensing FAQ: http://www.qt.io/faq/
Compilers should emit equivalent diagnostics for `enable_if` and `enable_if_t`. If they don't, then they should be fixed. I proposed _v for ::value because that's what I had extensive experience with. (This was in Jan 2014.) Relying on the constexpr implicit conversion does seem more useful (since bool-consuming code generally doesn't expect exactly bool). This was over a year before I used constexpr (it became usable for the STL's purposes very late in VS 2015's dev cycle), which is why I didn't consider the implicit conversion. As I recall, nobody else in LEWG/LWG proposed replacing the bools with the objects, so at least I wasn't alone in missing it. I would actually do this with a third suffix. _t is for traits that emit ::type (e.g. decay_t). _v is for when you want the ::value. _o would be for when you want the object. However, that would be replacing two characters (empty parens/braces at the end) with two characters (_o at the beginning). I did argue when proposing VTs-for-TTs that moving stuff from the end to the beginning helped with deeply nested code, but the case for is_same_o objects seems less compelling than is_same_v. Does passing tags around by value (and slicing) trigger the ODR concerns? It's midnight and my brain refuses to answer that question.
It is good practise to write the core functionality of your program without reference to any particular user interface, whether GUI or command line. The user interface is usually a separate component that depends on your core functionality. As well as separating concerns, this gives you the flexibility to change the user interface should the need arise.
Thanks for the reply! 
thank you for noticing I updated my post with the next values as default stack size:for SunOS/Solaris/Linux/Mac OS: 8192Kb, for Windows/1024Kb, cygwin 2048Kb)
Why? Should too many things be depricated before?
 template&lt;typename... Iterators&gt; void increment_all(Iterators&amp;... its) { ignore_returnvalues((++its)...); } This pattern is dangerous if you try to generalise it because function argument evaluation order is unspecified. It could do `++its` for the second type, then `++its` for the first and finally `++its` for the third, for example. Sounds wacky but the compiler is allowed to do it. Using brace initialiser lists is guaranteed to evalute left-to-right.
It's actually pretty useful, but you can use `std::exchange` now.
@STL: Regarding regex_match - as lunatic as "leftmost" matching is in ECMA/Perl vs. "leftmost longest" of traditional matching (it's a hack due to the lame matching algorithm), is what the world needs now yet another flavour of regex? "Kinda EMCA, but not quite". Most people struggle to understand regex as it is.
That code is shorter, but still: 1. uses comma operator + void(). Something not novice friendly. 2. `std::conditional` is some structure, code pattern that, even if shorter, you must learn. You also have to learn `if/else`, but that is something that you learn the first weeks in programming. I suspect that is one of the reasons why I find `static_if/else` good: the average person will learn to use it faster than `std::conditional`. 3. `static_if` just encloses conditions in lambdas as opposed to this SFINAE + operator, that `std::conditional` is using. 
Few days ago I was searching for some lightweight GUI library for a plugin (I am familiar with Qt, WxWidgets, Win32++, MFC, but they are too big or have not quite 'modern' interface) and found [Nana](http://nanapro.org/en-us/) library. Didn't use it too much, but from what I've seen it's pretty easy and 'modern' way of implementing a GUI in C++.
Many reasons I suppose - some libraries are layered on top of platform-specific GUI systems while others are cross platform. Some support rendering in a 3D context while others are strictly 2D. There are more or less unique widgets provided by some, and for some uses a dedicated layout editor could be necessary. There is also the compilation time thing, which leads some to choose lightweight libraries over feature-complete stuff. &gt; Can I write a command line program and then add a GUI later? (How much code would that involve re-writing?) If you just want to have a window that outputs the command line result it should not take that much effort. Most toolkits should provide a way to do that with about 25-50 lines of code. &gt; Which libraries/toolkits are common As mentioned before, it greatly depends on your usage. Some common ones: Qt, WTL, GTK, FLTK, Juce, wxWidgets
Hmm, Nana looks really interesting, thanks for posting that! Never heard about it before! I don't like their homepage too much unfortunately, it's really hard to find screenshots of how it actually looks like, which is kind of an important factor in a GUI library. I've searched for maybe 5 or 10 minutes but maybe I'm just too stupid :-)
The place you're looking are probably [this](http://qpcr4vir.github.io/nana-doxy/html/examples.html) and [this](http://qpcr4vir.github.io/nana-doxy/html/da/db9/md__c_1__prog__ext_lib_nana-docs_source_02-_getting__started.html).
&gt; namely when the order of the function evaluations needs to be guaranteed. That's why the example is what is, because it is very unlikely to be needed there. &gt; AFAIK, strict ordering can only be achieved with recursion As I describe in the article, you can use an initializer-list where it *is* guaranteed.
Reflection is hard, the design space is huge, and reflection means different things to different people; this makes it hard to achieve consensus. There are two radically different competing proposals. There is no consensus about which one of the two is pointing in the right direction. This might be because the design space has not been explored in sufficient depth yet. That's where we are right now. The following is what should still happen for introducing reflection in the C++ standard: Once there is consensus in which direction to go (which there isn't yet), one or more concrete approaches still need to be proposed, iterated upon, implemented, and get standard wording. Afterwards, a proposal that results from consensus (i.e. probably a stripped down version of reflection v0.1) will move into a TS, implemented, and iterated upon. At that point we can start thinking about merging an improved version of the TS into the C++ standard. That's... a lot of work that still needs to happen. Optimistically we are years of work away from even considering adding any form of reflection to the C++ standard. Optimistically, it would be great if the reflection study group manages to deliver a Reflection TS after C++17, in the C++20 time frame. That would probably mean that reflection can make it for C++23.
$0 if you don't mind deploying the Qt dll or so files with your binary.
1. This is just history being complicated. Different OSs, different requirements, different approaches to software dev. For example Qt requires a separate MOC step for stubbing in code, along with macro expansion. It is fine if you're invested in Qt ecosystem, but its not for everyone. 2. This is up to you but is a pretty common approach. CLI is just another front-end. Some people even just have their GUI talk directly to the CLI. Avoid as much rewriting as possible is probably in top 5 of dev rules. 3. I use Qt and/or web views. The web is much nicer to deal with. Basically the approach is, you embed a webserver library, then provide your GUI as a standard HTML/CSS/JS website through your local webserver instance. You have a lot of flexibility here, but typically you write you keep the UI separate then provide a data layer using web sockets to your core app.
&gt; As I describe in the article, you can use an initializer-list where it is guaranteed. But in this case you cannot propagate the transformed arguments as a parameter pack to another function. I agree this is less likely to be needed, but I see no other way to do it without recursion. My comment was not a criticism on the article. I'm simply interested in a possible alternative to recursion in this scenario, which happens to be one that I am encountering at the moment. I want `h(x)` to do something based on the first element of a sequence, `h(y)` based on the second, and so on.
&gt; N4531 std::rand replacement, revision 3 No rand_float/rand_double? :(
Okay, in that case you shouldn't have used `ignore_returnvalues` as the function to pass the mapped things too… ;-) Well, it is *possible* to do it without recursion, but I agree that it is not *as* nice as the case where you don't care. If the returntypes of `h(x)` are all default-constructable and move-assignable, the following will work (otherwise it is still possible, but even harder): #include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; using ints = std::initializer_list&lt;int&gt;; template&lt;typename T&gt; auto f(const T&amp; arg) { std::cout &lt;&lt; arg &lt;&lt; ", "; return arg*2; } template&lt;typename...Ts&gt; void g(const Ts&amp;... args) { std::cout &lt;&lt; '\n'; (void) ints{(std::cout &lt;&lt; args &lt;&lt; ", ",0)...}; std::cout &lt;&lt; '\n'; } template &lt;std::size_t... Indices, typename... Args&gt; auto fun_impl(std::index_sequence&lt;Indices...&gt;, Args&amp;&amp;... args) { std::tuple&lt;decltype(f(args))...&gt; rets; (void)ints{ ((void)(std::get&lt;Indices&gt;(rets) = f(args)),0)... }; return g(std::forward&lt;decltype(f(args))&gt;(std::get&lt;Indices&gt;(rets))...); } template &lt;typename... Args&gt; auto fun(Args&amp;&amp;... args) { return fun_impl(std::make_index_sequence&lt;sizeof...(Args)&gt;{}, std::forward&lt;Args&gt;(args)...); } int main() { fun(1, 2, 3.1, 4.7, 0u); } 
&gt; Okay, in that case you shouldn't have used ignore_returnvalues as the function to pass the mapped things too… ;-) Fair enough! :-) Thanks for the example! Indeed, it is not as nice as the simpler case, but the lack of recursion may still be useful to reduce the compile time...
Yea, that's not too bad. They're pretty low quality though and not too many screenshots there and it's tedious to click through all of it. If I was looking for a GUI library, I'd definitely want to see a showcase of the GUI online.
True, but he does have a point. Probably 90% of programs (especially in the business world) are just some variation of: * Read data from [file|database|server|etc] * Display data * Manipulate data * Save changes
No. For some is not even fast enough. I'm happy that at work we moved to GCC 4.9.2 and we can use C++11!
Just noticed co_yield, co_await and co_return. Those are temporary keywords right?
https://twitter.com/GorNishanov/status/657277791222677504
You should change your example code. Your class will only work on Heap Objects and as a result should probably just use a variadic template to forward arguments and construct the derived class on heap. CopyableAnimal animal1 = Monkey(); This line will have undefined behaviour as you bind a temporary by reference to a unique_ptr. EDIT: No its fine. but it does assume your class has a copy constructor :) reading too fast! I think im gonna get another coffee....
My solution: http://codereview.stackexchange.com/questions/54371/polymorphic-owned-reference-wrapper-for-class-hierarchies Have you tried posting this on stackexchange code review?
Have you thought of adding operator overloads for */-&gt;? Seems like it would be nice instead of having to call get.
I got that very same idea from another person who will update it to use such an interface, thanks! I'll also look into using forward arguments instead for creation! Thanks for the feedback!
Don't low level programmers find type_traits, r-value references, hash tables, atomic operations or threads useful?
Hugely useful.
\&gt; low level \&gt; Win32/MFC ?? 
Did you have something better in mind? Remember they can't conflict with existing code (e.g. variables named 'yield').
The stuff introduced in C++11 is kinda huge. Move semantics and `constexpr` are supremely useful. Smart pointers are great, and the new random library is incredible. It is so significant that I cannot code in C++03 anymore.
&gt; But what should be the focus of a C++ guy who has mostly worked on low level code which might not find many uses of the other 'stuff' introduced in C++ 11 and onward? I would focus on lifetime management and use std::unique_ptr and std::make_unique much more frequently. I don't know how low level you are working, but std::thread may be useful too. (I work on RTOSes and unfortunately std::thread doesn't provide enough control. That being said, I've learned a lot from std::thread and created a thread object that will one to spawn threads using member functions, function objects, lambdas, and free functions instead of the C-like void(void*) functions). `auto`and range-based-for help keep code maintainable. If you happen to use random numbers or regular expressions, there are now good standard objects for these. There's a lot that can make your code a lot cleaner. I strongly recommend reading up on C++11 (and on C++14 too) and watching [videos from CppCon](https://www.youtube.com/user/CppCon).
Should probably use reinterpret_cast instead of dynamic_cast, ~~and I don't really understand the purpose of storing a std::function when you could just use a private member function?~~ Other than that looks pretty good. edit: nvm I see why you're storing the function, to keep knowledge of the DerivedType around which is only given in the constructor's template argument.
wxWidgets is probably the second biggest cross platform GUI but Qt releases updates much faster and supports more platforms.
The problem (or one of the problems; read the email for details on the others) is that the current license has language regarding granting of patent rights that prevents people at some large companies from contributing. Dual licensing wouldn't change that, because contributors would still be hampered under those same requirements. (It would essentially make it harder for contributors not easier, because they would have to get their corporate overloads to sign off on two licenses instead of one, and one of them was already problematic.) 
In that case you can either write some modern C++ friendly wrappers for WinAPI usage yourself or use some already existing library for that. Technically everything should be wrapped to be safer and more friendly for future reuse. Also you most likely have code not connected with Win32 directly, there you obviously can use everything language has to offer in any manner you want.
This is now implemented. Regarding the forwarding of the arguments, is that possible in a nice way if the cunstructor is templated?
&gt; But what should be the focus of a C++ guy who has mostly worked on low level code which might not find many uses of the other 'stuff' introduced in C++ 11 and onward ? - Use `auto` whenever you can; Use decltype when it makes sense - Get used to consider std::unique_ptr as your "go-to" pointer type - Use the range-for loop whenever you can - Use lambdas - Use `std::async` instead of creating threads directly - Use std::thread, std::mutex, etc. - **Use RAII** You mention low level code, then you mention coding close to the WinAPI. If you have to write code to the winapi, you can still create abstractions in your client code (infact, this will improve the maintenance effort you do - if you refactor properly).
I hope so. I am new to standardization process, so I cannot state with confidence how permanent or temporary they are.
std::make_unique works in the same manner. you call std::make_unique&lt;Type&gt;( arg1, arg2, ... ); the template provides the return type. This makes sense anyway as you should be explicit of the type you construct given that you hide it in your object type. However, your constructor is best made explicit in this case (I think). Design decisions...
That has not been proposed.
regex_match is exceedingly simple to understand (in fact, I was surprised this was an issue at all). It behaves like regex_search, but with implicit `^meow$` anchors.
Not really. Low level programming is usually done in C not C++
It is easier and more satisfying to write new code. Also, you can sell new features. You cant sell beautiful code.
Pretty arrogant to think the only reason to no use exceptions is "fear" -- one of the fastest growing, [safe server programming languages](http://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right) don't have them at all. The problem with exceptions is * you have no way of knowing what exceptions may be thrown * unless you write a checked exception specification, in which case you're now exposing potentially irrelevant implementation details * which often you can't really do anything about and crashing is no worse an option than any other * and the ways in which your functions can exit are now non-deterministic * so you littered everything with try clauses that mostly swallow the exceptions any way * so now you're just going to throw unchecked exceptions, or specify throwing the base class * and you've essentially spent a lot of infrastructure to end up not far from where you started I'm not saying it's impossible to use exceptions, only that it's a heavy-weight tool that can make your code hard to read and reason about, and is often not necessary any way. Exceptions are great in theory, but in practice I have yet to find any well designed exception system that couldn't have been done just as easily with something like ```expected```
True, but even those have the underlying model which the UI drives. Plus, there's automation (scripting) of that model.
I did read the emails and it seemed to me that dual-licensing is/was a potential option: &gt; Our previous approach to solving this problem was to dual license the runtime libraries under both the UIUC and MIT licenses, because the MIT license doesn’t carry a binary attribution clause. This solved the attribution problem but prevents us from moving code from LLVM to compiler_rt, because the contributor may not have agreed to the use of the code under the MIT license. Dual-licensing was a sensible option at one point, but it didn't solve everything. &gt; The UIUC and MIT licenses have nothing to say about patents... The patent-speak is [not actually part of the UIUC license](http://llvm.org/docs/DeveloperPolicy.html#license). &gt; The other alternative would be a separate patent license (Google’s VP8 is the most high-profile project that I’m aware of to use this model), so the copyright license and the patent license are orthogonal. So, essentially a dual-license proposal.
the classical, non-co-routine return is in the form return &lt;expr&gt;; the same could be done for yield, await. BUT (&lt;expr&gt;) is an expression in it's own right. In fact a lot of people will enclose the return expression in parentheses. I don't know why, but, they do ( and that may break the semantic of the program because decltype(x) != decltype((x)) So you would need to have a special grammar for expression non enclosed in parentheses, and that may have been deemed too complicated. Also return would have accept () and yield would not have, it would have been confusing. 
I'm much more likely to contribute to a project with beautiful code than to one with messy, old code.
You would have to ask Zhihao.
&gt; Obviously they offer some advantage over one-another or, in theory, the best one would be the only one. This assumes there is such a thing as a single 'best' in this area. One quality by which a GUI library may judged is how well it conforms to the environment it's running in, e.g. by following conventions, integration with platform specific features, etc. The bottom line is that there's no way for a single UI library to be 'best' in every possible way on every platform.
The article that you linked is wrong, and Dave Cheney should know better than to be so deliberately misleading. In particular this line: &gt; `panic`s are always fatal to your program ...completely fails to mention that panics can be caught with the built-in `recover` function: http://blog.golang.org/defer-panic-and-recover . In reality the question "Does Go have exceptions?" is answered with "kinda". What Go has is an implementation of user-recoverable unwinding. Exceptions are also user-recoverable unwinding, though languages that embrace exceptions will add some usability niceties on top of this. In practice the most important distinction is that panicking across API boundaries is discouraged by the Go community; library authors are free to panic as much as they want internally as long as they recover before returning to client code (see the Go stdlib itself do this in the JSON module: https://github.com/golang/go/blob/e6ccfc1ad14d1078428fe5f408498f925ab69670/src/encoding/json/decode.go#L141).
&gt; Compilers should emit equivalent diagnostics for enable_if and enable_if_t. If they don't, then they should be fixed. Yes they should, but the problem is not quite that simple to solve. Because a boolean gets passed through a template alias, the original boolean clause gets "lost". So all that is known by the compiler is `true` or `false` rather than `is_some_trait&lt;T&gt;()`. It could be possible to back trace the boolean back to where it came from, but most compilers don't do that yet. So for now, I just stick with `enable_if`. &gt; I would actually do this with a third suffix. _t is for traits that emit ::type (e.g. decay_t) How about using `template&lt;class T&gt; using _t = typename T::type` instead of all this duplication? &gt; Does passing tags around by value (and slicing) trigger the ODR concerns? Its when they get passed by reference, because you will have an address that is different across TUs. On MSVC, it may not be this way, as it can be aggressive in optimizing duplicate objects, but it is considered non-conforming. Either way, in general, its not a problem in practice, but I would hope that the committee wouldn't leave at that, and actually fix the core language. There is [N4424](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4424.pdf) which discusses on how to solve these issues, and even offer workarounds that can be done now, however, I have found that those workarounds don't work well on MSVC. 
This is great. I'm following a similar approach at work: I'm working with Qt, and I need to dynamically.instantiate different objects depending on network data (Mostly different command handlers). I rely on Qt's QMetaType rtti stuff to instantiate different classes of a hierarchy given the derived class name (Demangled, of course. Just pick __cxa_deangle() and UndecorateSymbolName() from stlibc++ and MSVC respectively). Since objects instanced in that way should be created() and destroy()ed by special QMetaType functions, I wrote a (Horrible name....) MetaDynamicValuePointer smart pointer that gives value semantics to instances of derived classes of a given Base. In my case, since objects should be default constructed (See http://doc.qt.io/qt-5/qmetatype.html#create), I rely on polymorphic assignment operator (To copy a ptr means to allocate the object, then assign other object). 
There were no hits for co_yield in any codebase we looked at.
On Windows, there's the native GUI functions built in to the OS, and it's always been there. That's what you should use if you're just targeting Windows. Linux is developed as a kernel and a lot of separate pieces on top of it. Qt is a really good toolkit and it's been adopted by KDE as the basis for that whole desktop environment. It has a few issues I can think of: (1) until recently it wasn't available under a truly open source license, (2) you have to process all your GUI code with the "meta-object compiler" before actually compiling it, and (3) it has some legacy design decisions that could've been better if they had modern features of C++ available. The other main GUI toolkit used on Linux is GTK, which was created for GIMP and is used for the GNOME desktop environment. GTK is written in C, but there's GTKmm, which is a C++ wrapper for it. Both Qt and GTK have good cross-platform support. If you're doing Linux or cross-platform work, you should probably pick one of those, unless you have a good reason to use another toolkit. On Mac, the native GUI toolkit is Cocoa, which is an Objective-C framework. If you're targeting Mac, I'd recommend learning Objective-C. Qt has the best support for Mac I've seen of the third-party libraries. It is a good idea to write your program such that the logic is separated from the user interface, whether it's text or graphical. It may be more difficult to do it that way, but it does enable you to create different interfaces for it. I know at least a few programs have both Qt and GTK versions for Linux, and sometimes a command line version, too. 
... I would be very surprised indeed. What low level programming is done in C++? 
The problem is that it used to be wrong, before we had 0 overhead exceptions, exceptions would be slower even on the non-exceptional path. In such a case, it's completely reasonable to decide against exceptions. So if you either need to support old compilers or any compiler that doesn't support a form of 0 overhead exceptions, really, it's a completely sensible decision to ban exceptions. It also is a sensible decision to decide against them, because the old code base doesn't use them, I can agree with not wanting to mix new coding styles with old coding styles (although, you probably want to update the whole code base to modern c++ at some point anyway). However, if something like that is not the case, you're gonna need a very good reason to convince me that exceptions shouldn't be used. The performance problem is a thing of the past, however, throwing exceptions from DLLs going wrong, is something I can understand. Although, I'd probably lay down some rules to avoid such a problem, which would either be "don't throw exceptions from DLLs to the main module" or "make sure everything uses the same flags to compile". The last option seems the most sensible to me, but I can see why some people would want only a small part of the program to be compiled with different flags.
Any timeframe for the release of VS2015 update 1? Or is it still "When it's done"?
For pulling off the semantics of std::exchange, it's pretty terrible. One could have used std::swap before, or god forbid use two expressions (you have exposures to race conditions, but then, you had that before with operator++(bool)).
*Current systems just list the variables to be serialized which is pretty straight forward.* So now, when I add a member variable, I have to keep track of it in three places: the declaration in the class itself, the initializer in the constructor (which I guess is finally being addressed by P0134R0, yay), and now, some list somewhere that I have to remember to add it to if I want it to be serialized. No, thanks, I'd much prefer a keyword. *persist int foo=3*, or something like that.
So basically... *use classes instead of typedefs*?
Because it's a system API, like POSIX on Unix. When people mention "low level" C and C++ programming they are usually talking about writing code that calls system level API's instead of functions in higher level libraries like STL and Boost. Unless you're writing device drivers, the user space system API is the lowest level you can interact with from C and C++. 
I'm still confused. Kernels are written in C. Device drivers are written in C. Yes, user space is more often C++ than C but having a user space at all in an embedded system is fairly rare. Most embedded OS's don't have user space - they're a very thin shell over bare metal with just enough abstraction to allow a small subset of a full OS's functionality. Hell most aren't even multithreaded. I'm wondering if the state of the art in embedded processing has leaped in the last few years when I wasn't looking.
With optionals, checking in the if is idiomatic though, in which case there doesn't seem to be any performance penalty at all (see link below). If you don't do an if check, then you should want * to check and throw so you don't do something unsafe. I'm not against a method without a check existing, I don't see why it should be the path of least resistance. We're just setting ourselves up for people to do things like: auto my_optional = func(); auto x = *my_optional; // boom, UB , anything can happen, vs nice predictable exception thrown Why not make the easy thing (*) safe, and make the unsafe thing something that's obviously unsafe (like unsafe_get)? People who really care about one branch will be aware of this and make the change, people who don't care will use * and nobody will have to spend days debugging bizarre UB.
Exceptions are great. ADTs (algebraic data types) are great too. Sometimes one is preferred, sometimes the other. For functions that are called for their return value (not for side effects) I'd generally prefer ADTs. They give the user more flexibility with almost no downside (if done right).
I installed it, opened a source file, saw [this](http://imgur.com/1idmOAQ), closed it, uninstalled it.
Go also doesn't have generics. Are you going to now provide me a list of all the problems with generics, and why languages should in fact not have generics?
That's awful, it's like it's a beta release or something!
That's not stupid at all, it's actually a pretty widely held opinion in reaction to Go not having generics. Obviously saying "afraid of" is tongue in cheek; the point is many people very strongly disagree with a modern language not having generics, just as many people disagree with modern C++ developers not using exceptions. I also disagree with every bullet point except for your first one.
Probably missing some font dependencies or similar. I saw that happening with other KDE apps on non-kde environments
KDevelop is my favorite editor by far. Semantic highlighting is its best feature, never saw anything similar on any other IDE. I hope they'll make a standalone package for windows (not 1Gb of KDE dependencies) so I can use it at work.
What's special about its semantic highlighting?
Semantic highlighting gives the same color to the same variables/functions/... around the whole code (allowing you to easily find them just by "grepping the colors with your eyes") in addition to the standard syntactic colorization, which only gives colors to keywords, parentheses, brackets, etc.
You mean that every variable gets a different color? So: int x = 0; int y = x; int z = y; The two x's are one color, the y's are another, and the z's are a third? Edit: I'm no longer sure which you mean, from reading more. Do you mean what I wrote above, or just that e.g. local variables are all one color, free functions a second, methods a third, etc. ?
Member variables all get the same color. Honestly it is a bit weird at the beginning, but after one week you get used to it and it's awesome. I use QtCreator at work and I often find myself working with KDevelop on my VM. IMO KDevelop is way better than QtCreator, not only for semantic highlighting, but also for the UI that is much more intuitive and does not take much space from the code view, also the Git/Subversion plugin and the entire "Review" mode is awesome. There are a lot of small things that are really nice and taken individually do not matter much, but when you sum everything up you get something that is far better than QtCreator or VS (at least without extra plugins).
I wouldn't say that code quantity, in principle, is more important than quality or even that it's intentional. Code has a carrying cost and so the more of it that you have, the higher the cost of maintenance. I would say that duplication of code is an option at times which increases quantity however this trade-off is usually done to minimize dependencies. However I would say that people, in general, would want to minimize the quantity of code if they can. There is also a principle, called Conway's Law, that suggests that software is designed along how a company organizes itself. A well-known hypothetical example of Conway's law is that of a 4-pass compiler. If a company has 4 teams, usually disparate, building a compiler then you get a 4-pass compiler. Many of the teams I've worked on work like this and this usually results in code-bases that have implemented their own versions of a String class or something or other. It may be that I didn't know that you had a version of String that I could use and so I invented my own or maybe your version of String doesn't support internationalization or maybe your String class is not easily accessible (internal). Undoubtedly, there are other reasons that may contribute to a code-base getting large but Conway's Law, I think, is a factor.
Since sbabbi just answered the opposite of you, I'm not sure what to think.
We're saying the same, it's just that in your example, `x`, `y`, and `z` aren't member variables ;) you can have a look at what it looks like [here](https://zwabel.files.wordpress.com/2009/01/semantic_highlighting.png?w=840&amp;h=663).
&gt; QtCreator has semantic highlighting We are talking about two different things. Qt creator highlights keywords, maybe member vs non-member, but nothing more. KDevelop uses a different color for each variable, different highlighting for definition vs use of a name, etc.
QtCreator also highlights a bunch of other useful things like virtual functions. And Eclipse also highlights "read" vs "write" uses of each variable. Etc. but your point is taken, giving each variable a different color is an interesting and unique approach, maybe not for me but I can see why people like it.
Just try the Qt framework without doubt I always Write my application's CORE with C Programing Or Cpp which run in command line and Using Qt to build my GUI Just using the IPC to connect the two Part that means IPC is a good choice to make your GUI and Real Application function apart. That is the flexible way you can make your Programing in best way instead of waste more time about mixing GUI with Real Application function 
I don't think there's even an issue for that. But I know how to fix it, as long as I don't have to worry about user customization until we get to swapping the non-array element type.
We really should have normal return, if not, what does normal return mean in coroutine? is it prohibited?
&gt; Obviously saying "afraid of" is tongue in cheek Then you've conceded the point. You say "tongue in cheek", I say "stupid". &gt;I also disagree with every bullet point except for your first one. Well thanks for the thoughtful counter argument. I'll be sure to reference it in the future. The bottom line is your false equivalence lies only on one column: they're both in Go. Go does nothing but prove you can get along fine without either feature, it says nothing about the relative values of either. You're projecting everything else beyond that. Exceptions are a heavy weight solution to error handing, whereas generics are light weight and fast -- they were kept out of the language for reasons of conceptual simplicity and probably compile speed. Thanks for this intellectually unrewarding conversation. At best you have won a popularity contest consisting of what appears to be one voter. 
The main question is, how should it be fixed? Should the `noexcept` specification for `std::swap` be patched up, or should the semantics of recursive `noexcept` definitions be changed to what is expected? I'd argue that if the current behavior is sufficiently unexpected even the standard gets it wrong, it should be changed in the core language.
Tongue in cheek is not a synonym for stupid. Nobody is denying you can write code without exceptions, so if that all that your example was proving, consider it pointless. - you have no way of knowing what exceptions may be thrown - This is an issue with unchecked exceptions - unless you write a checked exception specification, in which case you're now exposing potentially irrelevant implementation details - throwing is part of the interface since it directly affects users, so it's not an implementation detail. In C++ listing which exceptions you can throw is considered documenting the interface. - which often you can't really do anything about and crashing is no worse an option than any other - crashing is nearly always worse. Exceptions already "default" to crashing the application, the end user should be able to override that; library authors should not be crashing user processes against their will. - and the ways in which your functions can exit are now non-deterministic - the behavior of exceptions is deterministic - so you littered everything with try clauses that mostly swallow the exceptions any way - I'm not a Java guy but my understanding is that this is considered terrible; in C++ as well swallowing exceptions is almost always wrong. - so now you're just going to throw unchecked exceptions, or specify throwing the base class and you've essentially spent a lot of infrastructure to end up not far from where you started - If you misuse exceptions, that will probably be true. Hopefully that's intellectually rewarding enough for you; I will not respond further. 
no public dates yet. RC is next. 
I can't write c++ without lambdas. 
The screenshot is from January 2009, so close to 7 years old. The current version is indeed excellent, though.
Repeat after me: reinterpret_cast is the wrong cast. The repeat it again. Repeat it until you stop even considering reinterpret_cast as a proper tool. The cases where reinterpret_cast is the right tool are truly few and far between.
Damn beta releases!
The changelog looks awesome, will try it later today.
Stroustrup covered this quite well as part of his recent CPPCON presentation, its also in the CppCoreGuidelines.
Ok, I think I read the relevant part of CppCoreGuidelines referencing reinterpret_cast, and understand that it can be dangerous if used incorrectly. In this scenario, downcasting to a known type, I believe it is well-defined behaviour [(referencing point 5 here)](http://en.cppreference.com/w/cpp/language/reinterpret_cast) assuming no virtual inheritance. I should probably have suggested static_cast instead since it would give a compile error in the case of virtual inheritance. It seems however that CppCoreGuidelines also recommends against using static_cast for downcasting, instead suggesting dynamic_cast. I disagree with the guideline in this case, since the derived type is known at compile time in much the same way as with CRTP classes. I haven't seen any CRTP implementations that follow this guideline and rightly so, since using dynamic_cast will have a runtime cost that can be completely avoided safely.
Couldn't this be checked with static analysis and be something covered by the Guideline Support Library, something like "you did not check optional before use"? That way you get the safety in semantics and no loss in performance. I understand if your not using them the points moot, but if the person is someone who forgets to check optional, maybe they should?
&gt; (1) until recently it wasn't available under a truly open source license Qt was released under the GPL in 2000, ending the FreeQt-QPL controversy. That was 15 years ago, I would't say it's recent. Since then, LGPL licensing was adopted in addition to a commercial license. &gt; Both Qt and GTK have good cross-platform support GTK looks terrible on platforms that are not *nix. Qt looks bad (but acceptable) on mac, and near-native on other platforms. 
&gt;In the world of console game development, there is no perceived need to cleanly handle serious errors. Is there? From my perception games seem to implement the concept of "no matter what happens, stay running". &gt;Console games do not use files. You might not be able to call them files directly, but these multy-gigabyte asset chunks usually consist of a layout of all the files and offsets of the actual data. A file might be missing from this chunk, which can very well be recoverable. And in the case it isn't, you can catch the exception and output the error to the TTY or log file and then exit. &gt;I see no indication that things are going to change for many years to come. You might very well be right on that one, but I feel somebody has to be a first, but nobody is daring to try.
I agree with the others that IDE doesn't look that good, but apparently this is from seven years ago. Would it be possible to get a newer version up? 
It's probably somewhat dependent on the environment, and my own personal experience. While I've done some development on side projects and in house utilities at small companies I'm not really a developer. I'm an electrical engineer, usually when the idea of low level code comes up we are talking device drivers or software for embedded equipment that may not really have an OS, or a very minimal one. So that's what I think of when I hear "low level".
Well, I will take that. I also tried Kdevelop before, and it is quite impressive (here it goes with more downvotes, wait). But the UI, and this I think happens to most of KDE apps: looks cluttered, they just show too much info you do not need inline. And, unfortunately, it is not stable enough. I would go with Qt vs Gtk anytime, but the truth is that Gnome is more functional, and simpler, which is a *good* thing most of the time.
Hm. OK the only routers I've had direct experience with are either home (Netgear et all) or the occasional small Cisco. The home routers these days do run a full Linux OS and the GUI and many utilities are run in user space. The Cisco you could only communicate with via a special serial cable and I found no evidence of such advanced abstractions. It was pretty close to bare metal and you couldn't execute anything outside of the shell they gave you and scripts you could write in that shell. Cisco IOS is written in C, I couldn't find documentation on IOS XR. What core routers (I.E. backbone routers) have user space applications? Cisco doesn't.
Here is a screenshot of version 5.0.0: http://postimg.org/image/v6dwr402v/ 
I'm not comfortable talking about my work on reddit, so no, I couldn't cite a specific example. My apologies.
No problem, I understand.
Yeah that's the version I care about. You can use it to bootstrap runtime reflection anyway.
You could. It's just in some situations, we actually don't want to deal with the error, and letting it bubble up automatically is convenient. As I noted (I've posted the link twice), there doesn't seem to be any performance loss in idiomatic usage; the assembly generates a single branch. IMHO, typically you "forget" to check errors mostly when you know there's nothing good you can do with them at this point in the stack anyhow. If you know you can handle an error in some useful way, you won't forget to check. That's why its nice for not-checking -&gt; exception thrown automatically.
Wow, and the issues regarding permissions that have been present since boost still haven't been fixed? Terrible.
yes. return statement is prohibited in coroutines and co_return statement is prohibited in ordinary functions.
I am unable to build it on ubuntu because cmake can not find ECM https://github.com/nsams/kdevelop/blob/master/CMakeLists.txt#L14 Any idea what this is? 
Distinct types instead of aliases, yes. The reason why you might be tempted to use a typedef is to save boiler plate code you'd otherwise need to make your user-defined type work like a double or an int (etc) -- *unless* you have access to such a library that makes "opaque typedefs" so easy.
From what I understand it's not that exceptions are too expensive, it's that you can't make real time guarantees around them. Video games are soft real time software - it's important to make sure that all execution paths can meet certain deadlines, not just the expected paths.
Challenge gladly accepted, I'm already working my way into the industry :)
I see what you're trying to get at, as I like to play osu and having under 120fps there is basically how to rage 101. But that most likely doesn't apply here, since by the time the game is actually running, you're not very likely to do operations that warrant throwing an exception.
This looks like it could be found in /r/funny/new
 Games on windows use VS. Games on Windows compile for 32 bits because everyone can run it. VS 32bit compiler does *not* implement 0 overhead exceptions. Also exceptions tend to be used all over the place for things I don't care about, such as OOM. I'd rather abort the program than waste time caring about exceptions in many cases. Also exceptions thrown from most libs seem to rarely contain useful information about why the stupid exceptions was thrown. And now the call stack is gone so I don't even know where it originated. About a 100x more useful to just assert/crash and dump a callstack so the problem can be fixed. 
So there you are, you have not installed the "pexpect" python module that was listed on the debian dependencies, and CMake is arguing about it.
Without a tag system reflection would be kinda useless for serialization. You cann't expect anyone(dealing with other apis) follow the naming conventions for c++ field names. But considering how 'cool' c++ would be with a compile time reflection and a tag system is a nice thought.
I'm really glad to see someone else doing this, makes me feel like I'm not crazy. I use this because I have a bunch of n-dimensional arrays and it is just way too easy to get indices in the wrong order, or assign a variance when you mean a standard deviation, etc. 
I'm not really sure about the complexity/benefit tradeoff here, as in my opinion exceptions make the code less complex. That's not to say exceptions don't have their set of problems, though.
There is a tag system, annotations were added in C++11. The reflection papers actually show examples using them.
The lgpl version is missing a lot of mobile features, though.
Oh wow, that's actually much better! 
Good point. Yes, that was my experience as well.
extra-cmake-modules is a KDE dependency, basically the extensions to CMake found most useful for general C++ and KDE development. It can be found at git://anongit.kde.org/extra-cmake-modules
As a random aside, I like how they used Chrome's profile renderer. Neat how you can plug in your own JSON.
I'm just run nested processing loop in process_lock where stop condition is event from sync. primitive we are waiting. But my solution will have problem with stack overflow on deep call hierarchies. 
Oh I see your point, so your issue is that there is currently no way to get the value in a safe manner (safe in the sense it throws), and still follow a throw paradigm without resorting to: if (!optional&lt;int&gt; oi = readInt()) // did I get a real int throw invalid_argument("Not an int") And I get that, just I dunno, I see optional as an interesting way to cheaply wrap return items that may return an invalid state without resorting to throws, pairs or negative ints. Having it proliferate as the standard way to returning invalid states is something I am looking forward to. And some unfortunately places just can't or won't use exceptions. I saw your link, but as for performance I'd like to benchmark. I wouldn't mind seeing a `std::safe_optional` in the gsl for those where safety is heavily enforced. The reason I'd argue for `std::optional` to be unsafe by default is some functions being so basic but may return invalid states, you don't want them to throw, and more complex functions/classes, shouldn't they themselves throw if they can't return a valid state, so therefore you never get to use the optional anyway? EDIT: inline code tags, but still failed. #newToReddit
Just an innocent question. Are you using the standard std::vector?
Nothing but a Project that include most features. By writing a complete Project you can get the grammar in a short time. Cpp is a monster if you just go through the concept by your eyes with books(However, book is important indeed ). Move Your hands and fingers and find some useful software idea.Write and Improve it is the best way to learn the one of the most complex language in the Programing.
First, cpp open source Project must have high level Programing skill or skillful in practice. It means if you were a beginner, leave the C++ Open Source Project away. Or else, you have a good teacher in the Open Source project Contributors, that was an amazing way, you can follow him/her without doubt. So whatever you choose, write something useful is not a bad way forever.
For those speaking German and C++ we have [open positions](http://www.onlinebewerbungsserver.de/WJJobs/JobList.aspx?CustID=_16_E5_E0_10_18_20_8C_0FU_14_2FA_A9D_99_9E&amp;Design=-1) at [e.Solutions](https://www.esolutions.de/en/the-company/) close to Nürnberg Germany. It's about working in Audio and Speech (and other) domains in the automotive field for brands like Audi, Porsche, Bentley etc. We recently migrated to GCC 4.9.2 and the `-std=c++11` flag is set! 
Off-topic comment: League of Legends isn't the world's most popular game. Edit: funny how this off-topic comment is downvoted, and another off-topic comment in this thread heavily upvoted. People, if you downvote because you disagree, convince me why I'm wrong.
I tried the following on VC++ 2013 and 2015: #include &lt;iostream&gt; #include &lt;regex&gt; int main() { std::cmatch results; std::regex rx("a*|b*"); std::regex_search("bbb", results, rx); std::cout &lt;&lt; "regex_search returned: " &lt;&lt; results[0].str() &lt;&lt; '\n'; std::regex_match("bbb", results, rx); std::cout &lt;&lt; "regex_match returned: " &lt;&lt; results[0].str() &lt;&lt; '\n'; return 0; } and both returned: regex_search returned: regex_match returned: bbb So I would say, yes, regex_search is behaving like ECMA (at least for this test). I tried changing the regex to `^(a*|b*)$` and then they both returned `bbb`, but I don't think this is helpful. I think of regex_search as a more complicated version of std::search in that it tries to match, and then if not it increments a character and tries again. Therefore regex_match is a simplified version that only attempts the match once and of course must additionally consume all input to be successful. I don't like to frame regex_match as the search expression with implicit anchors, because that surely has another meaning. In your `^meow$` example what if the input is `meow\nwoof`. I guess more testing using Perl and Javascript is required to show how ECMA is actually implemented, but the "leftmost" vs "leftmost longest" pattern is very well known. Personally I would prefer that ECMA changed to use "leftmost longest", but I doubt that is realistic.
They are, look at the code.
What videogame would you say is the world's most popular?
In my particular case I am working with bivariate distributions. The 5 indices are two means, two variances, and a correlation. Sometimes I have to interpolate over this space so I have a 6th index, sometimes I have to work only in mean space, sometimes I have to work with one distribution (i.e. a mean and a variance). Additionally, there are several different ways of expressing the covariance, and a couple of ways of expressing variance (one that depends on the mean and one that doesn't). I often get mixed up between whether the index order is [m1, m2, v1, v2, cov] or [m1, v1, m2, v2, cov], or whether the covariance is a covariance or a correlation index, etc. Having a type for IndexMean1, IndexMean2, IndexVariance1, etc and a wrapper type for the arrays which takes those indexes and does not accept integer indexes means I can't screw up the order at any point. Also types like Mean, Variance, etc which are all "opaque typedefs to float64" as described means I can't accidentally pass (Mean, Variance) to a function that expects (Variance, Mean) and so forth. TL;DR: The indices would be in the wrong order because I make mistakes and there are 10,000 lines of code.
Video game. My bad. 
For me the build system is an equally important factor to decide if a programming language is really worth investing time in. But indeed if he has already decided that he will learn C++, it might be less important.
If the interviewer wanted you to solve it in a specific way then they should've said that. That's the interviewer's fault; not yours.
&gt; Reflection Do you mind linking the reflection papers you talk about and mention where I can find It. Either I'm dumb or I cann't find it.
Producer/Consumer pattern? So you'd have a "tuner" object (the consumer) for each tuner that's a queue of what to record. An "episode" object which represents an episode at a particular time period. A "show" object which contains a list of the available episode objects. Once that's setup you create a controlling object (the producer) that determines what to record based on priority and inserts it into the queue of an available tuner. What algorithm you use is going to depend on what they need (e.g. As many shows as possible, all high priority shows, weighted maximum, etc). That leaves you with a number of tuners that contain a queue of what they're recording in terms of episode objects. Then dump those tuner objects into another "output" object that composes and outputs the final result. This way you get more flexibility. Want more tuners? Add more tuner objects. Want to output in multiple formats, add another output object inheriting from your initial class. Want to change the granularity of your output results from 5 minutes to 1 minute? Well now you can. Tuner 2, 4 and 7 only operate for 12 hours a day? Well now you can handle that by amending a single method in the tuner object. Importantly, and probably what they meant, is there is no array of what's happening per minute. If you want to know the state at time X then you interrogate the tuner objects and ask "At time X, what are you recording?". That's how I'd start looking at it anyway. Hopefully someone more experienced can give you a better idea. *** In terms of C to C++ I found structures were my way of grasping OOP initially. Strip away all the type/access stuff and they're basically structures containing members and function pointers.
&gt; CLion That's fairly new, have you used it? I have not had the chance to play with it, I have all I need with Code Blocks. 
Are you having difficulty finding recruits in De? Are you open to someone working remotely?
But doesn't VS C++ not true C++? Doesn't M$ have their own syntax sprinkled all over VS C++?
Surely, but the those project is still difficult to the beginner. I have ever been that yet. And the "Hack Code" always show in that Open Source Project which is messed and ambitious. Also, The Project have been clean and simple.But I have never Seen before.&lt;_&lt; 
It seems like there just wasn't much interest for it. Nevertheless, I took a stab at creating something in the same vein as rand_int, but it works with floating point types and distributions other than uniform. Feedback welcome. https://github.com/jmpac/easyrand
unless they wanted to test you on your requirement specification skills
I think those are really fun problems, but they are not going to teach you modern C++. They are more like math puzzles than they are programming exercises.
No, that's not it. If you want to be safe and use the throw paradigm you just do: auto oi = readInt().value(); My argument is simply that *, the shorter, more convenient accessor, should be safe. That some places won't use exceptions is not a justification for designing the standard library around those places. The standard library uses exceptions, that's how it is. As I've said, I'm in favor of a non-throwing, UB accessor, just call it unsafe_get or something. I don't understand, for performance you'd like to benchmark? How can identical machine code not lead to identical performance? The computer doesn't care what your source looks like. I don't follow your last point either. In any case, keep in mind that as long as you do the if check, you will never get an exception or UB. The question is only what happens if you skip the if check.
Yes but its UI is too slow for my taste. I can barely code. I prefer Qt Creator even if it is less featurefull. A very nice thing is some of the refactor options of CLion. for instance it can detect unused headers - I fired it up once only for this and spent the afternoon cleaning the headers of my project (600 files). Gained a few minutes of compile speed.
oh that's interesting. I'll have to check it out. I mean I love Resharper and I am sure CLion has that built in.
According to Raptr, LoL is the world's most played video games by far. [Link](http://www.statista.com/statistics/251222/most-played-pc-games/)
If you are bothered by compile speed try to use precompiled headers, serious improvements especially for heavy template code. Most modern compilers lets you use precompiled headers for C++.
Please don't recommend Express anymore. Community has effectively superseded it.
Last time I checked it didn't have all of Resharper++'s features. But it was a while ago.
M$: http://www.penny-arcade.com/comic/2002/07/22/
Just be ready for the long haul. You don't become proficient in ANY language, much less C++, over one book read.
So this argument of yours can be taken to *reductio ad absurdum*. Using local code for everything leads one to write an entire program in `main`. No functions, no reuse, etc... Just everything laid out in main. I've seen this kind of thing in the field. Not as bad as everything in main, but 500 line functions are not as rare as I'd like them to be. In no way is it easier to deal with that kind of thing. Splitting behavior out into separate functions is a **very good thing**. The smaller the function the better. You may think you are better at examining 500 line functions rather than 200, 5 line functions, but human minds are surprisingly similar in their weaknesses and it's simply not within the human brain biology to track through a 500 line function. On the other hand, through grouping of many smaller sections into a hierarchy of cascading calls the human brain is then able to encapsulate the whole. It's simply what our brains are good at: groupings and abstractions. So then, *objectively*--separated, smaller functions are easier for people to understand. Some programmers that didn't learn this early on will take some adaptation time where they'll feel like it's harder to understand, because they're used to doing it the hard way, but at the end of the day...human brains are similar in how they work and with only small variation everyone will find that smaller, split apart functions are easier to read, easier to follow, and easier to think about. Tag dispatching wins.
You can replace std::vector with your own vector implementation.
How much experience does one have to work with your German team? Is a few years university enough to start out? 
So should we just write a complete project from scratch?? What kind of project should we write that would best maximize the learning curve for c++?
Cool! I work on a similar project, called [HPX](https://github.com/STEllAR-GROUP/hpx).
What does the /C2 mean and did I get it right that the msvc standard library will be used and not libc++?
GNOME has better designers and better quality control. KDE is more like a perpetual hackathon.
[Slides](https://conference.libreoffice.org/assets/Conference/Aarhus/Slides/SBergmanLOCON2015-bizarre.pdf)
I didn't know I needed this until now. I wonder how hard this would be to port into QtCreator
Yes it is. No argument there. Most popular video game of all time. In fact, the gap is bigger than it's ever been, WoW used to have half the play time, but the closest at the moment is CSGO. 
That is a nifty thing that will go in my pocket for later.
Are there prebuilt binaries yet, or distribution packages? What's the easiest way to use it currently? Do I have to build from source by myself?
IMO, you should try and show the instructor Kate Gregory's CppCon 2015 talk: https://www.youtube.com/watch?v=YnWhqhNdYyk
But the code still calls a member function on null this-pointer, which is undefined behavior.
I found Clion to be really well suited for my needs. The latest version I got was pretty fast. Then again, I have a great dev machine, and its possible thats why its not very performant for you. 
If you can afford to optimize your game to deliver the best user experience possible you would do it even if it ran okay already. Also, they keep increasing the number of polygons and the quality and detail of the terrain, the original engine architecture could have potentially suffered a bit to support this. They also ported the game to iOS last year, perhaps they found a few bottlenecks here and there.
1. Does this work on windows? 2. How does it do memory allocation?
yeah, we want to do this too. lot of details to work out.
in the CTP, no. The (soon to be released) RC will have some modules support. RTM will be have even more :)
Curious, do you guys use stl or do you have your own internal libraries?
In this case yes we are using std::vector. 
First sentence: "The statistic presents the worldwide most-played PC games on the online gaming platform Raptr in August 2015, by share of total time played." You don't think this put some heavy restrictions on what is meant by 'most popular'? What about console games like Tetris, Super Mario Bros. 3 and Super Mario World? I'm reasonably well informed about the gaming community, but I have never heard of Raptr (or statista.com for that matter). Chances are they aren't as relevant as one would hope. Only August 2015? What about historically blockbusters like Tetris and various Super Mario installments? Edit: online gaming also potentially excludes some huge single player games, like The Sims installments as potential candidates. Random statistics from some website with severe limitations on it's data isn't very convincing when talking about "the world's most popular game".
In my app threads share a [lock-free small block allocator](https://qarterd.github.io/Honeycomb/Doxygen/html/classhoney_1_1_mem_pool.html), it's an auto-expanding arena/pool that allocates its chunks from the heap and holds onto them until the pool is destroyed. Freelists like these are nearly identical to stacks, so it's easy to make them lock-free. My library [Honeycomb](https://github.com/Qarterd/Honeycomb) can be linked statically but I'm currently working in OS X. ~~The Windows platform code is out-of-date but I just started on porting it back again, so it will take a few days.~~ EDIT: It now compiles and passes all tests on Windows with VS2015. Here you can see I'm just using a pool with buckets of fixed-size blocks: MemPool Id: Small Total Allocated Bytes: 1116905 Total Used Bytes: 53688 (4.8%) Block Header Size: 48 Bucket Count: 7 Bucket Blocks Used: 255 / 13800 (1.8%) Bucket #0: { Block Size: 8 Block Count Expansion: 5000 / 5000 (100.0%) Allocated Bytes: 280007 (25.1%) Blocks Used: 0 / 5000 (0.0%) Avg Block Fill: 0 / 0 (0.0%) } Bucket #1: { Block Size: 16 Block Count Expansion: 5000 / 5000 (100.0%) Allocated Bytes: 320007 (28.7%) Blocks Used: 78 / 5000 (1.6%) Avg Block Fill: 1248 / 1248 (100.0%) } ... 
Technically yes, but it's quite frowned upon to add your own stuff to the std namespace, so they probably didn't.
The Chrome tracing tool looks really cool. Will any standard profiling tools (obviously I don't have access to Riot's in house tools) generate data that one can read into Chrome?
Curious, what performance reasons? It seems to me that most things can be solved with std containers plus the boost::flat_* containers. 
Alright, what does k-relaxed mean?
I started writing this a year ago and have worked on it off and on. It is not feature complete but can do tcp servers, include higher level HTTP on top and some json routines to pull data in/out. The core is in the Event Emitter that everything goes through. It was inspired by Node.js but isn't strictly keeping to it.
You are spot on there. The reason I'm posting about this it is the most common issue I see when profiling - most programmers focus on instructions, not data. I'm hoping that raising data's profile (excuse the pun) as a performance bottleneck will help some people make better decisions about their data and thereby help with performance.
If you want to do a subset of useful things, I do not mean an integrated book, learn: - Basic data types. - Basic control structures: for, while, if, do-while and switch. - Value types and copy/move semantics. - *RAII* and scopes. - *std::vector*. - Basic iostreams for input/output. - Unordered map. - classes special functions. - new/delete, to understand how it is used in *RAII* containers. - smart pointers. - range based for loops. - virtual functions. After these, you can move to more advance stuff. For example: - Generic programming. - Type traits. - lambdas/std::function. - iterators and algorithms. There is much more than this, but with that you can do a lot. Some recommendations: learn with a command line and a basic text editor, do not feel tempted to use an IDE at first. You will be glad you did it later. I recommend to use gcc/clang over Visual Studio for learning. It has more extensive support for C++11/14. You can always learn what is missing in Visual Studio later. There are three standards: C++03/C++11/C++14. It is safe to stick to C++11, you can even go for C++14 in my opinion. But as a default, C++11 is stable and will teach you 90% of things. If you need to look for some documentation, go here: http://en.cppreference.com/w/
That very much mirrors my experiences trying to build RapidCheck on GCC 5.x... 4.9 works fine but 5.x just gives me internal compiler errors on various things. To me it doesn't feel like a release quality compiler.
There's [packages available](https://software.opensuse.org/download.html?project=KDE%3AUnstable%3AExtra&amp;package=kdevelop5) for openSUSE in the KDE:Unstable:Extra repo. It looks like it's [only working for Tumbleweed](https://build.opensuse.org/package/show/KDE:Unstable:Extra/kdevelop5) at the moment though
Ok. I'll just wait a bit then, no time to bother with building at the moment. Thanks for the info! :-)
Why don't you just try KDevelop then ;) Granted, it may not be available on Windows, but then, if you applications are platform independent, developing on Linux is a pretty good choice anyways :-)
To be honest, I was anticipating the article would be about Doom. This is a programming forum.
Yay! I'm really looking forward experimenting with them in my codebase. I'm planning already to use the Clang version next week and hoping for some nice speed increase!
I actually did watch it. Nevertheless, I am just a TA ... and the teacher is teaching C with class... I try to teach them the C++ way but it is hard when the teacher focus on C stuff. 
Missing properties and class helpers in c++, all other is very great.
I highly recommend solving a real world problem as a way to learn. Start small and get big, so maybe something like listing all the files in a directory and printing them out, except that any .h or .hpp files are printed out with their matching .cc/.cpp/.c++ file. Then maybe do "smart" listings for other languages, so show only .py files but not .pyc, or recursing through a filesystem and finding all the uncompiled .java files? In addition to your desktop computer, Arduino's in the development environment, support C++. An Arduino, a switch, a resistor and an LED can make for hours of quality project time. Plus it's an interesting look at how C++ can fit and work with bare metal. Something that you can do with Java, but not quite as easily. Also, make sure that any materials you use are recent. C+11, especially in memory management, made some big changes, so a C++ book from 2010 might not be useful. Some really cool things in recent CPlusPlus that might make life more interesting are the regular expression library, initializer lists, the use of the auto keyword, more concise iteration, and lambda expressions. 
That's next, lost an hour yesterday when I used putty to test the server and it looked like my buffer was uninitialized. Turns out the telnet protocol has a bunch of control characters and I was seeing this. It was a nice doh I knew that moment. Raw mode in putty does the trick
I've worked on a large 3D model application, and you're completely wrong, having a CLI was utterly key. At the end of the day, every button, every mouse click is just a event fired. You can open up the command history and copy and paste the commands into plain text file, and feed them into the CLI interface and have it do the exact same thing.
This should be constexpr. Also...what does this have to do with c++? Just because something is written in c++ doesn't mean it belongs in this sub. Or maybe OP is just trying to get exposure for his site. **EDIT:** Just checked OP's posting history and this is clearly the case.
For anybody who wants to read more about the basic idea here, Googling (or whatever) for "Zeller's congruence" should turn up a fair amount.
Is Oklahoma considered the midwest?
Apparently just barely not! TIL.
This gives the wrong answer prior to March 1st, 1BC. It says this day is a Wednesday, but the preceding day is a Saturday. (The year 1BC has the number 0 in the proleptic gregorian calendar. You can duplicate my results by looking at `GetDayOfWeek(0,3,1)` and `GetDayOfWeek(0,2,29)`.) You can find more calendar algorithms [here](http://howardhinnant.github.io/date_algorithms.html), including discussion of all the tricks involved. [Here](http://howardhinnant.github.io/date_v2.html) you can find a date library built on those low level algorithms.
Seems you've found the appropriate subreddit for your submission, why not delete this and save everyone time (specially the mods)?
Yey, awesome! I used Visual Studio extensivly when I was a student for C++ and was thrilled, and the profiler is awesome too. Now, just recently I discovered I can use it for python too! I have yet to see an IDE that compares both in a proper dark theme (my god Eclipse, why, whyyyyy), code completion, and supporting so many languages out of the box.
Herb and Neil mentioned there may be some of the GSL support in this update, is that still the case? 
GSL ships outside the core VS schedule. it's coming. - Steve, VC Dev Mgr
Qt has a bunch of pointers to a bunch of different things; QSharedPointer uses an external reference count, while QSharedDataPointer refers to COW (I think?) QSharedData objects, and QPointer is a non-owning pointer semantically similar to QWeakPointer. It's a mess, and reinventing functionality that is already present in the standard library and the language itself is a bad practice in general and really turns me off to Qt from an API standpoint. Anyway, the point I was making was that heap-allocating everything like in Java and C# is a terminally stupid thing to do in C++, even if you use garbage collection, refcounting, or some other strategy to avoid memory management; if you choose to ignore the possibilities offered by value semantics, stack-allocation, and deterministic destruction, you're throwing away most of the performance and stability benefits that C++ offers over those languages, not to mention RAII in its entirety.
Gabriel Dos Reis (I think) promised us support for modules in the Update 1 timeframe, is that still coming?
Here you go: [Microsoft Visual C++ Build Tools 2015 Technical Preview](https://www.microsoft.com/en-us/download/details.aspx?id=49512) &gt; This is a pre-release for Visual C++ Build Tools 2015, which provides the required tools for building C++ applications and libraries targeting Windows desktop. If you want to build your C++ projects targeting Windows desktop without having Visual Studio installed on your computer, Visual C++ Build Tools 2015 provides C++ compilers, libraries, build scripts, and Windows SDKs. &gt; PLEASE NOTE: This Technical Preview has not been subject to final validation and is not meant to be run on production workstations or servers. It ships with the same C++ compilers and libraries packaged with Visual Studio 2015 Update 1 RC (2015.1). For more information on Visual Studio 2015 Update 1 RC (2015.1), see the Visual Studio 2015 Update 1 RC Release Notes and the Visual Studio 2015 Update 1 RC MSDN Article. What it's unclear is the licensing. How can you use this in an organisation? How many users can you have?
&gt; It's a mess, and reinventing functionality that is already present in the standard library and the language itself is a bad practice in general and really turns me off to Qt from an API standpoint. QGuardedPtr was there in Qt 2 which was out in 1999. 
Is there a list of newly supported C++11/14/17 features?
Didn't work for me either. Same error.
And extensability. It's one of the things I love about VC. You get so many cool extensions.
Sounds like an extension issue. VS 2015 very rarely crashes for me.
Have you ever tried any IntelliJ IDE, Clion in particular? I've fond they offer a similar experience, plus more advanced refactoring. 
Kudos for including Solaris; I code cross-platform for Linux/Win/Solaris, and Solaris is very much a forgotten stepchild these days.
But we were specifically discussing WINAPI, that's what my comment answered to. Also, having dealt with MFC I honestly think it causes more harm than good. Qt is the only sane option.
I've found lots of information about how to implement the algorithm, but almost nothing to gain insight to how it actual works. Why does it works the way it does? What is the congruence of the days from feb to jan? EDIT: searching on "Zellers Rule" gave me the following results: http://mathforum.org/library/drmath/view/62324.html http://24x7interestingfacts.blogspot.be/2008/09/zellers-rule.html
Qt isn't a weird tangent at all. It's an example of a complex and old bit of very important C++ code most D users would want to leverage sooner or later.
Yes, the static analysis tools show in Herb's keynote will be released in November. The lifetime analysis checkers probably won't be in the first release of the tools (as mentioned by Neil in the keynote, IIRC) but should follow soon after.
Yes, the static analysis tools show in Herb's keynote will be released in November. The lifetime analysis checkers probably won't be in the first release of the tools (as mentioned by Neil in the keynote, IIRC) but should follow soon after.
very good news, thanks!
Aside: anyone know why reddit keeps picking these random pictures for my links? They have nothing to do with it.... they are just the pictures of some random person on meetup who has RSVPed to the meetup.
As I understand it (I haven't installed it myself in a VM), the toolset SKU is like my distro, except (1) just the essentials (no third-party libraries or utilities), (2) distributed via an installer, instead of pure extraction. Every day at work I build and run "vctools", which is basically the contents of the toolset SKU (minus the CRT and WinSDK which are built by the Windows division).
Are there any new flags since Gabriel's talk? Any documentation past what he showed us? I'm pretty interested in taking it for a spin when the update rolls out.
You filed the bug I hope, otherwise it may not be fixed!
Thank you very much for that. It will improve a lot of people lives. And, it merely took you 27 years :D
It is called cargo cult programming. For them the act of coding is to worship the paradigm by following rigid rituals, instead adding value and features to the product. 
And as I listen to this I'm reminded of another thing. Someone needs to take away all the desk toys and pens from the hosts. Those sounds are annoying.
tagging /u/roschuma , Robert can you take a look?
I always see an awful lot of job ads from e.Solutions and similar automotive supplier companies. Always makes me wonder if they are just having a hard time finding acceptable people or if nobody wants to work for them for whatever reason.
Thanks for the feedback! I've just added it to the issues list: https://github.com/zed0/clang-format-configurator/issues/2 If you have any further suggestions or bugs feel free to add them!
From my experience, VAX just turns every . to a -&gt;. To be fair, it's right 90% of the time...
if you have a repro for a crash in update 1, i'd love to know about it. - Steve VC Dev Mgr
Post here: http://reddit.com/r/cpp_questions Or probably even better here: https://www.reddit.com/r/learnprogramming
You're probably using the CTP on accident. I'd describe that build as "the lights are on but nobody's home." I just installed the RC on a fresh machine and here's what I'm getting: http://imgur.com/Hx6lq7o That said, if you're still having issues, please let me know and I'll try to fix it! :)
correct. we are tracking our progress on range-v3. We'll definitely let folks know when it starts working. This is in the category of "things I care about a lot" :) - Steve, VC Dev Mgr
I think C# uses a lot of stack allocation, but I don't really know much about it.
yup, you're right quantity &gt; quality
But [elsewhere, Steve mentioned that this update will not contain the tools](https://www.reddit.com/r/cpp/comments/3qry9b/visual_studio_2015_update_1_rc_available_visual_c/cwi2w9z). Is that incorrect?
Works now.. 
I could hug you for the fact that you're tracking your progress by compiling range-v3.
Why don't you like Visual Studio?
Well that's cache too, really. Among other things.
I'll have to try it with update 1. I was going to try it again the other day, but the auth servers were down so I couldn't run VS. There's no workaround for that, is there?
We are both right. :) The checkers can go out independent of VS. We are going to try to ship them at the same time, but one does not determine the other. 
This is neat! Does anybody know how to configure it for whitesmith alignment? i.e. for (....) { // yes indented code with same indentation } Although, I was looking for a way to force the break before the first parameter if the parameter list is scattered on several line. i.e. instead of some_function(param1, param2, ... paramn); How to have this ? some_function( param1, param2, ... paramn); 
Visual Studio with Visual Assist.
I too like to format using Whitesmith.
Is there any documentation on how to use modules? I'm trying to find something on msdn, but everything reffers to a different type of modules. Also is it possible to use modules inside VS or is it command line only?
I give some C courses and some C++ courses. Here are some remarks. C is not hard to learn. There is almost only one way to express something with the language. There is no issue with the pointers. Students understand that it points to somewhere in memory. There is no issus with [] C++ is really hard to teach. There are always a lot of ways to do the same thing. Vector is an evil data structure. Students have a lot of problem to use it, because of the resize, reserve, push_back and random access. The hidden copy of objects is also a mess. In students' code this is without any doubt the most buggy part. Such problems do not happen with simple array Now, people who have never taught C and C++ can strongly downgrade this post. 
Easy to say. Totally unrealistic. Do you really think that it is better to learn a language without understanding any of the ground concepts like pointers? That's a really strange point of view... It is like learning mathematics without considering + or *, but just operator with their properties and then groups and so on...
Ah the old install/gut/uininstall visual studio dance. A waste of time and bandwidth. If anyone wants a copy of the VC directory pm me. Also, if anyone knows anyone on the VS team, please tell them to shove their SQL server up their ass, I don't want/need it, and frankly am insulted every time it installs itself without asking,.
the best is vi
We did take away my pen several episodes back - I have no idea what you would have been hearing in this episode. 
Which os? 
Just about everyone I know who's used it on a larger project with sophisticated C++ has described ctags as "not awesome", "80% reliable", etc. I don't think it's parsing is very sophisticated compared to many other tools. 
I'm a big fan of clion. Which is free with a .edu address
I got one too: http://github.com/activemesa/blackmire
I skimmed through and found an instance of what I was talking about in this latest episode. It's at roughly 46 minutes in. It sounds kind of like a small slinky. It's nowhere near as bad as Pengate was but once I noticed it I couldn't stop hearing it (particularly because I was wearing headphones). I just realized it could also have been Andrei though. I hadn't heard this sound in other episodes.
You too are a horrible person.
have you seen dlang.org?
There is a link to dlang.org in the show notes.
I have used it in release mode, it works 4 sure. Really nice tool.
&gt; std::string f(...); // Variadic functions are so "untyped" that... &gt; template &lt;typename T&gt; std::string f(const T&amp; t); // ...even a templated function got the precedence! This indicates a significant misconception. Many people believe that ordinary functions are preferred over function templates, which is incorrect. What happens is that name lookup, template argument deduction, substitution, and overload resolution run (in that order). If a function template produces the best match, it wins outright. Only if an ordinary function and a function template are *equally good matches*, does a tiebreaker rule step in, and select the ordinary function. This is significant because templates often produce very good matches (especially if they're perfect forwarders). For example, `meow(const string&amp;)` versus `meow(const T&amp;)` called with `meow("kitty")` will select the template, because it'll be an exact match (`meow(const char (&amp;)[6])` will be instantiated), which is way better than a user-defined conversion to `std::string`. `purr(int)` versus `purr(U)` given `purr(1729L)` will select `purr(U)`, again because the exact match (`U` will be `long`) is preferred to the integral conversion required for the ordinary function. It is true that C varargs are considered the worst conversion by overload resolution (worse than UDCs, which are worse than standard conversions), but that's a separate issue. &gt; template &lt;typename T&gt; void f(typename T::B* b) { } This example isn't demonstrating what you think it's demonstrating. Here, T is in a non-deduced context (double colons are brick walls to template argument deduction, which can't see to the left, by design). So T is simply not deduced, which prevents the templated overload from being considered. For a SFINAE example, the signature `hiss(const T&amp;, typename T::iterator)` would be an example. `T` would be deduced from the first arg, not from the second (non-deduced context again), then substitution will fail if `T` is `int`. &gt; If you want to check the full code of this C++98 version No - your hasSerialize is using C++11 Expression SFINAE, not C++98/03 Classic SFINAE. (`&amp;C::serialize` is an expression.) This is important to understand for anyone who cares about the difference (notably, anyone using VC right now). The sizeof stuff is old-style. Nowadays we use decltype, true_type/false_type, and void_t. &gt; declvar is really handy for our SFINAE constructions. Try to avoid typos when naming code. It is important to point out that `auto`'s use as a placeholder in trailing return types is completely disconnected from its meaning elsewhere. This keyword reuse was not an especially good idea. Sigh. &gt; constexpr gave birth to two pre-defined types in the STL: std::true_type &amp; std::false_type. No - integral_constant long, long predated constexpr. It has been enhanced with constexpr, but your history is backwards. It's really important to understand that `auto` decays and `decltype` (and `decltype(auto)`) doesn't. &gt; auto l1 = [](B&amp; b) { return b.serialize(); }; // No clear return type. What? It is perfectly clear. It is the decayed type of whatever serialize() returns. &gt; int operator(int a, int b) Notably, lambdas have const function call operators by default. Also, you forgot (). Try to present fully worked examples that have been compiled. Experienced programmers can mentally error-correct problems in examples; novice programmers can't, yet they're the ones who examples are meant to help. &gt; If you are a bit lost at that point, I suggest you take your time and re-read all the previous example. I really don't think this is a good way to introduce metaprogramming. It is too much, too fast, and makes people recoil from the complexity. I prefer to start Metaprogramming 101 with tag dispatch, which is straightforward and has many practical applications.
He wasn't talking about types, he was talking about classes. Not all types are classes. Sometimes, what you need doesn't even have to be a type. Instead of a stateless singleton, something as simple as a namespace may be just as suitable.
Search for nightly builds on their forums.
Well, I downvoted because your statement didn't include anything useful for this discussion. Just blame.
Thanks STL for this really good feedback! I will start with the last point and then continue with all the others in your order! * I tried to work on an article that explained few points I struggled with when learning more about TMP. I tried to use my own wordings for helping future readers, but this post doesn't have the pretension to be accurate (even though I would like to be able to). I had two friends that read this article. The first one has a really good knowledge of all the subjects. The second one has a strong background in computer science but not so much in C++. I think he enjoyed the first parts, it made him discover some new concepts. He will most likely attack back the article if he acquires more knowledge on other supports (I will forward him your suggestion). All of this to say that I had a hard time to find the best between full explanations with a lot of vocabulary and some loose explanations but easy to grasp. I will try to use your feedback to fix some points, but "what happens is that name lookup, template argument deduction, substitution, and overload resolution run" looks for instance a bit too deep. * I will replace the first point with "Variadic functions are so "untyped" that... this templated function got the precedence!", and fix the few other inaccurate sentences. Thanks! * Good point on my broken SFINAE example! Thanks again! * I played with clang flags to check my code compliance regarding C++ versions. Looks like I was fooled. Tack! * I agree that the 'auto' usage to delay the specification of the return type is really weird. * Does cppreference is wrong about integral_constant? http://en.cppreference.com/w/cpp/types/integral_constant * By "// No clear return type.", I wanted to say that the type isn't specified by the coder! It's not clear what would be the type until the return statement. It's misleading, you are right! * I will fix my unnamed types' operator()! Thank you! As you read, I provided gists that run, expect for few example I didn't try, I punished myself there. I am French with bad language skills even in mother tongue. Please feel free to show me my mistakes! Last but not least, I felt kinda bad after reading your kind feedback for my jokes on MSVC. I actually spend most of my time using Visual Studio ;). My sincere gratitude to you guys!
Did you guys fix the installer? It currently packages a bunch of junk of little interest that often fails at installing, correctly. For example, it doesn't install on some of my machines due to nuget problems. https://connect.microsoft.com/VisualStudio/Feedback/Details/1856767
&gt; I played with clang flags to check my code compliance regarding C++ versions. Looks like I was fooled. Tack! Clang and gcc both keep expression SFINAE enabled when using C++03, because it is still considered conforming. However, pre-C++11 compilers did not support expression SFINAE. If you tried your example on gcc 4.2, it would not work. &gt; Does cppreference is wrong about integral_constant? The `integral_constant` class comes from Boost.MPL library(see [here](http://www.boost.org/doc/libs/1_59_0/libs/mpl/doc/refmanual/integral-constant.html)). Being almost 15 years old it predates the existence of `constexpr`, which was first proposed in 2007.
&gt; I've found that void_t has made TMP much easier for me. `void_t` is nice, but I find it too low-level. Its nice for building some high-level abstractions such as Hana's `is_valid` or `overload_linearly`. However having those functions available, I rarely find a need to use something like `void_t`.
For me it's the UI. My benchmark is visual studio's dark theme. To be fair though, kdevelop's dark theme is light years better than Eclipse's, which is why I don't use eclipse. Visual studio dark theme: http://i.imgur.com/nWQ7LNQ.png Kdevelop dark theme: https://www.kdevelop.org/sites/kdevelop.org/files/photos/kdev_python_8.png
Qt Creator is a best choice, or else Kdevelop-5.0 is also amazing 
This kind of compile time introspection is a very versatile and powerful technique but like with everything else in C++ you need to be aware of when doesn't work as expected. In this case it's incomplete types. Especially when you use the introspection to differentiate between multiple implementations depending on the availability of certain operations you need to make sure that the instantiation sees the complete type of whatever is about to be introspected or it might compile fine but still do the wrong thing. One way to ensure this is to graciously insert sizeof(T) into all your introspection constructs to make sure that the compiler will generate an error in this case. static_assert( sizeof( T ), "type is incomplete (don't forward declare, include the header!)" ); 
To be fair, I wouldn't take anyone with a "Grand Master" certificate seriously. You are better off without it.
Couldn't care less about the "certification". The idea to have a clear schedule of weekly exercises and material is what really appeals me. 
It's not that I don't like it. In fact, I like it so much I've been answering their surveys with things such as "leaner VS" and such. I don't like my machine.
In my opinion, it looks actually quite cool. Direct link: http://www.cppgm.org/
Please consider either creating an official way to move the Package Cache directory, or at least stop killing the junction point I create. I have a small SSD for the critical files I use and a huge slow rotary disk for the other stuff. Right now your completely unneeded setup files (all tens of gigabites - I have to use all VS versions starting with 2010) sit on my SSD. I understand their purpose and what scenarios they serve, but still, they take precious space on today's small SSD drives.
Good suggestion! That will be added somewhere in the article. 
wow, ok. How did you find out?
Not yet. This idiom is part of a larger whole, which is the paradigm of using values for type-level computations. For example, the fact that `is_valid(...)` returns an `integral_constant` object would be surprising to most, and definitely clashes with the way things are usually done in the standard library right now. One would expect `is_valid` to be a `constexpr` function returning `bool`, but that would be useless because function call strips off `constexpr`-ness. I feel like properly introducing this in the standard right now would be premature. I think we need a larger proposal that basically standardizes parts of Hana, like algorithms on tuples and arithmetic operators for `integral_constant`s. However, writing such a proposal is a big task and I don't have the time to do it right now. But I'm graduating in December, so maybe we'll see something during this winter? I can't make promises :-). 
&gt; Anyway, I was blown by Hana and I am really glad to see you here! Thanks a lot! Also, a nitpick: Your link to Hana's documentation in the introduction of the article is broken. It's my fault; I had to move the repository on GitHub to make it part of the Boost organization, but that broke my GitHub Pages. Please link to `http://github.com/boostorg/hana` instead. 
In his presentation at cppcon14, the author of `void_t` essentially encouraged people with good ideas to contact him for writing / presenting joint Standard proposals. 
I will change this and the other tweaks as soon as I reboot on my debian! Thank you!
I am a huge proponent of every class having a default constructor and a default-constructable, stable, defined and specified state; whenever possible, of course. That way, we can just say that the moved-from object should, by default, be reset to that state, and we're golden. 
Well, the assignments are still there, so you can step through those.
Actually, a better solution would be to use `hana::overload_linearly`: template &lt;typename T&gt; std::string serialize(T const&amp; obj) { return hana::overload_linearly( [](auto&amp; x) -&gt; decltype(x.serialize()) { return x.serialize(); }, [](auto&amp; x) { return to_string(x); } )(obj); } The extra `is_valid` is not necessary. Even more, since you just pass `obj` on to the lambdas, you can just make that the function as well using the [Fit](https://github.com/pfultz2/Fit) library: FIT_STATIC_LAMBDA_FUNCTION(serialize) = fit::conditional( [](auto&amp; x) -&gt; decltype(x.serialize()) { return x.serialize(); }, [](auto&amp; x) { return to_string(x); } ); 
For custom UIs, QML (Qt's declarative UI language) is by far the best UI toolkit I've worked with, and I suppose it fulfills most of your requirements, except being pure C++. Honestly though, working with UI directly in C++ is a huge pain compared to a declarative language. I believe the Qt Charts component is only available for commercial licensees, however. Without more information, I however question your decision to write the game in C++. By your description, I get the impression that it will in no way be performance sensitive, so you could potentially save yourself a lot of trouble by choosing a more pragmatic language/toolkit. That said, I am no game developer so take my opinion with a grain of salt.
Well, the article was about how to do these things, for those who are interested. A quick intro to Hana would be a good article, but it's not the article the author chose to write. Hana is great, but it's not in the standard and probably won't be anytime soon. It's not even included in boost. To boot, according to the github page: &gt; API stability is still not assured I do some TMP, but not a whole lot. When I need to do a small task, here are my options, in a real life company: 1. Write 20-50 lines using void_t, which I know how to do and will get working in very little time. 2. Talk to my boss about introducing a boost hana dependency. Which will have to go up the chain, will necessitate a discussion with the guys that package up third party dependencies for deployment purposes, etc etc. Which would you do? I take your comments with a grain of salt not because you are the author of Hana, but because you seem to be ignoring practical considerations. The bottom line is that in 2015, it's well worth knowing about void_t. So it's not outdated. I hope Hana is included in Boost releases soon, as that will make it much easier to use in the wild.
I'm getting pissed off by IDEs hijacking my project directories and dumping dot files and project files in the top level. If you ever use more than one IDE its a bitch. Oh, and good luck creating a project under a subdir and getting it all to work correctly. Pain in the ass.
What about CEF? You have the power of HTML5 and Javascript and you can leverage the rich selection of JS UI libraries :). It's a bit bloated and heavy (basically shipping chromium with the game) but if your game is all about UI then it might be wort it. Edit: CEF = Chromium Embedded Framework
I've seen QT Charts and it sounded awesome, but it wasn't open-source, so... crap. 
Yep, probably too heavy for mobile. Not too slow on PC though.
That kind of game screams for strong static typing though. 
I saw somewhere that you had to implement most of a C++ compiler to finish it. Anyone who can do that I would take seriously.
There is KD-Chart which is dual-licensed under GPL and commercial, like Qt : http://www.kdab.com/kd-chart/ (You have to go to "Download trial now" and register to get the gpl version)
Well... that's just like, your opinion, man.
That's right. [I've been meaning](https://github.com/boostorg/hana/issues/115) to change the example included in the documentation so that it reflects the advantages of `is_valid` more clearly. For "simple" conditions like this, your solution is probably better. Where `is_valid` comes in really handy is for example when you have complex conditions: auto has_X = hana::is_valid([](auto&amp;&amp; a) -&gt; decltype((void)a.X)) { }; auto has_Y = hana::is_valid([](auto&amp;&amp; a) -&gt; decltype((void)a.Y)) { }; hana::if_(has_X(obj) || has_Y(obj), [](auto&amp; x) { /* do something */ }, [](auto&amp; x) { /* something else */ } )(obj); I suppose this would be harder to achieve with `overload_linearly` (I can't think of an easy way right now). 
Not by choice :(
&gt; That is neat stuff, thank you for your post. My pleasure! I'll be glad if it can sometimes make your job easier. &gt; I'm curious, is there an article or talk where you go into detail about the pros (and cons?) of value syntax for TMP? I don't think there's an article or talk in which I go into very specific details or present an exhaustive list of pros and cons. However, my talk at [CppCon 2015](https://youtu.be/cg1wOINjV9U) would probably be the best start. When (if?) the [videos of C++Now 2015](https://www.youtube.com/user/BoostCon) are uploaded, you might want to take a look at it. It's essentially the same as my CppCon talk, except it's 1h30 and targeted to a slightly different audience so I go into a bit more details. Off the top of my head, here's a small list: Cons ---- - Incurs a larger compile-time overhead. Indeed, the compiler has to do more work because it has to instantiate the body of functions to deduce their type. In practice, this should be counter-balanced by the fact that metaprogramming in C++14 is much easier than in C++03, so you have less of it and the compile-times are thus much better. But strictly speaking, your type-level computations written with value-level syntax will take longer to compile than if you had written them using old-style TMP (e.g. [MPL11](https://github.com/ldionne/mpl11) or Eric Niebler's [Meta](https://github.com/ericniebler/meta), which are super damn fast). - Lack of compiler support. Indeed, doing almost anything with this paradigm will require generic lambdas, which bump compiler requirements quite a bit. - Lack of interoperation with previous metaprogramming libraries. If you write old-style metafunctions, you can use them as-is with Boost.MPL, Boost.Fusion and most existing C++ libraries. If you use this new paradigm, you're basically on your own unless you use Hana. Pros ---- - The syntax looks sane and natural. - It's easy to compose computations into larger ones using lambdas. It's easier and has fewer pitfalls than writing Boost.MPL LambdaExpressions IMO. - Higher-order algorithms look more natural. If you compare for example `hana::remove_if` and `fusion::remove_if`, Hana's `remove_if` looks much more like `std::remove_if` (modulo iterators), while Fusion's is a different beast. - You can reuse _some_ of your metafunctions to do some runtime computations. But this is only really a small subset of the metafunctions that you'll write. Mostly metafunctions doing some kind of arithmetic. That's not exhaustive, but it still gives an idea. 
The use case for `is_valid` is when you want to expose type requirements to the user for them to use, and the type requirements are not just as simple as a few valid expressions(like what is done for iterators). However, if you or'ing them together it is because you are using(or should be using) an overloaded function. That is the above could be written like this: FIT_STATIC_LAMBDA_FUNCTION(get_element) = fit::conditional( [](auto&amp;&amp; a) -&gt; decltype(a.X)) { return a.X }, [](auto&amp;&amp; a) -&gt; decltype(a.Y)) { return a.Y }, ); template&lt;class T&gt; void foo(T&amp;&amp; x) { fit::conditional( [](auto&amp;&amp; x) -&gt; decltype(get_element(x)) { std::cout &lt;&lt; get_element(x); }, [](auto&amp;&amp;) { std::cout &lt;&lt; "no element"; } )(x); ... } And it seems to make more sense to use a function to unify distinctive type requirements than to write a bunch complex conditional logic. There may be cases for it, but I have yet to see it. &gt; I suppose this would be harder to achieve with overload_linearly (I can't think of an easy way right now). The above can't be achieved with `overload_linearly`, so for your example in Hana `is_valid` has to be used(unless you want to show how to do it using `fit::conditional`).
They're not entirely mutually exclusive. One of my projects started with standard QML for prototyping and has moved onto a ruby based pseudo-QML for actual development.
Ah, I was wondering which company it was. A recruiting gimmick was my only plausible guess for what it actually was, but they did a good job of hiding who it was for.
With exception handling, there's always a catch.
Heh, atleast you tried
How's the performance of that? Do you have any articles on the topic?
Unless you use a custom smart pointer. 
No articles, it's just part of my open source side project. It involves drawing three curves and a polygon representing the three color and one luminance channels at 128 brightness levels. This is the code that is called inside a Canvas item: https://github.com/CarVac/filmulator-gui/blob/master/filmulator-gui/qml/filmulator-gui/generateHistogram.js It just queries a c++ function for the values it needs. It seems to be fast enough...? When resizing the toolbar with the histograms (there are three in the toolbar along with various other tools) it evidently is able to render them at 60fps. I haven't investigated its performance too closely (profiling and such) since it has always run plenty smoothly. 
Yes, a module is a collection of translation units (roughly source files.) So, you can (and it is expected that you) build a module out of multiple C++ source files. If you have an existing build infrastructure where you set dependencies based on header files, you can continue with that system if your header files corresponds to interface files. No build infrastructure change required. The additional bit that the MSVC setup brings (and I hope other compilers will provide similar functionalities) is that you can now set the dependency only on the build artifact that matters the most, the IFCs, for interface consumption instead of myriad of header files, and increase both componentization and build parallelism among consumers of a module. As this is new era for C++, it is expected that some time will pass before compilers set on dedicated extensions of module interface files (that do not have `.h` extension) and systems like GNU Make provides internalized correspondence between such extensions and automatic rules. However, it is my hope that such time won't be too long, as modules are important and often requested features of C++. 
As you've seen from the various trip reports from the Fall 2015 Kona meeting, the C++ Evolution Working Group voted to have the core of the module proposal (as presented in the Spring 2015 Lenexa design, modulo a couple of issues such as strong ownership and ability to assert that a different module exports something) to a Technical Specification. That is one good, positive step for the C++ community. There will be an update of "formal specification" in the Kona post-mailing, and also an update before the end of the year (most likely near end of December). A good way to help is to convince your favorite compiler providers to start giving you access to an implementation of the specs, which in turn helps provide concrete reports from the field. Yes, convincing your representatives in your National Body delegation on the ISO C++ committee also helps :-) 
The C++ Standards already says that include files are mapped in *implementation defined* manner. I expect compiler writers to exploit this latitude to its fullest extent (they already do this with PCH supports) in presence of modules.
Finally!
They offered a possible Google interview for the ones completing their own C++-related interview/exam (which was a surprise at that point, since all previous assignments were coding-based).
C++ Qt Widgets doesn't use accelerated graphics. So the animations don't run faster than in QML. (if there is something slow in the application logic then it's not a GUI problem)
Come on, unwind a little.
Think like a computer. That's not exactly helpful advise; but you have to be able to have a somewhat clear idea of what you're being asked to do and how you should best do it. try to get a clear idea of what exactly your algorithm should do and how before starting to write a single line of code. . Writing algorithms and codes will help. Something like competitive programming more-so. Anything that lets you program under a bit of pressure helps you get into the mindset of debugging code in your head as you write it. . Coding is 90% in your head (statistic not verified nor accurate). The more you learn to think logically the better you can code logically. 
Sounds like you just got a bit flustered by the interview and weren't able perform properly under the stress. I wouldn't bother to necessarily try and overcome this particular case; I assume you're writing code all the time and will only get better. What you need is more interview practice, so that when people do throw an unexpected trial at you, you remain calm and slowly solve the problem.
Having to solve a problem during an interview also often serves not as a skill check, but as a way for the interviewers to see how you work and how you approach problems. Demanding syntactically correct C++ on a whiteboard is just a silly waste of everyone's time, though.
Get a strong understanding of iterators and the `&lt;algorithm&gt;` header. I've found that the concept of a `begin` and `end` iterator has helped me catch tons of edge cases, sometimes even _implicitly_ by an algorithm! (I always get a warm fuzzy feeling when this happens, hehe) Knowing the algorithms means less time reinventing the wheel during an interview, and more time showing your interviewer that you really know your C++. Here are a few motivating examples, n.b. how _clear_ the implementations are and how _few_ loops are hand-written! * [find next permutation of a sequence](https://github.com/thatbrod/CppSamples-Samples/blob/master/1-common-tasks/algorithms/next-permutation.cpp) 0 hand-written loops * [reverse sub-sequences of a sequence](https://github.com/thatbrod/CppSamples-Samples/blob/master/1-common-tasks/algorithms/reverse-by.cpp) 1 hand-written loop * [find the mode(s) of a sequence](http://coliru.stacked-crooked.com/a/b957331e7b13cd2d) 1 hand-written loop With enough practice and knowledge on the STL you'll find that C++ can be as expressive as modern scripting languages while maintaining all of it's famous speed :)
If the interview is specifically for a C++ programming position, then it's a completely appropriate thing to do, because C++ is a very nuanced language, and you can easily identify an expert versus a novice based on things like how they employ pointers versus references, how they use (or don't use) const-correctness, or whether they're comfortable writing a template to make their code reusable. Edit: Now whether this should be done on a whiteboard versus in an IDE is another matter.
Try being a bit more humble...demanding correct c++ code on a whiteboard does not mean that the interviewer is a lazy, arrogant asshole but rather that you were not properly prepared. It's not an uncommon requirement and can be trained by coding exclusively in gedit/notepad for a few days.
 thanks!
[try libRocket](http://librocket.com/) Documentation is severely lacking and it uses ref-counting *without* RAII but that can be solved quickly with some wrapper code. It allows you great control over rendering and uses a HTML/CSS dialect for layout/styling.
Also: word wrap comments.
I have think about that a bit, and, I think the compiler should probably warn about cases like your example. A compiler already warns you about uninitialized variable, and semantically, I realized moved variable are in fact uninitialized variable. ~~As for the standard, it should probably acknowledge this state and formally describe the nature and behavior of moved-from objects.~~ The standard already mention the value of a moved-from object is unspecified, implicitly stating that the result of calling a method on such object is also unspecified. 
There's so many puns, I'm going to throw up.
Our default is that we lay down the win8.1 SDK, not the win10. and even then you can go to the custom page and make it not install either. We want to lay at least one down by default because you can't build anything without at least one SDK. Did I misunderstand?
Now make it free and we will be interested.
I'm pretty sure Visual Studio 2015 C++ express for desktop gives win 10 SDK (8.1 doesn't have corecrt.h). I don't recall a custom page, but I'll take your word for it and just missed it. I have both 8.1 and 10 SDK installed manually, well installed, copied the inc/lib folders then uninstalled.
Please post a self-contained repro. I overhauled call_once personally in 2015 for 100% conformance and dramatically improved efficiency. Note that I implemented a C++17 Library Issue resolution where call_once should not decay_copy - that may be the difference you're seeing.
Your second example sort of brings me back to statements that I've heard about how it can be harder for the compiler to optimize things when references are involved, as compared to value, due to aliasing issues. Did you try the second case with std::accumulate instead of std::for_each? I'd argue this is cleaner anyway as you don't need to initialize a local variable to zero, but rather output it directly (and you also won't need to capture anything by reference). My guess would be that std::accumulate will emit the better code.
&gt; find most recurring word 1 loop So I have nothing better to do and looked at the code and I'd like to offer the following remarks are constructive criticism: 1. requires DefaultConstructable&lt;ValueType&lt;Iter&gt;&gt;: that's only because you have `value_t retval{};`. I believe if you were to just save an iterator that points to an instance of the currently-most-occurring-value rather than a copy of that value, you could forego that requirement entirely. 2. requires ForwardIterator&lt;Iter&gt;: well, according to [std::sort documentation](http://en.cppreference.com/w/cpp/algorithm/sort), std::sort requires RandomAccessIterator 3. call to std::sort: so that requires the data to be modified. An important assumption I'd mention in the requirements. 4. "1 loop": well, what did you mean? Only one "hand-written loop"? Yes, I agree, but that function is not overall O(n), std::sort is already O(n\*log(n)). Next, you're invoking std::upper_bound, which one expects to be a binary search, thus O(log(n)). But in the worst case of all unique elements, you're invoking it n times. That's an another n\*log(n). Additionally, [std::distance](http://en.cppreference.com/w/cpp/iterator/distance)'s complexity is constant *only* if used with RandomAccessIterator (which, coincidentally, is enforced in a round-about way by the use of std::sort), otherwise, it is linear. So, if I got my count right, this function as is is O(n\*log(n) + n\*log(n) + n). Yes, I know that one would typically reduce it to down O(n\*log(n)) but when comparing similar algorithms for performance, I like to keep all the factors in because, heck, it's performance we're after, right? If we are allowed to modify data and must keep space usage constant, I'd keep the sort but then do a straightforward element-counting loop with a plain `i = begin(); i != end(); ++i`. That'd make the function O(n\*log(n) + n). Otherwise, I'd probably go the even simpler `map&lt;T, unsigned&gt;` route. All that being said, I also definitely am in the camp of aggressive use of `&lt;algorithm&gt;` but I believe it was a bit too aggressive in this case. What say you?
don't worry I get it :p 1: Yeah, I agree. I just wanted to make clearer what was going on but I guess it's just wasted eye movement. 2/3: I'm performing all of those operations on the `copy` vector, not the input sequence itself, so it's non-modifying. So that'd be: `make vector (n) + sort vector (nlgn) + walk vector (mlgn)` n = # of elements, m = # of unique elements But for this I wanted to demonstrate clarity not efficiency; though I'd love to write an algorithm w/ better complexities in the same style :) 4: I agree that I should make the run-time clearer, but I point out the lack of loops as examples of how simple/clear the implementation is. No need to go through iterations in your head just to figure out what's going on, etc.
Awesome, finally! :) Thank you!
Well, will it correctly generate non trivial include directories? Most real projects have multiple include directories, not at the base of the project. I don't know whether it will always guess ./ or if it will try to deduce it from looking at the code. IdeaVim doesn't have incremental search, which is a huge blow. Marks across files were broken last I used it. Vrapper from eclipse has these things, and also a selection of vimscript plugins. For example, argument text object. Just hit daa to remove an argument from a function signature; pretty fantastic. 
Great suggestion and indeed it does for the range-based-for example. If you change the example under #if FOREACH_LAMBDA to use std::accumulate (as suggested by /u/quicknir) then that auto-vectorizes too. total = std::accumulate(values.begin(), values.end(), total, [](total_type t, value_type&amp; v) { v += 1; return t + v; } );
part of the page was not loading. Initially I was unable to see the options to the left. 
I downloaded the git repository for git and imported it in CLion to test a relatively large project. The import interface is kind of dodgy, but I got it imported and on an i5-4670k the indexing took just under a minute. Quality of indices seems to be good and I didn't really encounter anything that I couldn't click on, though it just indices [using CMake, per their FAQ](http://blog.jetbrains.com/clion/2014/09/clion-answers-frequently-asked-questions/), so you'll probably have more experience with how that works (I have little to none). There were oddities with enums in structs though, where those names were not properly detected. I think because of the way it works, importing an existing project is probably going to be a pain, but starting a new project in it might make sense if you can get over the vim limitations, speaking of which: - incsearch is still not there, though the default search does provide it and it has a regex mode, so it's a viable substitute - marks across files are indeed still broken; they save the right location but don't open the right file
How did it come up with the CMake file? Did you have to manually select the includes? Git isn't a great test, because its written purely in C AFAIK. C is extremely, extremely simple to parse compared to C++. To give you perspective, I imported this project into Eclipse by picking the directory and naming it. It indexed in &lt; 15 seconds (not exaggerating). With another couple of clicks I can see that there are 28 missing includes in the entire project, they all seem to be related to other projects I don't have installed (curl, gnome keyring, windows/macos related things, etc). So it resolved everything that was available correctly, without any input from me. At the end of the day, the indexer is the heart and soul of an IDE. I have high hopes for CLion, but we'll just have to see I guess if it can pull significantly ahead of Eclipse (which is much maligned but actually has a very good indexer). The problem with default search btw is that it works for moving the cursor, but if you want to delete from here to your search or similar, I don't believe that it will.
Delightful, Florian. Do we have a syntax error here: template&lt;typename... Iterators&gt; std::tuple&lt;Iterators&gt; increment_all(Iterators&amp;... its) { return std::make_tuple((++its)...); } should this be?: template&lt;typename... Iterators&gt; std::tuple&lt;Iterators...&gt; increment_all(Iterators&amp;... its) { return std::make_tuple((++its)...); } Thanks for this article.
Honestly, I hate writing code during real-time interviews. If possible, I choose to use Perl, which I am most articulate/speedy in. Even with Perl, I still performed worse than my regular potential during my last live-coding interview. I don't mind a specified language if I am given a couple of days to work on an "offline" interview problem. I delivered a rock-solid alignment-aware malloc wrapper for an offline nvidia interview, but I had a few days to work on it and the interviewer wasn't literally watching every keystroke. :) Sorry, I don't really have any specific advice for this interview, but do know that there are others out there who really struggle with live-coding interviews! Edit: W.R.T competitive programming, I've won a prize category in the three hackathons I've attended. I was dancing between 1st/2nd during a CTF at DEFCON 21 (ended up getting stuck near the end, I've conveniently forgotten my final score :). I find competitive coding events to provide an *invigorating* stress while live-coding interviews offer me *nervous* stress. However, I suggest you try some competitive coding regardless, it is great fun and does help!
I suspect that the compiler thinks the function could throw, and the standard requires the compiler to catch and terminate the program if an exception is thrown. That catch logic likely results in not being able to inline the code.
Profiling showed that application running slower when I applied noexcept. Not getting inlined is way too brutal. Also these were functions that did not catch, nor throw, were tiny, entirely in a header, the compiler should have easily been able to see that they did not throw.. I'm now removing all the noexcepts I've added. What is more concerning is that the STL etc are likely going to start using conditional noexcept. Anyway I still think this is a compiler bug in part, because it should be able to see that these functions aren't capable of throwing. 
So is this kind of like MinGW except Visual studio?
Kind of makes me think of the XCode Command Line Tools actually. 
Visual Studio 2015 without visual assist ;)
It sounds like you had a dis-click with the guy. If that's really the case, then don't worry about it: there's nothing you can do. I've had a similar experience.
 void drive() { std::cout &lt;&lt; "brooum" &lt;&lt; std::endl; } This is the definition of a (completely unrelated) free function, not a member function. You need `void Car::drive() { ... } ` if you want to define the member function, which is currently not defined per the error message. 
Well, it is technical preview, so it is normal.
This comment reminds me about Windows 10.
I'm going to _assume_ no, both legally and technically.
&gt; There is probably a way to fill a vector (i guess) with a reference / pointer to the original (initial) car object built by the factory instead of a copy? Yes, there is (create a vector of Car*). But don't do that because you will have a vector full with dangling pointers. Your factory creates cars on the stack. Those cars are short lived and get destroyed when they go out of scope. (Which is at the end of the ::build() method) 
I wouldn't worry about things being copied. Copies are a lot rarer than they look at first because of compiler optimizations and because of a behind-the-scenes language feature called move semantics. Even with copies, you don't need to worry about performance until you have measured it and found that eliminating copies would be worth your time. That said, passing larger objects by const reference (e.g., `const Car&amp;`) is common when you don't modify the parameter. No copies are made in this case, and it's not a premature optimization.
And now I also hope it runs under wine, making it easier for FOSS projects to produce windows binaries.
I agree. Java was the inner context, but it could still be misleading. I could have just said something like "Java has value semantics, too."
I checked with our recruiting team this morning. We do sponsor visas for new grads, but it's less common for us as we mainly recruit at US schools. I'd encourage you to apply!
Because FOSS people will shrivel up and die if they run a Windows VM?
Code is an editor with no C++ IDE like features
Really? I thought it still had autocompletion and the like. So it's just Notepad++?
 Some highlights: * Modern C++, heterogeneous computing &amp; OpenCL SYCL - Slides: https://codeplaysoftware.github.io/iwocl2015/presentations/2015-05-10-IWOCL_OpenCL_modern_C++-expose.pdf - Video: https://www.youtube.com/watch?v=w_01x-aJAK8 * Update on the SYCL for OpenCL Open Standard to Enable C++ Meta Programming on Top of OpenCL - Slides: http://www.iwocl.org/wp-content/uploads/iwocl-2015-talk-andrew-codeplay-sycl-1-2-announcement.pdf - Video: https://www.youtube.com/watch?v=l4GrMOKDRSs * Mapping C++ AMP to OpenCL / HSA - Slides: http://www.iwocl.org/wp-content/uploads/iwocl-2015-talk-Jack-Chung-MultiCoreWare.pdf - Video: https://www.youtube.com/watch?v=ktheNLohF30 Downloads (slides): http://www.iwocl.org/conf-2015/iwocl-2015-presentation-downloads/
It will be on release, all CTP releases force EIP, it is part of what you agree to as part of installing it. 
Not sure what this means... do you mean "doesnt install any language but c++ and features that work with it?" - steve, vc dev mgr
Something like visual studio shell + this. Not sure you still accept requests though ;)
It's easy to cross compile using mingw-g++ as crosscompiler. Besides, VMs can be used if MSVC binaries are needed. 
Thanks, will do.
Fair enough. Even people willing to coexist with Windows sometimes pretend they can't get it without spending money. Are you a student? Do you know any students? Windows is free for life. Are you okay with piracy? Windows is free, if a little unstable.
&gt; should this be?: Yes, and now it is. Thank you
Everything is so happy but how is this different from the cl.exe that used to be shipped with the windows sdk ?
we are always interested in requests :) That's why I'm on reddit in the first place.
Well..if I use a lambda with params, it throws me errors..if I use a function &lt;&gt; which holds the lambda and then I pass the function to the call_once, it works
Look at Bjarne's website - c++11 FAQ - excellent information here overall http://www.stroustrup.com/C++11FAQ.html I would also recommend Scott Myer's excellent "Effective modern C++" book - http://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=sr_1_2?ie=UTF8&amp;qid=1446592421&amp;sr=8-2&amp;keywords=more+effective+c%2B%2B
Closed-source. :(
An unordered set, if you will :D 
[removed]
Does this fill the same role as Emscripten? From the examples it appears that it's meant for writing webapps, as opposed to porting existing applications to the web browser.
I use something similar. The only catch is you have to make sure the lambda you are passed in contains a raw pointer, and not a wrapped pointer such as a unique_ptr or shared_ptr
 I do not know of a better way and i do it the same way[1] you did. Basically,I: 1. Created a lambda. 2. Cast its address to void * 3. Pass the void * pointer to a function. 4. Cast back the void * to a lambda type. 5. Call the lambda. [1] https://github.com/mhogomchungu/zuluCrypt/blob/f51f5efc748798b377e2c921ffd0579091782f60/zuluCrypt-gui/cryptfiles.cpp#L317
Thanks for the void_t link. That's the best explanation for template argument deduction/substitution that I've found. I'll be sharing it with others.
In yours it looks like you're taking the address of a std::function object? Since it all remains in scope for the lifetime of the function that works fine in that case. In mine the callback is passed by value as the caller goes away after setting it.
yes,i take an address of a std::function object and hence the value of the address will always fit in variable of type void *. I played around with sizes of lambda a little bit and it turns out the size of a lambda object varies depending on what variables were captured. my foo lambda for example only captures "this" variable(single pointer variable) but it takes 32 bytes of memory on my 64 bit system.The "emit" Qt macro is probably pulling in 4 pointer variables through captured "this" pointer behind the scenes(4 * 8 = 32) The above means your class and example of: &gt;&gt; Set([this]() { Do stuff with this pointer; }); Will not always work because generated lambda maybe larger that the size of void * 
Looking at your comment Set([this]() { Do stuff with this pointer; }); This would result in the lambda being released after the call to Set() as its only a temporary, you will need to copy T and not just use the const-ref. NOTE: Capture-less lambdas have a user-defined conversion function to function pointers, thats the only reason they can be used for callbacks, they aren't function pointers.
Emit is nop macro. It does nothing. It's just for making emitting signal clearer. Emitting signal is just a normal function call but the funtion body is generated by MOC.
I'm actually surprised how VAX has stagnated over the past couple years, there has been nothing new really. They added some things like the debug step filter (which is awesome!) but that's it. I hope Resharper++ will bring some fresh air. Re++ is quite awesome, but misses some important things VAX has, so I can't switch. And running both plugins just creates havoc. I hope in half a year or a year or so we'll have something that can do all the good stuff of both plugins.
&gt; I deal with callbacks often enough in code to want to make them more elegant. For anyone who's used std::function you already know what I mean! I have used std::function and don't get it: What do you mean by "more elegant?" What is it you do not like about std::function itself? &gt; In my case I wanted a std::function that was the size of a void* so that I could use the same class to hook up to external APIs that take a function pointer and a void*. Can you provide some sample code that shows exactly what you are trying to do? I don't get the usefulness of it.
const_casts that remove const make me nervous since they can run afoul of undefined behaviour. More importantly, doesn't this end up dereferencing deallocated memory as soon as you leave stack scope if your lambda has any kind of capture? I'm sure you're aware that Lambdas without capture auto-magically convert to function pointers so I'm not quite clear on the value this is providing. Also, this is technically the size of 2 void pointers since you need to keep track of m_pCallback which itself is a fairly poor attempt at emulating type-erasure since you still need to know the function signature. Type erase is hard to get at first, but the boost implementation for boost::any and boost::variant was pretty enlightening about 2 mechanisms to actually get rid of all type-information &amp; then get it back.
This is a good overview, though it is written from the perspective if Visual C++ https://msdn.microsoft.com/en-us/library/hh279654.aspx
The problem with this type of approach is that it technically requires multiple windows licenses, if I understand correctly, which seems unfair. To be clear, it's possible to separate the tools from VS today, and many shops do that, but it would be nice to not have to maintain internal scripts for that.
Ah yes. You are correct, so bad example on my part. Even worse is that for non C++11 compilers, the zip_iterator compiles but gives the wrong result because we're unable to properly create a copy of the dereferenced iterator data. I'll update the article.
&gt; Hana has been an inspiration for me. That's really great to hear! &gt; I hope to eventually contribute to (or author) a metaprogramming library of this caliber. Writing a whole library is a huge task; I spent more than 2 years working basically full time on Hana. If you have an idea for a metaprogramming library that makes it different from what exists right now, then definitely go for it. Otherwise, however, I would encourage you to contribute to an existing library because your work will then almost immediately be useful to others. And rest assured that almost any library that you see out there still has a lot of things to improve on, so they could use your help. If you're interested in contributing to Hana, you can contact me and there are some specific directions I could suggest to you. There are many things to improve, and we still have the freedom to change some things because it's not released with Boost yet. 
&gt; I deal with callbacks often enough in code to want to make them more elegant. For anyone who's used std::function you already know what I mean! I use `std::function` every day, but I have no idea what you're talking about. What's the problem with it? What are you trying to solve? &gt; I wanted a std::function that was the size of a void* Your implementation is not. It's the size of a function pointer (typically the same size as `void*`, but that's not guaranteed), plus `sizeof(void*)`. &gt; I mostly use it for holding [this] capture lambdas, since those are always a single pointer. They're not, but they can be implicitly converted to a pointer to a function if they don't capture anything: void (*pf)() = []{}; On Visual C++ 2015, your code fails miserably if I pass a lambda to it, because the size of a lambda with no captures is 1. template&lt;typename Callback&gt; struct TCallback; Don't prefix class templates with `T`, it just looks stupid. template&lt;class T&gt; TCallback(const T &amp;v) throw() { Set(v); } Don't put braces on the same line, most debuggers won't allow you to set breakpoints. Also, `throw()` is deprecated in C++11. Use `noexcept`. void Set(Callback pCallback, void *pData) throw() { m_pCallback=pCallback; m_pData=pData; } What's the purpose of this one? It changes the behaviour of a `TCallback` completely. template&lt;class T&gt; void Set(const T &amp;v) throw() { static_assert(sizeof(T)==sizeof(m_pData), "Can't hold functor, only able to hold a single pointer sized value"); m_pData=*reinterpret_cast&lt;void**&gt;(const_cast&lt;T*&gt;(&amp;v)); m_pCallback=[](void *pData, Params&amp;&amp;... params) -&gt; return_type { return (reinterpret_cast&lt;T &amp;&gt;(pData))(std::forward&lt;Params&gt;(params)...); }; } Oh dear. Keep your line lengths below 80 characters. Like I said, function pointers and lambdas are not guaranteed to be the same size as a `void*`. This has nothing to do with "functors", whatever that means. You're also not allowing functions to decay to function pointers, forcing calls like `Set(f)` to be `Set(&amp;f)`. ~~const_cast is undefined behaviour if the object is actually const~~. `const_cast` smells of bad design, but it's not undefined behaviour as long as you don't modify the object. You're also keeping a pointer to something you don't control and assume that it will outlive the `Set()` call. Your `reinterpret_cast` is unnecessary for function pointers. For lambdas, it's undefined behaviour. You seem to be assuming that a lambda is implemented as a function pointer, which is not necessarily the case. This code fails to compile on Visual C++ 2015 because of the `static_assert` and it fails to run after commenting it. I don't care if you use this shit in your basement, but don't put it on the internet. People use code they find indiscriminately and it would be a disaster if this was used in any professional context. 
IMO command-line-only updates are only useful if you're targeting Windows, but no one working on the project actually uses VS normally. Command-line only installs of upcoming versions will be quite nice (rather than needing a throwaway VM to work around not being able to uninstall VS...), but I don't think there's a lot of value gained from making those endorsed for production.
I agree, that's why I posted this to figure how to do a special case of std::function and not make it evil. And you're right, I updated the title since I realized it was totally wrong. My initial goal was to make my interface nicer than the old style 'SetCallback(void(\*callback)(void\*), void\* userData)'. Which is... obviously the size of two pointers, duh.
It's making a copy of the data of the const-ref, not just copying the reference itself (the evil \*reinterpret_cast&lt;void **&gt;(&amp;functor))' part. Yep, I know how capture-less lambdas convert to function pointers, unfortunately I needed to hold some state.
Yep, your foo lambda is of type std::function&lt;int(int)&gt; which is what is taking 32 bytes on a 64 bit system. The std::function implementation includes extra bytes of buffer to possibly handle small sized lambdas then will switch to a pointer to an allocated buffer if the lambda is too big to fit in it. I wanted to special case it for simple ones. Try doing replacing 'function_t' with 'auto' and doing the sizeof the resulting type, it should be 16 bytes (on 64-bit) or 8 on 32.
Ah, I was using MSVC and saw that std::function was 24-bytes on 32-bit to optimize for small lambdas. I wanted to make it so I could pass this by value and not need to keep it around. The same way you can pass a function pointer that takes a void\*. You can pass the function pointer and the void\* around by value.
But then you have a extra memory allocation per callback :(. It works, but I wanted it to be as low cost as the old function pointer + void\* userdata.
Yea, so far I never needed this for lambdas smaller than a void\* I mostly wanted to know how to remove the evil reinterpret_cast stuff. I know mine will blow up if the lambda's capture needs to be destructed, but I couldn't figure out how to do a copy of the lambda into my temporary storage.
Yeah, it's not perfect, I couldn't figure how to copy the lambda by value with full type safety, so I posted here :)
In VC++ std::function takes up 24-bytes x86 32-bytes x64, so I wanted to make a special case for pointer capture sized lambdas. So it's meant to be just like std::function, just only 8-bytes x86/16 bytes x64. Same as a function pointer + a void/*. 'more elegant' was meant to refer to the old style callback syntax, it is confusing the way I wrote it as std::function is elegant, just not optimal in terms of memory.
Without CMake? What is it supposed to use then?
Support for type-deduced __builtin_{add,sub,mul}_overflow was added to Clang in the last week or two, matching the builtins that GCC has had for a bit. Now I just need to find a nice way to wrap them up that also includes MSVC compatibility. :)
&gt; I wanted this to be as efficient as that, but as simple as passing a lambda with a single capture value (usually a this pointer). You can't, unless you want undefined behaviour. It might work on your architecture and specific compiler version, but it's fundamentally broken. If you have a C function that takes a function pointer and a void* and want to forward it to a member function, you'll have to do that manually. You can't pass lambdas around to a C function and expect it to work reliably. You can however write some generic trampoline function that allocates something on the heap to keep track of `this`: #include &lt;memory&gt; class basic_trampoline_data { public: virtual ~basic_trampoline_data() { } virtual void call() = 0; }; template &lt;class T, class F&gt; class trampoline_data : public basic_trampoline_data { public: trampoline_data(T self, F fun) : self_(self), fun_(fun) { } void call() override { (self_-&gt;*fun_)(); } private: T self_; F fun_; }; template &lt;class T, class F&gt; std::unique_ptr&lt;basic_trampoline_data&gt; make_trampoline(T self, F fun) { return std::make_unique&lt;trampoline_data&lt;T, F&gt;&gt;(self, fun); } void trampoline(void* data) { static_cast&lt;basic_trampoline_data*&gt;(data)-&gt;call(); } extern "C" void c_fun(void (*pf)(void*), void* data) { pf(data); } class test { public: test() : d_(make_trampoline(this, &amp;test::f)) { c_fun(trampoline, d_.get()); } void f() { } private: std::unique_ptr&lt;basic_trampoline_data&gt; d_; }; int main() { test(); } 
Yep, that solves the copy case, but how do I call the destructor? It seems like access to it is lost after I'm out of the Set() function. Unless that's one of the other function pointers that std::function stores, a pointer to the destructor...
It happened to me a lot: don't worry. Just comment stuff until you find the line that causes the problem. (If you're kind enough, isolate this in a simple example and submit a bug). Then, reword your code using older syntax until the compiler accepts it. That, or you're stuck waiting a new update. 
&gt;Writing a whole library is a huge task; I spent more than 2 years working basically full time on Hana. That must be a true work of love then, no wonder you gave it a personal name :)
My bug was a combo of variadic templates, typelists, and nested expansions. The compiler decided it didn't want to keep expanding and just crapped out. If I did it another (similar but less efficient) way, the compiler failed to compile, which was also a bug, but not one that crashed the compiler. It crashed on instantiating [this definition](https://github.com/jkoritzinsky/JKor-Units/blob/master/include/unit_base.hpp#L94).
Signal processing (audio and graphics) usually.
&gt; I don't care if you use this shit in your basement, but don't put it on the internet. People use code they find indiscriminately and it would be a disaster if this was used in any professional context. That's nobody's responsibility except the person who copied it.
Your commenting on coding style which is completely irrelevant here, and I completely disagree with all of the style points except for throw() Your wrong about const_cast it is only undefined behaviour to modify a const cast object, the cast itself is valid. Anyone that uses random code from the internet within a professional context without understanding it should be fired. And most work environments your going to have commit checks which will provide a second set of eyes. His code while ugly and hacky would be safe if he checks if the lambda is POD so a copy can be made just on its value, the size is already has a static assert.
That was badly worded on my part. I'm talking about the size of his implementation, not the size of an std::function.
`HasFoo` isn't a metafunction, though, it's a `concept` that is already provided and is used elsewhere in the code. Maybe there's a way to create a generic metafunction to handle an arbitrary concept, but I'm not seeing it. Otherwise you'd have to create one for each concept, which is kinda annoying.
Quickly skimming through the readme and the doc directory it seems like there should be some mention of how things work with multiple concurrent threads logging information. It seems like everything is safe based upon the fact that you're using at least one mutex, but it would be nice to have that documented in the readme.
It doesn't need to be a metafunction. Static assert uses a boolean, so you should be able to pass it directly in the static assert. The problem is using a concept outside of a requires clause. The way it is implemented currently, I believe, is it assumes it is in a SFINAE context when it evaluates a concept. However, a static assert is not a SFINAE context, so this could be problematic. 
But it's so much nicer to capture [this] since you can call member functions directly, it's like writing inline code :) I partly wrote it that way to avoid all the reinterpret_cast calls in every callback I'd write (as they're ugly). cfunc([this](int a) { foobar(a); }); 
It's hard for me to find any consistent information about concepts; there's too many different things flying around. I don't know if it makes to worry about best practices when it's not standard C++ even. I'll just leave you with this parting thought. Assuming that the only way to use concepts in the gcc implementation is with concept and requires keywords, and requires requires SFINAE, here's what you could do: #define MAKE_CHECK_CONCEPT(N, C) \ template &lt;class T&gt; \ struct N : std::false_type {}; \ \ template &lt;class C&gt; \ struct N : std::true_type {}; I'm obviously not sure whether this will be resolved correctly, but this (or something very similar) should. It addresses the SFINAE context that pfultz2 mentioned. The macro can generate a meta function in one very short line from any concept, and then you can use the meta function for anything. If I were to use this I'd probably default to creating metafunctions for all my concepts at the point of creation.
Aha, I thought the same thing above (though you technically replied before I did), where I'd use std::is_pod or std::is_trivially_copyable. Makes me feel better knowing I'm not alone thinking that.
Unfortunately they aren't `constexpr`.
I'm also curious about concepts support in Visual C++... Is there any plan?
Probably not, but a Windows VM cost money.
Celebrating 30-th anniversary of the first C++ compiler: let's find bugs in it: http://www.viva64.com/en/b/0355/
No it doesn't.
Nice to see Bjarne's feedback on it.
Maybe it's time for meta-concepts ? :p
Well, std::function can be implemented in quite a few ways. You could add another pointer to function that will call destructor on data. Or you could create some function_allocator, with pure virtual allocate, destroy, deallocate methods etc, templated derived class which will deal with calling destructors of specific type, and placement new it in another local buffer. Then you would have one pointer that can copy and destroy provided callable types. I think function implementation VS2015 is doing something similar, though I'm not sure.
You can search for last reflection papers here [Pre-lenexa](https://isocpp.org/blog/2015/04/2015-04-pre-lenexa-mailing-available). *hint* search "reflection" in the page. After that, in Kona there was no reflection papers AFAIK.
Then join the committee and shake things up. Or maybe just actually do some research and realise how clueless you are.
&gt; keep ignoring pleas from C++ developers Pleading to be committee while refusing to participate is like begging for features in an opensource project while refusing to donate or help out.
Do you *really* want C++ to be a compiler driven language? Cause that's how we got the abomination that was Visual C++ 6. Standards are a *good thing*. They mean that standard C++ code you write with one compiler will still compile with the other compiler.
&gt; Is there any reason a concept couldn't be used in more generic contexts, though? I don't think so. I think its just the implementation being lazy.
There's no need for that. Concepts just need to be higher-order, like template classes(or aliases) are. That is you can pass a template class to a template parameter, you should be able to pass a concept as well. Ultimately, the best would be for concepts to be like classes(like how aliases are) instead of a adding a new type to the template parameter. This also has the benefit of making concepts integral constants instead of using constexpr boolean, which are generally discouraged.
It requires you to buy a copy of operating system, so it should be costing money, although it will be interesting to hear your comment on why not. I'm assuming piracy and student offers aren't an option here 
If you want a request, here is mine - VS Build Tools/ VS Studio for linx
followup question: do you mean you want cross compilers you can run on Linux to build Windows apps or are you talking about native Linux tools for building for linux
Double dots? Everyone I know calls them colons
&gt; I'm assuming piracy and student offers aren't an option here If you have a .edu e-mail address, or know someone who does, it's free. Also, Windows piracy is easy, though I find pirated Windows too unstable for regular use. Stable enough for a VM to compile in, though. And seriously, even if you don't know any students and don't want to pirate, surely you know *someone* who has a Windows PC.
std::function isn't evil, it just takes up more memory. The evil was in my code I posted, but thanks to everyone's help here I've made it much less evil now (aka it's safer to use).
Yeah, that makes sense. The implementation in VS is hard to follow but things other people posted also agree with this being necessary to make it work in all cases. I put more static_asserts in mine to require that the lambda be trivially copyable and to have no destructor. This was the case I was optimizing for and I'm glad I can enforce it. For everything else, there's std::function.
There is actually a very good reason for this. When I started the implementation, it wasn't obvious that most implementations would be able to instantiate template requirements outside of carefully constructed SFINAE contexts. In fact, this was a national body comment on the TS, and it was the only design issue accepted after EWG discussions in Kona. But sure... let's chalk it up to laziness on the part of the implementation. Or maybe you just don't know what you're talking about. 
Why would it impact a compilers to determine concept-based overloads? Concepts already act either like a function that returns a bool or boolean variable template. So why would it matter if it acts like a class which is an integral constant? Furthermore, as a class it would make it easier to implement concept-based overloading. So when the user writes: template&lt;class T&gt; concept bool Foo = A&lt;T&gt;() &amp;&amp; B&lt;T&gt;(); The compiler could generate something like this: template&lt;class T&gt; struct Foo : std::integral_constant&lt;bool, (A&lt;T&gt;() &amp;&amp; B&lt;T&gt;()) { using __ExpressionTree = __and&lt;A&lt;T&gt;, B&lt;T&gt;&gt;; }; And use `__ExpressionTree`(which is an implementation detail) to subsume the expressions when overloading. Something similar could be done for checking template definitions. Of course, that is just one way, ultimately it can be left to the implementer to best decide. &gt; When will I see your proposal in a WG21 mailing? I am not sure how receptive the committee is to these changes right now(you don't seem to be). Unfortunately, it may too late when they are.
The web installer seems to have materialized [here](https://www.visualstudio.com/news/vs2015-update1-vs), and the C++ Build Tools link above seems to be working again! :)
Could you expand on this point: // Note that function templates shadow rather than overload, so if you want to have the same // generic function with a different number of parameters, you do as the standard library does // and suffix the name with the number parameters. This is the same approach as taken in most // functional languages. Usually the original function remains un-numbered, so you can apply // this after-the-fact. Are you talking about something like this? #include &lt;iostream&gt; template&lt;typename T&gt; T op(const T&amp; a, const T&amp; b, const T&amp; c) { return a + b + c; } template&lt;typename T&gt; T op(const T&amp; a, const T&amp; b) { return a + b; } int main() { std::cout &lt;&lt; op(1, 2) &lt;&lt; std::endl; std::cout &lt;&lt; op(1, 2, 3) &lt;&lt; std::endl; return 0; }
cppreference: http://en.cppreference.com/w/ Books: http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list
Very interesting! Your code seems to act as it should, and I think I will have to retract that particular assertion. I was reading too much into the fact that template specializations don't overload. However, base templates _do_ overload just fine, which is what the trinary op is doing. Thanks for the correction!
I like [cplusplus.com](http://cplusplus.com) better for reference. More human-understandable explanation, less hardcore standardese.
It also has misinformation and bad advices. I use QtCreator and cppreference offers .qch file for integrating documentation to the editor. Also multiple other formats are available for offline reading: http://en.cppreference.com/w/Cppreference:Archives 
Make it graph out arbitrary functions!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [RAMwave : cpp](https://np.reddit.com/r/programming/comments/3roz2g/ramwave_cpp/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
When you say: /// we don't need std::bind for stand-alone functions - they're much easier to pass around than /// member functions. Are we assuming that what you pass them to just doesn't handle PMFs very well? It's preferable for the code receiving these callables to use `std::invoke`, but I recognize that the majority of code today (including `&lt;algorithm&gt;` for now) doesn't.
Thanks for (indirectly) clarifying! I was puzzled as to why my example works when you claimed it wouldn't. I didn't even think of specializations not factoring in to overloads at the same time as base templates.
I don't recognize the monitor on the last screenshot, would you mind enlightening me?
It depends on the constraint. If you're just evaluating environmental constants (macros or simple constant expressions) you're fine. If the constraints evaluate have something like: requires (int a) { *a; } then your success may vary. Every compiler knows that *a is ill-formed and will naturally diagnose your program as ill-formed. But concepts try to suppress that. Eventually (presumably) that would be well-formed and simply evaluate to false.
The "New database engine" entry is quite cool. It appears VS moved away from SQL Server (embedded) to SQLite.
Right, I think so too. However, my coworker still uses VAX and its search, code outline window and refactoring tools.
yep. they went up on Monday afternoon. I should have closed the loop, sorry about that.
got it thanks! just as an amusing aside, it is interesting on how our top feedback is split pretty evenly between "Make an IDE for Linux" and "Make it so I don't need an IDE on Windows" :) 
I used to use code::block, but now I'm back to using plain gedit and a terminal window to compile and run. I also make my own make file. I think I have more control that way.
I feel you still have not addressed the basic question that has come up in the past when you have posted very similar material: what is the advantage of using a non-member friend over a member? &gt; Its has better generic usage (especially with respect to the above preferred forms of polymorphism) and exposes a much simpler and more extensible interface. Adding a new function to a DA is as easy as opening up its containing namespace and plopping one in. It's only as easy as "plopping one in" if it doesn't require privileged access to data members, otherwise it will require a friend declaration. Similarly: &gt; Unlike with OO interfaces, extending a DA is easy; even if you're in a different file or code base, just open up the DA's namespace and add functions to you heart's content! You can do this just as well with OO, under exactly the same circumstances: if you don't need direct access to data members. If you need direct access to data members, you need to change the class definition either way. &gt; Here we expose our DA's interface with stand-alone functions. Stand-alone functions are preferable to member functions because they are much more amenable to use in generic programming. For more on this see - http:www.gotw.ca/gotw/084.htm and - http:www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197 Actually, neither of these two links mention generic programming. Neither of these two links recommend non-member friends over members. They recommend non-member, non-friends wherever possible, which is considered the norm in modern OOP C++. In fact, look at Scott Meyer's algorithm (shortened for brevity): if (f needs to be virtual) ... else if (f is operator&gt;&gt; or operator&lt;&lt;) ... else if (f needs type conversions on its left-most argument) ... else if (f can be implemented via C's public interface) make f a non-member function; else make f a member function of C; Since none of the earlier conditions apply to you, it's down to the last two, and you can see that Scott specifically recommends making a function a member, not a friend, if it requires privileged access.
Just to be clear, this is my blog, so if you have any questions, I can answer them to the best of my ability.
There's a ruby book that is great at explaining how to design OO systems : Practical Object-Oriented Design in Ruby , An Agile Primer-Sandi Metz
In English `:` is called `colon`, but in other languages (article author native language is Russian) `:` is called `double dot`, so `::` is called `four dots` or similar, not `double colon`.
I've managed to reproduce this in a more isolated form. Best to log a bug on connect? EDIT: Oops, looks like I can't log a bug on connect. I receive an error saying I am not authorized. Please advise.
&gt; hurr durr I am retard essentially
Use Send-A-Smile/Frown, the smiley face in the upper right corner of 2015's IDE. We have a vendor team who processes that feedback and files bugs in our internal database for anything with a proper test case provided. Include your E-mail address if you want to hear back from us.
I reported a similar missing warning in the compiler back-end maybe a year ago. The BE is good when it comes to warning about unused local variables. I'm pretty sure they're also good about detecting variables that are only written to (as they can see that all the stores are dead). However, the case that I encountered was a variable whose value was both written and read, but only to update itself (consider `+=` or `*=`). This indicated that the whole algorithm was totally damaged, and should be perfectly detectable (as it wasn't address-taken in any way). Some days, I'm glad I'm not a compiler dev. All days, really.
First time hearing that. Thanks
Lol thanks. I'm still curious
&gt; I remember back when it was just a joke that C++ would have a turing-complete type system before the standards guys got around to reflection. That was so prescient.
Even coming from the same person, that would be a reasonable request and not a contradiction per se. Command line tools for build farms and CI, and an IDE for development.
yep. totally get it. just thought it was interesting.
Steel beams can't melt dark themes.
Notice how in the menu on the left it's laid out like *&lt;cstdlib&gt; (stdlib.h)*? And the explanation about header file names [here](http://www.cplusplus.com/reference/clibrary/)? It's pretty clear. I've never run into an error in the documentation there.
Books are ok, building something is better. Chances are you're going to google an error and find a forum thread or stackoverflow page. I built a cross platform [build tool](https://github.com/Dekken/maiken) and in the the process learned a lot, now it's all I use for building. Sublime Text 3 as editor.
Is the middle-click paste fixed in gedit? Btw, it's a perfect time to learn CMake. My config is eclipse + CMake that is set up to generate makefiles (not eclipse projects).
Certainly, but how often do you run on this page when doing a google search like "c++ abs" ? cppreference leaves less things ambiguous.
std::vector doesn't allocate linearly so that won't work. https://www.quora.com/How-is-memory-allocated-to-std-vector-when-we-push_back-elements-into-it
Why do you thnk push_back should to force copy construction as compared with emplace_back? There is no difference at all which function to use in the case.
I prefer QtCreator, codelite and kdevelop over codebloks
Sorry about that! I'll fix it later on my blog, but alas, I'm stuck with it on Reddit. 
Where did you read it is LGPL? It was recently relicensed to BSD. &gt; There are already SIMD C++ libraries out there with liberal licenses. The interesting thing about this library is that it's author is also working on the SIMD proposal for the C++ standard. The proposal is based on Vc.
With every new vector library and vector class I see, the question I always ask is how fast and how easy it is compared to Intel's ISPC language. I've made my own mem_add etc. functions that take one array of numbers and add them to another array using AVX. This requires only a few lines of ISPC. I can't find any examples on their opening page so I don't know if it works over arrays (good) or makes a vec4f type and a vec8f type (bad). SIMD can be very fast and not at all difficult but most people think you have to treat the SIMD lanes as just a fat variable which doesn't give much speedup at all. I don't think people are at fault for thinking this either, the myth keeps circulating without much done to educate people. And then knew libraries come out that just dig it in deeper and most people lose any hope of SIMD speeding up their programs. But if you can use it correctly... my god can SIMD be fast. 
Of course, I wouldn't wrap the std lib :) But I think individual APIs have sufficient freedom to opt-in to various styles in C++ - rarely does any non-std API reach the level of global consistency you're talking about. However, on that point, parts of the std lib are actually being wrapped in this style directly in the std lib. std::begin and std::end, for example, wrap the container's member functions for exactly the reasons I mention. As to the links, they do support my assertions, albeit somewhat from a different perspective than the one you hold. From the perspective of a programmer coming from C# or Java, the points laid out in this article are effectively lemmas that allow me to get to my final point. However, since you and I share much of the same perspective, we would take them as a given. And yes, static selection works with both ad hoc polymorphism and member functions, but the former does not carry the burden of membership, a burden which has the additional trade-offs I mentioned.
For example here: https://github.com/VcDevel/Vc/blob/master/include/Vc/Memory
No, it only supports gcc, clang and icc. (Supporting more compilers is a manpower problem, because the library regularly exposes bugs in the compiler's implementation of C++.) 
4189 (local var init but not referenced) and 4100 (unreferenced param) are both FE warnings, and thus rather dumb. The BE could undoubtedly do a better job though. I don't think we've ever warned about dead stores though, have we? I imagine that would be extremely noisy.
The pedantic compiler dev in me wonders why someone wouldn't consider passing a parameter to a call (even a recursive call) as a use, but the regular human in me sees OP's point.
Warning about an individual dead store would be obnoxious, probably, but warning about an only-written variable would be valuable. I thought the BE did that, but maybe I was wrong.
I certainly understand the pedantic compiler dev in you, but we have to remember that these warnings are there for us regular humans. As I mentioned, this happened in real code, and had the warning caught it, I would've never had run into the issue. 
I mean, we define have to define what a problem is right? [We can see right here that people thought it was a "problem" when this warning didn't exist at all.](https://llvm.org/bugs/show_bug.cgi?id=2739) I consider this to be the same level of issue, as I'm just asking for a bugfix/enhancement to that existing feature. Your compiler isn't generating incorrect code, it just misses a special case of this warning they all implement. Is it a huge deal? Absolutely not, but it's an interesting corner case they all seem to run into. 
What about using ```deque```? Something like ```deque&lt;vector&lt;char&gt;&gt;```
Well, it's not a problem as far as the compiler is concerned, however it's generally indicative of something fishy going on and therefore a warning would most likely be appreciated.
I agree.
Haha, true. What a blogger has to do these days to get noticed in the blogosphere :p
I generated the documentation and put it on Github pages, because it does not seem to be available anywhere. [Here you go.](https://vks.github.io/Vc-doc) It goes into a lot more detail than the README. (Please note that I'm not the author of Vc.)
Right, I mentioned that as a an alternative for situations where you can't guarantee the same sequence of allocations each time, e.g. in multithreaded benchmarks. (And an even simpler trick is to _just_ no-op free/delete.) One concern with the pointer-bump allocation approach is that this can potentially make a big difference to data locality, since you end up with big holes in your heap. (Got to admit I haven't actually tried measuring this though.) Also, it's not ideal for benchmarks on a build server, where ideally you would like to play nice with other stuff running on the same machine.
If his focus is performance why is he using dynamic polymorphism?
Rust has a unified call syntax like you mention, and I think that is one way to remove the contention that quicknir and I are grappling with. In rust, method invocation syntax is nothing more than syntactic sugar. If one could choose the syntactic form of invocation in C++ depending on need at the call site, this discussion would be moot. As things are, however, the syntax in C++ is inextricably bound to one's choice of abstraction / semantics. Because of this fact, coupled with the absence of extension methods in C++, I cannot recommend using member functions in C++ for data abstractions. Maybe they're fine with OO-style objects, but even then, that's how you end up with a type with 100+ methods yet whose interface is _still_ incomplete - http://www.gotw.ca/gotw/084.htm I hope things will improve in the future for C++, but I have to make recommendations on what exists now rather than, say, in C++ 17 or 20. And I don't see any compelling reason to wait since these upcoming generalizations don't apply to people who aren't interested in doing object-orientation anyway. And you're correct that there can sometimes be unintended consequences to augmenting the namespaces provided by libraries. But even the std lib allows for and encourages template specializations in the std namespace. I really think the approach should be a safe in practice, especially if the API is designed with the approach in mind. And like you say, you can always open up extension-specific namespaces. I personally however don't really find that approach satisfactory since I try to confine using namespace statements to within function scopes - and having to open up a whole slew of namespaces over and over just to get the right overload is rather painful. Perhaps unified call syntax can render some of this discussion moot. However, in the face of the proposal's wording - https://isocpp.org/files/papers/N4165.pdf - my suggested approach of 'just define non-member functions' would be even _more_ preferable, since that approach allows the users the choice of either syntax, while the member function syntax only offers the choice of... well, member function calls - call that are, again, that much harder to pass around. I really suspect that if people adopted the DAS in C++, such language extensions would be unnecessary. And while data abstractions and stand-alone functions are simpler and more general than objects and methods, one does not simply kill off the remnants of an ideology like OOP.
I've certainly never seen as much discussion on any new C++ addition as I have for `variant`.I found it amazing that such a consensus was reached at Kona already.
The article is a decent intro to such things, but he omitted some of the most important pieces of information. Generating copy assignment/constructor for a class with an explicit destructor is deprecated from 11 on. And compilers can generate this warning (exact flag escapes me atm). This means that in a codebase with appropriate build settings, the situation where it still worked but had a performance hit would fail to compile and could be caught early and corrected. This should be one of the major take arrays for practical programming. 
I'd like to stress that this is an *alternative* to boost::variant and the upcoming std::experimental::variant types. This does not, and is not meant to, accomplish the same thing as the *::variant types. Here's a section of the README: This is a simple reference implementation for fixed type at construction algebraic and recursive algebraic data types in C++11/14. It is a single header implementation of just one data type: the algebraic&lt;T_1,...,T_n&gt;, and a single wrapper: the recursive&lt;T&gt;. The implementation is RAII conforming (with the help of some template magic, of course, but does *not* rely on undefined behavior). The recursive wrapper is allocator-aware, so it can be used out-of-the box with custom rolled allocators. The implementation is known to compile and work correctly using both clang++ (ver. Apple LLVM 7.0.0) and g++ (ver. 5.2.0) under standards c++11 and c++14. The motivation was a need to efficiently deal with algebraic data types without appealing to a visitor pattern; I needed a type for objects that could take *one and only one* identity though their lifetime, and could be safely and implicitly converted to the correct type as needed, sans obfuscating glue code.
As I told Axel during the evening session, "I am extremely very happy" with the compromise :-) My hope is we will quickly move to approval into the TS without further urging feeling for "improvements" that may do more harm than good.
As soon as I read the article it seemed clear to me that it was the way to go, no ub and no real performance hit. I can't figure out why I didn't think of it... The answer is always clear in retrospect ;-). 
My guess is they don't pay enough
Does this mean that a variant will always be valid, and never invalid? Will the standard say anything about implementation requirements, e.g. avoiding heap allocations for small objects? Or is the design now such that there will never be a heap allocation ever, and it's a pure value type like a union? 
Right, but I mean if it always throws when accessed in an invalid state does that mean there's no need for `valid()` as a member function? That was necessary to avoid UB in the previous incarnation, but it seems extraneous if it throws.
You'd probably still want to be able to avoid the exception, so I'd guess `valid()` still has a place.
I really don't understand the example given in the article: variant&lt;string, MyClass&gt; v = "ABC"; v = MyClass(); Surely if the construction of MyClass throws, variant::operator= will never be invoked? 
&gt;&gt; std::move doesn’t actually do any moving. It simply casts the supplied object to an r-value reference. sometimes,i wonder why it was named "std::move()" and not "rvalue_cast&lt;&gt;()" or any other name with a form of "xxx_cast&lt;&gt;()" to be consistent with the rest of C++ casts?? anybody know why?
It's a problem if the old variant value is destroyed and then an exception occurs when putting the new value in rather than in the creation of a temporary to assign from. 
**edit:** assignment operators are now correctly deleted. Assignment now works through the emplace function, which throws in the case of differing type. Ahh, right thank you for mentioning that. In my local copy of the repo I have commented out a version of the assignment operators that checks for type equality. I haven't yet decided whether an assert or throw is better. As for the template T, Ts... versus Ts...; the latter would allow for an empty algebraic type, which is useless and (I think, given the implementation) would just cause a compiler to spit out error messages. The T is not privileged at all, that's simply a way to ensure at least one type exists.
We switched PathEngine over to the iAllocator setup some time ago (so with one virtual function dispatch per allocation and deallocation). Our benchmarking showed no significant hit for this. Maybe virtual function call overhead is less of an issue that it used to be in the past. Or maybe it's just that dynamic allocation is expensive enough already that this additional overhead is not significant. Note that Bitsquid also does something similar, described here: http://bitsquid.blogspot.fr/2010/09/custom-memory-allocation-in-c.html (Niklas says there, "Memory allocation is expensive anyway, so I don't care about the cost of a virtual function call.".) So I'm not really worried about virtual function call overhead for this. But actually you don't *need* any virtual dispatch to implement the technique. Just overload global operator new and delete to call directly into the cReplayAllocator concrete class for your replay iteration.
The cost of a virtual function call would probably be dwarfed by the run time cost of malloc/free themselves.
It is interesting that everyone is comparing `variant` with `union` while it is actually an extension of `enum` which is a special case of `variant`.
From my experience during biicode development, I'm pretty sure that importing existing project -&gt; generate cmakelists will never work correctly. I had no time to try a clang-based scanning approach which is what I would liked, but things like "guessing standard version" don't sound simple to me, even with tools like libclang
The move constructor called inside variant, not the default constructor called here.
Probably because they want/need it to be as efficient as union in addition to being safe.
If you assign specific numeric values to `enum` values then yes. Otherwise, if you are using `enum` just as a set of possible values without caring about specific numerical values then you can use variant with unit types. E.g. instead of: enum Triple { ONE, TWO, THREE, }; You can use: struct One {}; struct Two {}; struct Three {}; typedef variant&lt;One, Two, Three&gt; Triple; 
&gt; return boost::optional&lt;Student&gt;(); You can also write boost::none!
Avoid null by returning optional&lt;T&gt; from a find function? How is this of any benefit over returning a pointer, or preferably an iterator? The only piece of sane advice in this article is to use references instead of pointers where possible.
&gt; that is if you dereference it and nothing was found, you throw rather than ub ub? &gt;Second, optional internally contains the information of whether something was found or not. How is this any different from null? EDIT: Oh, I just realized ub is undefined behavior. That's a good point. What about a language like java? Is using the Optional class any benefit over null in java?
Why it so complicated? Sounds like simple thing, but so many templates there.
Or even terse `return {};`.
Dereferencing null is not UB in Java, it is guaranteed to throw a NullPointerException.
I needed a ThreadPool for something that I was working on, but I didn't see any that were just a single header or simple enough to just drop into a project and start using. So here's my solution, feel free to use/steal/do whatever with it. ~~There's no license or any of that shit.~~ Public domain, if it's messed up on github, please let me know. I probably won't make any changes to it, since it accomplished my goals. 
FYI, "no license" means "you don't give anybody rights to use it". If you want "do whatever you want", put it into the public domain.
Thanks for putting this out there. This is one of those things everyone has made for themselves at least once, and it would have been nice to start off with what you have, and modify it to fit the situation. When I looked a few years ago, I could only find overly-complex or compiled versions of this. A possible issue (and this is just a possibility, I'm not sure) is that I think you should explicitly check your wait conditions are satisfied after being notified, because of [spurious wakeup](https://en.wikipedia.org/wiki/Spurious_wakeup). Also, would there be a way you would see to easily modify WaitAll() to only return once all the jobs are actually finished, and not just running? In some situations it would be nice to know all the jobs have finished, but still be able to use the thread pool for more jobs.
Ugh, I hate all the licensing bullshit. I think it's right on Github. It should be in the public domain, I have the license from http://unlicense.org
It's important to play nicely with the C++ type system. Writing template code that behaves correctly with respect to different reference types (rvalue, lvalue, forwarding references, etc.), move semantics, type deduction, and so on unfortunately requires some boilerplate because of the many different "type states" (that's not a precise term) an object can be in. Adding in an arbitrary number of possible types not known ahead of time, the need to write exception safe code, avoiding expensive default construction, and so on makes things complicated. Take a look, for example, at the [libstdc++](https://gcc.gnu.org/onlinedocs/gcc-4.6.3/libstdc++/api/a01117_source.html) std::vector&lt;T&gt; implementation; it's about 800 lines. Sometimes these things just get complicated. Of course, you could write a resizable array class in about 100 lines at most, but would it handle all of the possible cases for the template type? What if the type isn't default constructible, isn't no throw copy constructible, or any of the many many other possible cases?
What you should actually do is use the predicate-waits provided by condition variables. Those are simpler and handle spurious wakeups.
You are not. I'm working on a couple other fixes, and that's going to be in there. 
What the hell now it is working. What sorcery is this..
It makes absolutely no sense to me to have the thread count as a template parameter. You could just as easily have stored the threads in a vector and set the size dynamically. Also, y u no use lock_guards?
Honestly, I'd rather have it assume the real complexity by renaming it to `xvalue_cast` than making beginners believing that because they call a `move` function, something will actually move...
Some countries don't have notion of public domain iirc. You *need* to have at least some form of copyright.
The company grew in six years from 60 to 700 employees, but mind you, not all are C++ developers. Hopefully this explains why you see an awful lot of job ads from e.Solutions.
Then what license should I use if I want it to be nonrestrictive? I do not care one bit what this is used for, or who uses it.
I used a template parameter and lock the thread count to a fixed size because it saved me time, and made the code smaller. I understand that some people might want to be able to dynamically set the number of threads, but for what I was doing that wasn't a requirement. It's ~5 lines of code to change it to be set via constructor. I don't care enough to change it right now just for the github version, because internally I'm using a template parameter for other reasons. The other issues that people brought up were real issues, and that's why I dealt with them. This is not a critical change, and yes, I could have changed it 10 times over in the amount of time that I spent writing this. No, I don't care. &gt; Also, y u no use lock_guards? Because there is a time and place for everything, and this wasn't one of them for `std::lock_guard`. I wanted more fine-grained control over when my locks were opened/closed, and I didn't want to deal with forcing scopes. I'd rather just write `mutex.lock(); mutex.unlock();` - it's clearer, and I can quickly change the locking logic. 
oh well. that's offically become too much work for 200 lines of code. 
&gt; Iterators need to be used for iteration, so it's unlikely an iterator would (outside debug) ever do checking as you describe Yeah, well, but you are a C++ programmer, most of the checking is debug-only. &gt; It depends on the lifetime, that's different than depending on the object. For instance, my object may contain a map, and have a method that returns the result of the lookup to the user. Then your object is not on container level and should thus make a translation from iterator to optional/pointer etc. But the find function operators on container/range level and thus uses iterators.
Why not get checking in deployment too if it makes sense? The thing is that it doesn't make sense for iteration, and it does make sense for one off look ups, for the reasons I gave before. These are two quite different uses and there's no particularly good reason to reuse iterators for an unordered container other than perhaps consistency with ordered containers, which may actually get some mileage out of it. Yes, naturally in my example I would perform the translation. But with lower coupling the translation wouldn't be necessary. You can argue about whether it's worthwhile or not, but the fact remains that it is less coupled to use optional. It's lifetime coupled but not scope coupled, if that makes sense. 
&gt; The thing is that it doesn't make sense for iteration, and it does make sense for one off look ups, for the reasons I gave before. It does make sense, it can prevent things like running past end(). &gt; You can argue about whether it's worthwhile or not, but the fact remains that it is less coupled to use optional. It's lifetime coupled but not scope coupled, if that makes sense. I can see your point and I think I know why we're discussing: find() returning iterator means "look for the position of that thing" while find() with optional means "look for that thing". They are different use cases.
It can, but it's not likely to in the idiomatic usage of iteration. That's the difference. Exactly. Different use cases have different optimal solutions. In this case, re using iterators has led to an optimal solution for iteration, but sub optimal for find. 
Just checked the source code Verbosity_NOTHING = -9, // If set as output, nothing is written // Do not use FATAL yourself. Prefer to use ABORT_F over LOG_F(FATAL) Verbosity_FATAL = -3, Verbosity_ERROR = -2, Verbosity_WARNING = -1, // Normal messages. By default written to stderr. Verbosity_INFO = 0, The answer is no as those constants do not conform to syslog rfc.
This article is an absolute shit post. There are a number of issues, the most concerning of which I think is this bit on references &gt;Replace pointers with references when parameters are required. This is easy solution, but caller can ignore it and still pass null value. To intercept such a problem during compile time - see not_null below. In well definite C++ code, a reference can never be null. The only way to do that would be dereferencing a null pointer like this int&amp; bad_reference = *(int *)nullptr; So no, unless the caller is being purposefully stupid and invoking undefined behavior, they cannot pass a null through a reference parameter. And if they do that then your function has no obligation to behave properly.
Looks still overly complicated. For example, why would you need the `second` part in the thread array? You could simply store the current task in the local variable in the thread function. Another thing I feel uncomfortable with is the multitude of mutexes. Essentially, there is only one concurrent resource - the queue. One mutex should be enough to protect it. And it there any specific reason to use `std::list` instead of `std::queue`?
I agree. One mutex, and 2 CV should do it.
Sorry I don't understand this. Boost is modular and to a large degree header only. There is zero difference in overhead using Boost.Optional vs something like std::experimental::optional. You can pick and choose the simple lightweight parts without the heavy template metaprogramming stuff.
I believe you probably want MIT, but I'm not sure. basically it says "do whatever you want with it, but I make no guarantees about it, so don't sue me"
fair enough. There may be other non-boost lockless queue implementations that could be inline in your header.
I don't want a ton of them - I want a standard one!
In case of student, probably you can assume it is invalid age.
Bloomberg -- we're always looking for C++ devs, both junior and senior. We have a number of people on the C++ standards committee and we have been publishing large swaths of our C++ libraries to GitHub recently (http://github.com/bloomberg/bde). The BDE team is run by John Lakos -- he has a book that a number of you may know. We have a *lot* of C++. Check out the Jobs site -- I see 105 job postings that mention C++: http://jobs.bloomberg.com/search/?q=C++&amp;sortColumn=posteddate&amp;sortDirection=desc
Thanks a lot! I've been meaning to overhaul my thread pool for a while, and when I do I'll probably start from yours since it is nice a readable.
http://www.gotw.ca/conv/002.htm You. You're Bob.
That's exactly what you must do. Dereferencing a null pointer is undefined behavior.
No problem! I just pushed another change that fixes a potential race condition, and removes some of the dumb stuff that I was doing. 
But that's the thing, see, this code is no longer portable because it relies too heavily on context.
what a piece of junk
I've not seen this project for years. Perhaps worth another look As an aside their mobile site is stupid
Isn't having a non-atomic bool variable 'stop' potentially a race condition if the thread pool is deconstructed (and set to true) at the same time as the thread worker checks to see if it should still be running? 
Both setting and checking `stop`happens inside `queue_mutex`, and DTor waits for the threads to complete. 
If you like this, you should check out the [Bloomberg logging library](https://github.com/bloomberg/bde/blob/master/groups/bal/ball/ball_log.h). It's very similar and the default output is totally customisable and you can add your own callbacks for variables etc. EDIT: [This page](https://github.com/bloomberg/bde/blob/master/groups/bal/ball/doc/ball.txt) is a better summary of the package.
No, it's not, it's incredibly slow.
There was an error in that part (string instead of int), so more invalid age appeared. Fix applied. 
You can save time on your main (producer) thread by moving the processing of the formatted string and the arguments to the consumer thread. That's what he means the "log-site". As for simple text files...I am not sure. Maybe he means a binary file? But that wouldn't be any quicker in my experience. In the end it's all writing to a file descriptor, and the writing speed depends on what that file descriptor is, whether it's a file on disk, a network port, shared memory, etc. The writing itself is indeed the slow part, because by the nature of computer hardware, processor speed and ram access time is are far far quicker than writing to disk/doing IO operations. Being a text file really has nothing to do with it, it's all binary in the end. Sure, text may be more verbose and require more bits to represent, but it's easily human-readable.
The [0-Clause BSD License](http://www.landley.net/toybox/license.html) should be as unrestrictive as it gets, while still being a "serious" license.
Just shove a MIT licence on it and be done with it, you can add one automatically with github (though I don't know if it lets you after the repo has been created?)
Well I've got a project very similiar to yours: https://github.com/lhecker/libnodecc I think it would be really great if we could merge our efforts since we're basically having the same aim anyways... :D But I also think that even if we'd agree on doing this it might proof to be very difficult to do so, due to the vast differences between our projects (e.g.: I don't like boost and thus try to avoid using it since IMHO it feels so cumbersome to use, which is why I'm currently using libuv instead, but plan on replacing it with my own custom cross-platform abstraction...). But you might find my event emitter interesting. I implemented those by requiring developers to define "symbols": static const node::events::symbol&lt;void(int param)&gt; s; At runtime the adress of the symbol is taken and used as the key in a map like: std::map&lt;void*, custom_intrusive_forward_list&lt;custom_std_function_base&gt;&gt; That way I can extract the function signature and reverse the used type erasure (simplified): template&lt;typename T, typename... Args&gt; void emit(const node::events::symbol&lt;T&gt;&amp; s, Args&amp;&amp;... args) { auto fn = static_cast&lt;custom_std_function&lt;T&gt;&amp;&gt;(this-&gt;events_map.at((void*)&amp;s)); fn(std::forward&lt;Args&gt;(args)...); } I did a lot of benchmarking for this and discovered that the above std::map with the custom structs usually outperform std::multimap, std::unordered_map and std::unordered_multimap (the latter 2 are not surprising since a map is faster that a hashmap if only a few keys are present). Surprisingly the std::map system above is even faster than using boost::flat_map even though it shouldn't since the flat_map has a better cache locality. You can find the emitter code at: * https://github.com/lhecker/libnodecc/blob/master/include/libnodecc/events/emitter.h * https://github.com/lhecker/libnodecc/blob/master/src/events/emitter.cc
Do you know of any loggers that do the formatting on the 2nd thread? I suppose you would have to use printf style instead of stream style logging though... :(
For people who like boost, using boost.asio looks like a good choice ([one example on stackoverflow](https://stackoverflow.com/questions/19500404/how-to-create-a-thread-pool-using-boost-in-c)). The code will be short, and you will not lose time to debug your implementation. 
A dynamic simd vector that chooses the instruction set at run-time is harder problem whose solution, among other things, needs to be able to create simd vectors at compile time for each architecture. Or in other words, that's the job for a different library, built on top of this one.
&gt; Unlicense ~~Unlicensed stuff is a nightmare if someone else wants to use it for work or on a project that will be available for others, please don't encourage this practice.~~ EDIT: Turns out [Unlicense](http://unlicense.org/) is an actual licence.
&gt; Cross-platform (but not tested on Windows yet...) :)
I did not know that, thanks for the information.
&gt; The only piece of sane advice in this article is to use references instead of pointers where possible. I don't think this is good advice either. The problem, for me, is that from the POV of the caller, passing to a function an argument by reference looks exactly the same as passing it by value. This makes keeping track of mutation in the body of the caller more difficult, e.g. in C++ "foo (x);" I have no idea whether x is possibly mutated unless I look at the declaration of foo, whereas in C (or C++ without mutable references) "foo (x);" definitely cannot mutate x (unless foo is some horrible macro). So I think it's better to use pointers instead of (mutable) references where possible because it makes mutation more explicit. Further, returning a reference instead of a pointer can sometimes undesirably invoke the copy constructor if that return value is used in a non-reference context, e.g. "vector&lt;int&gt; x = fn_returning_some_reference ();". If the fn returned a pointer then this assignment would be a compile-time error. So again it's an issue not being able to get a good idea of what a block code is doing at face value. Using references makes the behavior of code too implicit and too non-local for my tastes. In generic/library code I understand that references (especially const and rvalue references) are important for making usable and useful abstractions, but in regular non-templated application code I don't see the utility of references. "References shall always refer to a valid object," says the standard. Big deal! That condition is no more useful than "dereferenced pointers shall always point to a valid object." In practice, both of these conditions get broken and using references won't magically make your code more correct. So just use pointers!
Not all platforms that C++ runs on have SIMD or GPUs.
Thanks! I'm gonna look into this further, as I've heard of interesting work going on there. Gonna start polishing my DS+A in the mean time.
The best way I've found to is to define test predicates as constexpr bool variable templates that default to false with a true specialization(s) for the concepts. e.g, given namespace X { template &lt;class T&gt; concept bool HasFoo = ...; } define namespace models { template &lt;class&gt; constexpr bool HasFoo = false; X::HasFoo{T} constexpr bool HasFoo&lt;T&gt; = true; } static_assert(models::HasFoo&lt;Baz&gt;); It's a lot of extra typing, but it is at least simple and mechanical.
I had similar questions after watching Gabriel's CPP Con 2015 talk. For instance, what about debugging information or architecture-specific compiler flags (e.g., gcc's `-mavx/sse/fma`, `-march`, or `-malign-double`); in particular, different optimization levels? What about passing debug-level macros to the system includes like `NDEBUG` for libstdc++? Yes, there was the "export macro" flag, but that is much harder to deal with (you have to have foreknowledge that the module *needs* that flag) than just `-DNDEBUG`. I have a feeling that some of these problems have been considered by folks who use pre-compiled headers, but I think that bringing modules into the standard is going to shine a very harsh light on these non-uniform code-gen features of compilers. Of course at the end of the day, you can just *not* use precompiled modules and make your users compile it all. &gt;we also have direct AST serialization ~~Because llvm/clang doesn't use an AST, does that automatically put them out of the list of "compliant" compilers?~~ I was mistaken. Clang definitely [does](http://clang.llvm.org/docs/IntroductionToTheClangAST.html) have an AST. **EDIT**: ~~That last comment wasn't intended to sound as snarky as it does. I genuinely want to know if this will be a problem.~~ Also, I come from a position in high performance computing where exporting functions that use CPU-specific code is common.
&gt; Most importantly the current date is not part of the the preamble E1107 &lt;-- that is a date.
&gt;These days, you really shouldn't be writing code that isn't modern (C++11 and above) I'm still stuck with the requirement to use C++03, because there isn't a C++11 cross compiler for the toolchain I'm using. I wonder how many developers are still in that position? 
What do you mean "doesn't use an AST"?
Std:deque is a container adaptor. I don't know if it provides its own allocator, I suspect not...
I think you mean one log consumer and one or more log producers.
Oh - good to know! This is why loguru has an explanatory header for the preamble ;)
I spent a hour today and took a look at asio... And you know what? You're right in your choice to use it - asio is actually really good. Especially since I found out that there is a standalone version which is able to use C++11 features and doesn't define it's own types for everything (e.g. boost::error_code instead of std::error_code). I might actually port my code over to it as soon as I've got time for it. :) Regarding the unordered_map: As I said it's almost always slower than a map if you only have a few dozen or so entries in the map and only a simple numeric type as the key. And if you use strings as the key type for the event emitter: how do you make sure that the argument signature while calling emit() is the same as the functor signature while calling on()? I mean... somehow you've got to transfer the type information right? The only other way I can imagine is to use dynamic_cast but that doesn't allow compile-time assertions.
Why not have it plot any 2D scene? a.k.a. running games in your taskmanager
Easy and transparent
Thanks for writing these! I find them really helpful. One thing I don't quite understand is why having a lot of small jobs is better than having a few large jobs that you don't split up. You use the example of keeping each block small enough to fit into L1 cache but if you just iterated over them all at once they would still be in L1 and you wouldn't incur the cost of spinning up/processing a bunch of new jobs. Additionally, if you process them all at once, wouldn't there be better utilization of the L2/L3 since you're not switching between cpus or interleaving those jobs with others that process other data and blowing the cache? 
The callback methods are type erased. So the error if the arguments are incorrect is thrown at runtime. I used boost::any to store the callbacks.
[I wrote one too!](https://gist.github.com/jrandom/08048c79ce0c752e9160). It's a good exercise in learning the new native threading tools. (Although I need to update mine to store `std::future` objects to make it more versatile.)
There is no efficient and reliable way to pass the arguments that I know of (see https://www.reddit.com/r/cpp/comments/3rwfs5/introducing_loguru_the_user_friendly_logging/cwu9tz2). Oh, unless by printf-style you mean that you restrict yourself to barebone integers/floating points that are thus copied very efficiently but awkward to format and do not log anything more substantive?
Every time someone claims that a library is "high performance" without providing actual benchmarks, a kitten dies. Please back your claims properly, as some people could actually base important decisions on those claims (like choosing one library over another). Glancing at the code just 5 minutes, I found that the `DEFINE_JSON_ATTRIBUTES` macro creates a `std::string` when the enclosing object is constructed. This has several problems, like throwing away PODness, making constructors potentially throwing, and the sheer performance implication of creating a `std::string`. You could easily make all of this 0-cost by using compile-time strings and switching the computation of the members to output to compile-time.
I can't remember where I read about clang not having an AST. I may have misinterpreted what the LLVM IR was really doing. Thanks for the clarification!
[Maybe you meant MSVC++?](http://blogs.msdn.com/b/vcblog/archive/2015/09/25/rejuvenating-the-microsoft-c-c-compiler.aspx)
The deadline for sending in papers was last Friday. I would expect the mailing to be available sometime this week; possibly as soon as today.
That's hipster C++! Funny 
 This python script (100 lines), scans a given json file and generates c++ classes that are able to parse such a json and store each json property into a class member. Relies on an external json library; only provides load support, no save; does not allow json subobjects. But script can easily be extended and the approach seems interesting - since using the class members is safer than using a map (so error prone at runtime) - which is what all json parser libs are doing.
I agree with you that starting with CMake is hard, but don't give up! Once you begin to master it, it's a great build system, and the multi-platform ability is awesome.
maybe you mistaken it with msvc, which indeed doesn't use AST.
Exactly. On many platforms, you cannot really control which job gets executed when and on which core, so you have to try to strike a balance between job granularity and the costs of inserting new jobs. Additionally, processing all items at once wouldn't work in cases where some other jobs depend on the job being performed. All those jobs would need to stall and wait until their dependency has finished. 
I mean, I could probably sometimes forgive using new/delete in modern C++, if you're careful, and so on... But what the actual fuck is malloc doing in C++code?! Also, [it doesn't seem to escape characters](https://github.com/ymglez/jsonpack/issues/4). What even.
I meant what I said, but yes, generalising, there is a 1-to-many relationship between consumer and producers.
This is a very good point. For strings, I have a wrapper which marks them as "this string will definitely not change by the time we log it, pass by reference", and "this string may change by the time we log it, copy it". This makes logging static strings very cheap indeed, but you will get a small performance hit for non-static strings. This accepted and known, and in general I try not to log non-static/constant strings unless I know I can take the hit/this log line is important enough, or if we are off the "hot path" of our code (ie copying the string won't slow us down here) For complex objects, the object is copied from one thread to another using placement new and it's copy constructor. The memory is already allocated so copying is not THAT bad. Additionally I try to keep my classes minimal and restricted to doing one job, so generally a "complex object" for me is just a struct with a few primitives inside it, which turns out to be pretty fast to both copy and log. In the end, it really does end up being just primitives and strings that are logged, with some fancy code to copy objects and print their primitives. If you are trying to log objects with tens or hundreds of members, each of which are themselves complex objects, then you missed a software design course somewhere down the line.
I just with CLion was a little more performant. In my gigantic work code-base reloading a CMakeLists can cause my IDE to go unresponsive for 1-2 minutes.
I've never counted - I'm only concerned with my small little corner of the source tree. Still, it's disappointing that the CLion parser can't manage its memory better. Linting and code completions should never cause the UI and main program to suffer.
Awesome. Thanks
From the description: &gt; TensorFlow comes with an easy to use Python interface and a no-nonsense C++ interface to... What do you think they mean with "no-nonsense C++"?
That's not going to happen soon, if ever. CLion is written in Java and they use [antlr](http://www.antlr.org/) for parsing. Antlr has a java runtime. libclang is written in C++ and one would have to bridge it to Java. Better luck with Qt Creator and KDevelop, they both have libclang integration. 
 pentium4-g++ (GCC) 3.3.1 Checking in :(
It's not a questions of the LOC, but more about the complexity of the whole prj, heavy usage of templates/variadic templates, C++11, etc. Anyway, in most cases increasing the xmx helps a lot (https://intellij-support.jetbrains.com/hc/en-us/articles/206827537-Configuring-JVM-options-and-platform-properties). If not, it's better to send us a CPU snapshot (https://intellij-support.jetbrains.com/hc/en-us/articles/206827577-Reporting-performance-problems) and thread dumps (https://intellij-support.jetbrains.com/hc/en-us/articles/206827507-Getting-a-thread-dump-when-IDE-hangs-and-doesn-t-respond) to investigate. And if CMake command is running too long, maybe it's worth switching off the CMake auto-reload feature and call it manually. The point here is that changes in CMake can affect the code parsing in the editor, since a lot of information is taken from your CMakeLists.txt files.
We currently have a very short CMake tutorial in help: https://www.jetbrains.com/clion/help/quick-cmake-tutorial.html. And we are going to extend it quite soon. And of course you can use official CMake documentation and wiki. We also hope to get smth done together with the Kitware. Trying to communicate with them now about this. Not sure about the result and ETA.
I'm going to guess "simple &amp; unoriginal"
I like the idea of `constexpr_if` as I think it provides most of the benefits of the original `static_if` proposal without all of the drawbacks (e.g. it introduces scope as we've come to expect). However, I don't like adding a new keyword (constexpr_if) for it and I certainly don't like adding two (constexpr_else). Is C++2x then going to add `constexpr_switch/constexpr_case`? I suggest simply: if constexpr ( ... ) { ...; } else { ...; } The main justification for the original indivisible `static_if` was due to the fact that it was a conditional structure so vastly different semantically from the usual `if-else` structure. This isn't a problem with `constexpr_if`.
&gt; then you missed a software design course somewhere down the line No, I just have a complex reality to deal with.
&gt; IMO this should be avoided. For very high performance logging? Probably. But that's a specialized need, so warrants a specialized solution. In my server, the bottleneck is the database; interactions with the database need be optimized, the rest, such as logging, can get away with merely being fast enough.
It's really hard to extend this approach beyond trivial use cases. The problem is JSON just isn't expressive enough to handle non-trivial data, and without a schema you can't do anything except rudimentary and rather inefficient data-structure mapping. You need additional configuration (e.g. doubles or ints, maps or vectors, optional fields etc etc) I'm more or less convinced the way to do this sort of thing is start with a generic serialisation layer like Boost Fusion and work the other way. I wouldn't mind seeing a JSON + JSON Schema equivalent to [XSD](http://www.codesynthesis.com/products/xsd/) though. 
The multiple choice questions seem to use radio buttons instead of checkboxes
What was the reason of renaming static_if to constexpr_if and why using constexpr_else? Isn't it obvious that when you begin the if statement with constexpr_if then the following else also has to be constexpr?
They've been fixed now.
Just fixed them now, thank you!
Hi, I'm not sure what you have in mind, json is trivial. The script is far from perfect, but does a few things well: generates int for json integer numbers, float for json fp numbers, std::vectors for json arrays, std::string for json strings, bool for true/false. A json object becomes a c++ class. What else? std::optional is easy to implement. std::map needed where? 
Q5 should be a multiple choice question. I use: CMake, Make, Scons, and Ant. The survey only lets me select one. Q1 should probably not be multiple choice ("which of the following platforms have you developed *most* for...")
this is not my script, I found it, shared it and now customizing it (to allow json subobjects and save support); Yes, json::value makes sense in the ctor. But I love how simple the script is and how useful the generated code.
Well for a lot of people, including me, it's a big BUY argument if an IDE uses libclang for parsing. At the same time, their own parser will never be able to keep up with C++14, 17, and what's coming. I think it must be a net-negative for them in the long run. But in general, competition is good - so let's see what they can do. _Edit: And actually their Java-implementation is quite a memory and CPU hog. I wish they used C++ to program their IDE :\_
Agreed. Still thinking about the poor souls in this scenario: http://blogs.msdn.com/b/oldnewthing/archive/2015/11/09/10653237.aspx#10653371
&gt; libclang is written in C++ libclang is C
what do you like about it?
&gt; Allowing the evaluation of a concept anywhere (such as in a static_assert or a constexpr_if), not just in a requires-clause, was approved. Well, that answers [a question I had](https://www.reddit.com/r/cpp/comments/3rie9i/best_practice_and_syntax_for_ensuring_a_class/).
Video 13 is set as private.
Read again: &gt; A suggestion to remove &lt;...&gt; was rejected &lt;...&gt; So the feature stays.
That's why I was hoping for a proposal which provides exactly this. I really would like to see extension method in C++. I think there was even one more proposal somewhere which wrapped extension methods in kinda namespaces somehow...
I wasn't clear. My incredulity was at the mere proposal that it be removed. I.e.: who would propose such a thing??
&gt;&gt;A proposal for looping simultaneously over multiple ranges was not heard because there was no one available to present it. &gt; Too bad, I really like this idea. In range-v3 (and STL2) you will be able to use `view::zip(r0, r1, ...)` but that is arguably less ergonomic than that particular proposal since you get a tuple of references that then need to access with `std::get`. Still, there are alternatives to that particular proposal. For example better destructuring/pattern matching would allow `view::zip` to be as ergonomic as that proposal, while at the same time being also useful in a wider range of situations.
It is kinda weirdly different from how the language usually works since it's putting a metatype in a place where a type usually goes, but I think it's definitely different in a good way.
So even Microsoft releases now have building on Windows as second thought, judging from the readme. 
Probably it shall appear in the post-meeting mailing, which is expected any day soon.
I believe it was renamed so it wouldn't be confused with the other proposal. 
You could probably #include something.h from your module file. Just put the #include after module directive
Rogue Gaming Studio is looking for a strong C++ developer. The ideal candidate has working knowledge of C++11/14. We make games for the casino industry. The position is in Reno, NV. More details can be found in the link. http://www.indeed.com/cmp/Rogue-Gaming-Studio/jobs/Software-Engineer-be5b012d1c4ba864
I don't recall this being discussed explicitly, but my guess is the reason for using 'constexpr_else' instead of just 'else' is that the 'constexpr_if' keyword could be "far away" (as in, off-screen) when you're looking at the 'else'.
I was one person expecting "for-free" dot chaining.
People who were concerned that you could write a declaration that doesn't look like it declares a template, but does.
And where is results?
C++14 already has that situation: auto lambda = [](auto i) { ... };
I'm sceptical. We already have hundreds of visual programming languages; have a look at this page for a (somewhat horrifying) snapshot: [http://blog.interfacevision.com/design/design-visual-progarmming-languages-snapshots/](http://blog.interfacevision.com/design/design-visual-progarmming-languages-snapshots/). They're quite successful for doing simple domain-specific tasks, but that's as far as they go. Given that we've been using them for nearly 50 years now, that's likely to be a fundamental limitation, not a deficiency in current implementations. We already have much more accessible programming languages than C++, e.g. Python. Learning basic Python is really no more difficult than learning a visual language, and there's a very natural growth curve to more advanced and powerful techniques.
Qt Creator finished the libclang integration long ago, and then didn't make it default because the performance is not good enough. So Qt Creator has a custom parser and it's pretty good.
Evaluation order finally matters! #include &lt;map&gt; int main() { std::map&lt;int, int&gt; m; m[0] = m.size(); // `m[0]` is now specified to be 0 } 
Great! Love getting his critical analysis of specific features/changes. It's the next best thing to a D&amp;E2.
It was [unspecified](http://stackoverflow.com/questions/15865627/is-indexing-a-new-map-element-and-having-something-that-reads-it-assigned-to-it#15866238) rather than undefined.
Even the [C++-core-guidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#-sl50-avoid-endl) recommend against the use of `std::endl`, so you really shouldn't show that to beginners. 
Previously, `noexcept` acted as a flag for the compiler (like `inline`) Now, `noexcept` can be passed around as part of a function's type (like `const`/unlike `inline`)
noexcept may be intended as an optimization, but since it requires the program to terminate when an exception is thrown.. it actually slows shit down and prevents inlining. Thanks to the genius that thought noexcept should terminate. 
 My experience with visual programming(UE Blueprints) was not a positive one. The information density is too low, it becomes scrambled eggs.
What would you suggest it do?
 Prevent you from calling functions that aren't marked noexcept, and not allow you to throw. No need to check for shit then. Or just don't insert checks for exceptions, and let it fail however it fails.
How about functions that can throw `std::bad_alloc`? You wouldn't let `noexcept` functions use `std::vector`?
from what I can tell [this](http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2855.html#problem) was the main motivation
 And thus throw() was reinvented with another name. See Sutter on throw() http://www.gotw.ca/publications/mill22.htm "rather than letting the compiler make optimizations by assuming only certain exceptions will be thrown, it’s exactly the reverse: the compiler has to do more work to enforce at runtime that only those exceptions are indeed thrown." "Besides the overhead for generating the try/catch blocks shown above, which might be minor on efficient compilers, there are at least two other ways that exception specifications can commonly cost you in runtime performance. First, some compilers will automatically refuse to inline a function having an exception specification, just as they can apply other heuristics such as refusing to inline functions that have more than a certain number of nested statements or that contain any kind of loop construct. Second, some compilers don’t optimize exception-related knowledge well at all, and will add the above-shown try/catch blocks even when the function body provably can’t throw." Replace "only those" with "any exception" and we get noexcept.. The reason I'm anti-noexcept is because I went through my codebase and added noexcept where it made sense. When I compiled I got a bunch of warnings(as errors) about shit not getting inlined even though it was marked forceinline. Eventually after fixing that, and getting the program running, it turned out it was *slower*. I investigated and discovered that the compiler was no longer inlining tons of shit. Thanks noexcept. 
then vs2015 isn't a modern compiler
C++ developers should be encouraged to do EVERYTHING on the stack if at all possible, since this gets you near guaranteed destruction as well as more efficient memory management. C++ is fairly unique compared to Java/Managed languages, since it treats user defined types as first-class types in a way that others rarely do! IF you DO need to store something in non-stack situations however, look into RAII and smart pointers, which should have similar semantics, but guaranteed deletion. So instead of: void foo() { Thing* t = new Thing(1,2,3); // Do stuff! delete t; } Which has the danger of Do Stuff throwing an exception (thus leaking t!), you would do: void foo() { std::unique_ptr&lt;Thing&gt; t = make_unique&lt;Thing&gt;(1,2,3); // Do stuff! } Which gaurantees that when t goes out of scope, it is immediately cleaned up. That said, in this contrived case, you're better off puttiing t on the stack, such as this: void foo() { Thing t (1,2,3); // Do stuff! } Which has the same gaurantees as the unique_ptr, but is more memory efficient and performant. 
I'm not on the committee, but it sounds like the desired wording is that it would perform a copy from out of the returned `std::pair` into `min` &amp; `max`. This is basically the same as `std::tie(min, max) = std::minmax(0, 1);` However, like other return values, they want to find a method that makes copy elision possible so that `std::minmax` actually initializes the variables directly rather than bothering with the intermediate `std::pair` at all. No idea what that would look like, especially given that they want to ensure it works with user types and not just `std::pair` and/or `std::tuple`. **Edit:** formatting
It really isn't.
On a non-technical note, I found this very interesting: &gt; Note that we don’t approve proposals by simple majority, we aim for consensus and consensus is defined as a very large majority (3-to-1 would be marginal). The alternative would be for a large angry minority to lobby against an “agreed upon” decisions and/or creating dialects. Consensus is essential for long-term stability. I hadn't really thought about how approvals worked, but in the end I'm very glad they strive for consensus. Simple majority wouldn't lead to a stable language. Also interesting to see the difference between a language run by a BDFL vs ISO WG. I imagine that Bjarne has a notable influence whenever he talks, but the committees aren't beholden to him at all. 
Sublime Text and Atom are missing from IDE list, so I had to fill in VIM as the first one, since my favorites are missing.
PlexChat is a newly venture backed startup looking for a C++ developer to power a new real-time messaging and social cross platform application for gamers! If you like C++ and thinking about distributed systems, please drop us a line! We're located in Redwood City and unfortunately can't do remote at this time (although this is mainly because we're only 2 engineers right now). Take a look at our listings here: https://jobs.lever.co/plexchat
Only if one tuple exists in the container returned by `f` Sorry for the confusion, my f has a different type signature from GP's vector&lt;tuple&lt;T1,T2,T3&gt;&gt; f();
~~Pics~~ self-contained repros, or it didn't happen.
yes, `x.first().second().third();` is much easier to read than `third(second(first(x)));`
Not really the same situation, since using `auto` as a lambda parameter will always make a templated function, while with the concepts shorthand `(Foo x) { }` may or may not depending on what `Foo` is.
&gt; After you gain enough experience to know what's in std The problem is that I am willing to bet that the number of people who know everything in the stdlib is super-tiny if not nonexistent and I am 100% sure that there are zero people who know everything that will ever be in the stdlib. 
True. At least in the case of a compiler error instead of silently doing the wrong thing, the error becomes pretty recognizable if you've seen it enough times (*cough* SO), plus you train yourself to immediately include this as a possible reason. That said, I still use std::