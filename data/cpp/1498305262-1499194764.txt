 Finally found out my build fails were caused by having build timing enabled when I spotted this on developer community. [bug]https://developercommunity.visualstudio.com/content/problem/52887/random-failed-build-when-vc-build-timing-is-enable.html?childToView=72502#comment-72502 
Skype was good as well, until they recently started displaying ads (in the Windows Desktop client). It's so annoying, the mouse is spinning all the time when they reload, and they show even during calls. And don't even get me started on the new re-worked Android app, haha :-) So ridiculous. Before that, Skype was great - multi-person voice, video, and screenshare. And great echo-cancellation. Ok, just the bandwith usage is a bit high, even for voice. But you're right - MSN was there too and about 18 years earlier ;-)
~~Not to mention that identifiers starting with two underscores and a capital letter are forbidden according to the standard.~~ (Edit: Thanks dodheim. Identifiers with two underscores are forbidden but these two are of course not as they're "pre-defined" by the standard.)
Can't wait until JetBrains will start rewriting their IDEs to a _faster language_.
I don't know about Windows, but on Linux the coredump should give you valuable informations. You can also handle signals like SIGSEV or use a backtrace lib like https://github.com/bombela/backward-cpp/
Because it runs in electron which is basically a full web browser, making it super slow (for what it's doing). It confirms the prejudice that web devs always reinvent the wheel and use the worst possible tools for the job because they actually have no idea of programming outside of their web ecosystem. 
&gt; You can write very pretty Haskell and it'll still be much much faster than Ruby or Python a statically typed language is faster than a dynamically typed language, shocking 
why rewrite when there's [Xi](https://github.com/google/xi-editor)
BUT MUH PRODUCTIVITY!!
Yeah, that's what I meant. I forgot to use the qualifier 'most', even though that was the intent. But conferences do tend to be a bit more general like "Here's a clever trick", or "Here's a new feature we've recently added". I've read more than a few blog posts where programmers claim to have invented a trick and I either recognize it from another language or can find with 2 minutes or less of googling.
Interesting. Thanks for letting me know. I'll follow up on this issue.
&gt; Industry calls them conferences instead. Conference papers get collected and published. It's one of the quirks of CS that the most consequential "journals" are published annually. But they're still papers. The real problem is that they're almost entirely behind the ACM and IEEE-CS paywalls. 
it is an editor after all, so not very demanding from the beginning, but considering how much features it has, it is indeed pretty slow. I think a lot of this hype around atom and VSCode was also from web devs who have never used a proper IDE and now discover proper auto-completion for the first time.
&gt; I still can't understand its nature, how to use it, I just don't get it. CMake defines a list of targets (things that end up being built such as libraries, executables, etc). Targets are key-value maps: linked libraries, include directories, etc... are all keys of this map. Such a key-value pair is called a property in cmake lingo. Such properties can be `CXX_FLAGS`, `LIBRARY_OUTPUT_DIRECTORY`, ... the whole list is [here](https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html) Functions such as `target_link_libraries(myapp SDL)` are convenient ways to set the value of such keys. They work by appending, not replacing. Variables that begin with `CMAKE_...`such as `CMAKE_CXX_FLAGS`, `CMAKE_LIBRARY_OUTPUT_DIRECTORY` will be used to initialize the relevant properties automatically. That's more or less it.
&gt; Use _DATE_ and _TIME_ macros, which gives you something but usually these are meaningless as often your code will be built by a server many times a day. Please *don't* do this. This prevents having reproducible builds. 
Exactly, I do agree, but for some situations you might want something like that (for example a one-off release build).
Having a clean binary format for C++ interfaces will be revolutionary for the language. What you suggest isn't possible right now because not all of the module code ends up in the interface file. Templates do, but most code does not. But we should endeavor to create a good, standardized IFC format that enables all kinds of tooling. Note that tooling was called out in the first C++ Modules proposal as one of the four benefits of the feature. 
Yeah they failed on first step: pick Java.
Get the product to users first, optimize later. Don't see what's so astounding to you. Pretty standard practice in software industry.
C++ grammar allows [attributes](http://en.cppreference.com/w/cpp/language/attributes) to appear before any kind of statement. In most cases the attributes appertain to the whole statement (except that in a declaration statement like `[[attr]] int x;` the attribute appertain to the entities declared by the declarators, like `x` in the above example; and in a labeled statement, the attribute appertain to the label). The only practical use I know is `[[fallthrough]]`, which only applies to a null statement.
VSCode is made in Electron and is not slow. It is becoming the stantdard text editor to use for webdevs.
Point was that _new-expression_ has something that make_unique/shared don't and therefore can't be completely replaced. Whether you are going to ever use it or not is not really important here. I found myself creating quite a few of these _static Foo makeFoo()_ functions because in my class hierarchy I needed to do some extra work before object construction. Constructor can't (conveniently) do that -- it has to construct member variables before it can execute 'freestyle' code. And in general -- I dislike special status of constructors. Semantically they are not different from any function that returns a value of type T (syntactically their implementation differ, but from client's perspective it doesn't matter -- both take arguments and construct value at memory address provided by caller). If you remove this special status off of them -- this will allow for things like passing 'constructor function' address (with default = &amp;T::T) into _make_shared()_ along with parameters. Have to do smth with function overloading, though... Maybe invent new type of function pointer -- _overload-set_, perhaps?
Of course, that's another topic.. If ownership is clear, there is no need to use smart pointers, maybe only unique/scoped ones, when it has a block level lifetime...
Almost everything ends up on google scholar... That's not an excuse
The hundreds of dollars is merely what allows you to pay more for access to papers. It's really sickening and the main reason I let my IEEE membership lapse. Lowest tier for papers was something dumb like 35/mo for access to 5.
So bool++ is upvoting ?
 int i [[cats::meow([[]])]]; // OK I see you there /u/STL :)
The best part of this post is the mention of one of my favorite books: Code Complete. 
Would a generic std::make_instance work here? http://cpp.sh/8vhmr I tried to use operator() but the *template operator()* syntax is considered to be an error (C2951).
No it is not. Didn't lag a single time for me
I've never used it before now, the need to specify the types separately had me a little confused.
Still, that thing has GC and lots of useless operators and syntax. I don't understand why with one good idea everyone manages to pack a dozen of irrelevant opinionated bad ideas in their language.
Ah. In that case, I would rewrite it like [this](https://wandbox.org/permlink/g6eQ3ZG5fLxaiyaG) so that isn't necessary in the first place. :-]
&gt; If you like static types, you don't need hard real-time responses and OK with C++/5 performance (which is very high in many domains), then Haskell won't disappoint you. I'd go with Go then.
Maybe try the QtCreator IDE. It provides a visual debugger while using GDB internally. For compiling - CMake (QtCreator opens and builds your CMakeLists.txt directly). Then you can also build (cmake and make) and debug (gdb) the same project from cli if you wish.
Indeed, having a proper debugger set up can save you loads of time, and having that integrated with your IDE is very convenient. In the past at work I've usually used Visual Studio, which I've found works pretty well (though you won't be able to use all of the upcoming C++17 features yet), and more recently I've started looking at CLion (which is not free, though there is a free trial). Eclipse can also work, though I'm not a very big fan. All of these IDEs provide wrapper interfaces around a debugger (often gdb) that makes debugging very easy. That being said, I often just use vim and gdb, especially if I'm just hacking away at a smaller project. If by chance you want to use vim, I'd definitely recommend checking out [clang_complete](https://github.com/Rip-Rip/clang_complete), which provides code completion in vim that's comparable to the IDEs (though a little bit more involved to setup).
Hello, Thank you for your reply. I will avoid Qt for now as it steps away from the standard library which I need to learn.
Hello, Thank you for your reply. I am on Linux and Visual Studio runs only on Windows. Do you have any good resources on GDB? At this point I would rather learn the basic stuff instead of delegating the work to third parties (that way I can't really learn how things work behind the scenes)
+1 for CLion, and QtCreator. You could give Visual Studio *Code* (runs on Linux) a try too, I believe they added debugging in latest version? People like kdevelop too I think but I have not used that.
The Alpine Linux distribution is built around musl C library which is statically linked. Therefore all the packages are built around this premise. Most other distributions are built around libc which is designed for dynamic linkage. If you build on another distribution, unless you are real careful, it is easy for you to have a libc dependency which can make portability a problem.
Yes, more or less as long as you use the Alpine Linux packages.
Indeed, that and the fact that you can have a small team 'optimizing' the core, and a larger team that's technically less skilled focusing on 'features'.
&gt; Rust certainly brings more to the table in terms of potential than D, as far as I'm concerned. Can you expand on this? I found rust to focus tons of resources on things I don't care that much about (probably because of my application domain). D doesn't have the big agenda that motivates taking the leap from c++ but has tons of small quality of life stuff, like super-fast compilation that has me gravitate towards it for hobbyist projects.
A little offtopic, but does anyone know any similar tool that can be used for free in any project?
Industry conference papers/presentations are not peer reviewed 
Neat. /u/emildotchevski the docs say that this library uses a different path when the return value of a function supports an invalid state. What happens with: int make_negative(int i) { if (i &gt; 0) { return -i; } else { return throw_(); } } auto f = try_(make_negative(1)); auto f = try_(make_negative(-1)); 
We offer free licenses for students and Open Source contributors now, see bottom: http://sourcetrail.com/buy-license Why does it have to be for free?
The library doesn't assume any semantics for the return value, though it does need to know what to return from throw_ return expressions (that value is specified by the throw_return&lt;T&gt; template, T being the return type of the throw_ calling function). Ideally the caller should be able to tell by the return value if there is an error, e.g. a null pointer or empty shared_ptr. If not (that is, the value that throw_ would return could also be returned in case of success), you'd call has_current_error() to check.
Sure they are, by the audience that gives their feedback to the organizers at the end, and by the organizers that decide what gets shown.
I know you do :-). And there's nothing wrong with that. Let's just say I work in a company where it can be hard to request from them to buy commercial licenses for this application for only a few people. 
Too much bureaucracy. 
I see, well, where's there's a will, there's a way. Let me know if I can assist in any way.
What happens if I don't call `has_current_error()` in the example above? (Or if I don't call `try_` ?)
The original code for facebook was written in 2003, by then Java already had a its HotSpot just in time compiler for three years. However I don't know how hard it was to get a server with Java set up and ready to use back then. 
How is that different from exceptions?
I'm really interested in seeing benchmarks against monadic return types and "traditional exceptions". One thing that really bothers me is the name you chose for the library: "noexcept", really? It is the same name as a C++ keyword, which makes your library quite hard to find via search engines and causes ambiguity when discussing it. It's like calling a C++ library "int". I advise renaming when you still have the chance.
Good job! I will definitely have a look at your library. Right now, I am using Google Benchmark and the syntax can be really annoying at times. One question though: Is there a way to let the library estimate the complexity class? Google Benchmark has once helped me get rid of an unwanted O( n^3 ) that I didn't intend.
Having a bad feature is not bad really. You just have to not use it. But without good features what else do you use? Another language?
That's a good point. The segfault will happen before the library has a chance to let you know that you ignored the error. However, that's no different than regular exceptions. Having said that, this seems like an excellent solution when exceptions cannot be used (games industry). 
Thanks. No, there is not. I've never thought anybody needs that feature. We were focused only on absolute values in our project. Well, if you find this feature critical, I should add it in the future releases.
I've never heard about nonius before. Thanks a lot!!! I will try to add comparison of sltbench and nonius.
How are you getting the start and end times? How many times are you running the test? I'm not a big fan of googlebench because it runs the test way too many times. That doesn't provide a realistic result, since for most of the test runs, the branch prediction will be perfect and the data will be in the cache. Intel has a [good paper](https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/ia-32-ia-64-benchmark-code-execution-paper.pdf) about using rdtsc and cpuid to get very accurate timings. One thing it doesn't mention (likely because this wasn't the case when it was written) is that all major compilers provide intrinstics for these instructions, so you don't need assembly. Also, compiler it as a kernel module is neat, but it has the unfortunate trade-off of only allowing you to test C code on a Linux machine (as well as requiring super user privileges). Finally, one thing to keep in mind is that `std::chrono::high_resolution_clock::now()` will have an extra overhead for the first call because of dynamic function loading.
Another strong competitor to googlebench is [Celero](https://github.com/DigitalInBlue/Celero).
1. Start and end timestamps. If function execution time is too long, it is just surrounded by `high_resolution_clock::now()` calls, otherwise function is called several times to acheive "minimal measure time when timer function error is within required tolerance error" and those several calls are sourrounded by `high_resolution_clock::now()`. 2. It is a really big problem to provide realstic _and_ reproducible results. If you want cache cleaning, you may introduce this in googlebench and sltbench manually for a conrete test (there are some hacks to do it). I wouldn't blame googlebench or another framework for multicall cache and branching problem because it is really hard to take into account all possible cases when providing cache cleaner. For example, there are extremely fast functions that requires hundreds of thounsands of calls to make single quite good measurement. And if you try to inroduce cache clean for this (which is much slower), you will get hundreds of thousands calls of slow function, when target function execution time is just an error of cache cleaning function execution time. That's impossible to measure. 3. Thanks for a paper, I'll read this. 4. Thanks for the note about dynamic function loading! Fortunately, it is not relevant to sltbench so as high_resolution_clock::now() will be called many-many times before the first measure function started.
Thanks, I'll look for it.
Calling it noexcept is a terrible idea. It's like that library called Modern C++. Good luck finding it with Google.
I was indeed confused, withdrawn!
Well, yes, without exceptions it is impossible to enforce postconditions, and you need to check for errors. Using Noexcept, you could still wrap the return value into something that won't let you use a bad value (e.g. optional&lt;T&gt;), but again -- if exceptions are disabled, what could you do in that wrapper if the user tries to access the value when it's not there? Is that going to be significantly better than a crash?
Exceptions blow through the stack, which make them impossible to use in environments that are not exception-safe. For example, using Noexcept you could return an error from a C callback, then as soon as control pops out into C++ you could: auto value=try_(f()).get(); which will get you a good value -or- throw the Noexcept error as a C++ exception.
Why is the naming style for classes/structs seemingly random?
Oh, your example is ill-formed, return throw_() (without arguments) can't be used if there is no current error. If you had: int make_negative(int i) { if (i &gt; 0) { return -i; } else { return throw_(my_error()); } } auto r1 = try_(make_negative(1)); auto r2 = try_(make_negative(-1)); then r1 will hold an int with value -1 (success), and r2 will hold a my_error (failure).
Against traditional exceptions it would be a very interesting benchmark indeed.
I think shared pointer recounts being non atomic would be the least of your concerns if you managed to compile your binary in single threaded mode and spawn threads at the same time :)
I will stick with ssh :P (And it also runs on Windows.)
Is that really true? I imagine if you capture an int by value a change to that int in the lambda function will not propagate to the outer int. Whereas with a reference it would.
I meant performance wise…
Did you actually check out the tool? What can and can't it do that ssh does?
I read some of the doc does it require port can it be tunneled via port 80 and reverse connected ?
If you capture an int by value then attempting to change that int in the lambda function will yield a compiler error (unless you declare the lambda as mutable). ;-]
The so called old guard was instituted organically specifically to progress c++ and the std lib. It has done that (bind, lambda, etc). I feel like your comment doesn't give these people their dues, some of whom went on to create another language (swift). I'm sure you didn't mean that so I'm just responding to your comment so others understand where Boost came from.
We used boost on a project recently. I think including 1 header pulled in 50,000 lines of code. As soon as you end up including `boost/thread.hpp` it's game over for compile times. You suddenly have to use pre-compiled headers and all the rest of that junk to make anything work. Was that part of the original vision?
I don't understand how your proposal solves the problem. So if I want perfect forwarding, I still need to use forwarding reference and `std::forward`, but I will be able to declare a (non-template) function that implicitly move its arguments (even when and where I don't explicitly write out "it should be moved here")? And how does the body of the `Standard` function look like in assembly? Will it have a bunch of branches under the hood?
It's a problem when you are using CodeLite and MSCV on a 10-person project and no one has any idea how to compile C++ beyond clicking "Build &amp; Run" or "Build &amp; Debug".
There are a number of very valuable boost libraries and I don't think anyone would deny that it's been good for the language. However, to achieve that second goal, the website and documentation need some serious work. It can be difficult to pick up a new boost library and hit the ground running.
To be able to say it's over engineered you first need to understand the requirements. First, the test matrix for boost is something like 100 compilers: http://www.boost.org/development/tests/develop/developer/summary.html Some of the libraries are very old, and supporting all of that is tricky, and 15 years ago often required a lot of work arounds for broken compilers. Today some of that complexity could be cleaned up, but someone needs to do that work. Maybe you're interested in in. Second, some bits of boost were written as an experiment because C++ strongly encourages building new features as a library instead of extending the language. The boost lambda library comes to mind here: it proved that implementing lambdas would require a language extension because the library solution was too messy. There's a boost for_each library that's in a similar boat. One probably doesn't want to use those libraries. Third, some of the problems solved are inherently complex. Example: Xpressive is a compile time regex parser. That is a very complex problem to solve but it generates very efficient code; paid for in compile times. If you don't need that speed, use the regular regex and save yourself the compile time and having to understand complex compile errors. Finally, to say that there are "better" solutions out there for any of that, you need to understand what better means to a user, and that might include test coverage, license requirements, community engagement, compiler support, maturity, etc. Most libraries fall short on these things when compared to boost. 
If you had asked me at random to pick the worst library in Boost, I would have picked Format or DateTime. So FWIW, `boost::format` is awful, and not representative of most other Boost libraries (there are some other surely awful ones, too).
Show me the better alternative for Boost.MSM. Or Hana, or Spirit, or Xpressive, or Proto. Which arbitrary precision arithmetic library do you use? I bet its interface isn't as nice, or backend as flexible, as Boost.MultiPrecision's... But I guess all those are useless over-engineering despite the fact their functionality can't be replaced, right? And the fact that no other library or collection of libraries has had nearly the influence on the C++ standard itself isn't telling at all... As to being enormous, well, it's a collection of libraries; collections having lots of items is a bad thing now?
On one hand, it's a _collection of_ libraries – what else could you possibly expect? On the other hand, I'd say it _contains_ the masters of state machines, regular expressions, non-PEG parsers, and heterogeneous computation, at the very least...
And it uses Makefiles, no CMake support. It also uses shell files on all platforms for "configuration". Not sure how this is acceptable in this day and age. Missing CMake support or crappy/non-modern CMake support is often unfortunately what decides what library I'll be using - using libraries that don't meet that criteria will incur lots of complicated setup for building and maintenance to keep that setup working. It also seems to be a fair bit slower than libpcap - 3x to 10x in the benchmarks shown. That said, it's faster than other C++ libraries. But maybe that's because the setup for the benchmark had a really old OS combined with an ancient compiler.
Yeah, well, this was at a university, a research project. The developers knew their respective fields better than the toolsets, and obviously it was a supportive learning environment, but the outcome was driven by research, not engineering quality.
I'm fine with and appreciate that; I've been in similar situations, I just don't blame the toolset or code. Academics above most other people should appreciate the value of learning their tools properly, since actual application is the most practical method of communicating their ideas to other academics and non-academics alike. (And is an academic in a position to be afraid of _learning_ something, really?)
Yes, there is nothing in Noexcept preventing you from using a wrapper for your return values if this is desirable and if you can afford it, for example if instead of int you use std::optional&lt;int&gt;, attempting to consume the value in case of an error will result in an exception being thrown.
I guess my line of thought was: if compilers internally already rewrite member and non-member functions to a canonical form (and at least overload resolution is described in these terms by the Standard), why not use the same approach during name lookup? Is it the open-ended nature of the non-member overload set that makes this hard?
That's a weird way to put it. If tomorrow I make a great lib and in ten years it ends up in iso cpp, have I been writing beta codethe whole time?
Any tips on profiling compile times? Tried to do that some time ago (working on a code base which takes pretty long to compile) but didn't get much further than gcc's default statistics thingy, which could only confirm templates take long to compile.
I've had fun with [Templight](https://github.com/mikael-s-persson/templight) + [Templar](https://github.com/schulmar/Templar), but I haven't tried to use them in anger yet.
You said "It's a problem when ... no one has any idea how to ...". I took this to imply someone just didn't read the docs somewhere along the line.
&gt; I prefer to tweak a few variables in a Makefile And I prefer for my build system to be cross-platform and be able to integrate with many IDEs. &gt; [...] to trying to understand CMake's convoluted FindXXX logic [...] For newer `find_package` modules, it's usually a matter of having the library's folder in your PATH. Unfortunately there are still plenty of old modules, which haven't been updated yet. Might be worth noting CMake provides functionality to install packages and have `find_package` work for even libraries, which don't have a `find_package` module in CMake itself. Unfortunately not many libraries seem to be using this functionality - I wish I knew the reason.
&gt; Ah, you've given me an idea now! When I compile a $package, I put it into /some/dir/INSTALL/$package... For each package I can make my own cmake module with imported targets, put it into /some/dir/INSTALL/cmake/Find$package.cmake and use CMAKE_MODULE_PATH during configuration. It doesn't have to even necessarily be so complicated. CMake projects can install themselves and their find module after compiling using `install(...)` command into the standard CMake directories meant for that. But once again, not many libraries do this, and those which do, often do it incorrectly or problematically. Package managers could also probably install find modules into directories that CMake creates for that exact purpose. &gt; Cmake has functionality for exporting find configuration, but it's too badly documented :S I agree. Maybe you could open an issue [here](https://gitlab.kitware.com/cmake/cmake/issues) to track the problem?
I just added that to a project i'm working on (Log V2 to be exact), is there a good alternative to it?
Right, that may well be the case, but it doesn't imply anything about someone being afraid to learn new things :)
I've found other comments about it indicating it might have performance issues. I wasn't sure if they referred to V1 or V2 though.
Concerning the arbitrary precision arithmetic library, I found [MPFR C++](http://www.holoborodko.com/pavel/mpfr/) by Pavel Holoborodko quite useful and simple to use. If I remember correctly, it can be used together with Eigen. But you are right, boost is more flexible in general.
I know that exact pain
I'm going to say yes; we don't know it's a great lib until that first ten years of testing has been done.
Those look very useful!
 #define FORWARD(x) ::std::forward&lt;decltype(x)&gt;(x)
It is a joke, Herb Sutter has his AAA, so this is mine. :) 
Yes, good Point! There's also one link missing for the paper with those default values... I'll fix this soon
that's honestly not a very relevant metric then. If everything is beta, nothing is.
I'm not a fan of macros, either. But they do make life bearable on occasion and that's one macro I have actually used in real code. The issue with implicitly treating a named rvalue reference as an rvalue expression are accidental moves. This is not something a compiler can help avoid because the source of a move is still "valid" and it is not necessarily an error to access a moved-from object. The compiler does not really understand what you can and cannot do with such objects and it does not read the mind of a programmer. So, yeah, it makes a lot of sense to be conservative about what is treated as an rvalue expression. Speaking of 2017, maybe the Rust language is more appealing to you. Among other nice properties it has much simpler move semantics. It moves by default without the danger of accessing invalid memory and it does not force you to add some zero state to your type's invariants only to make your type movable. Everything is noexcept-movable in Rust and it's guaranteed to be as efficient as a shallow memcpy. In situations where you perform perfect forwarding in C++ you'd simply move by value in Rust. This might involve an extra move but the cost of a move is super low as opposed to C++ where you deal with lots of legacy types that possibly throw on a move request. However, the Rust guys are working on a "placement syntax" to elide moves and create objects directly in containers similar to what the C++ standard lib offers via `emplace` functions.
Any idea on why they were removed?
I have similar issues with versioning. I'm doing the semantic versioning with macros from a file linked in. It it pulls the branch from git information via cmake and a shell call to git. This works but causes the application to be built (linked) every time. Our project has many exe's and so it increases the build time considerably. To the point we had to disable the auto approach and manually tag the actual release (rebuild with versioning after testing). It would be nice if I could avoid cmake "touching" the version file if the version has not changed. I've even though of compiling artifacts with a version location and tagging them after the facts by modifying the exe to write new version string in the executable image. Need something fool proof but fools keep getting better every day.
I don't understand what you propose. In your opinion: what should the exact rules be which make a named rvalue reference an rvalue expression?
The proposed defaults where too tightly coupled with the mathematical meaning of the operators. However, those operators are often overloaded with a non-mathematical semantic (for instance: string concatenation). In that case those values would have produced hard-to-understand error messages. Since default values can easily be provided using binary fold expression, the feature value is not diminished by the decision and the design principle "better explicit than implicit" is met.
Niall you never "ran" Boost at all, did you? From what I can see you just "ran" (administrated) the Boost GSOC program. So you're moving on to make room for a new GSOC administrator? Sounds ceremonious. From an outsider's point of view, it seems like you like to take credit for Boost ("Prinicipal Architect in Boost") without really contributing anything significant to Boost.
The easiest, and least sophisticated (so it works in any environment) thing to do, is first have your automated build system report the compile times of each cpp file. This will tell you who the worst offenders are, and also allow you to inspect it daily, looking for spikes. Once you know what the worst offenders are, you can write a script that looks for slow functions. Basically, take the cpp file and chop it up, so if it has 10 functions in it, you end up with 11 smaller cpp files such that the first cpp has only the #includes, the second has the #includes plus the first function. The third has the #includes, plus the first function, plus the second function, and so on. You time the compilation of each small cpp and output the results to a csv and then plot it. By subtracting the time of cpp N-1 from N, you can see how long each individual function takes to compile. When I have done this on big projects, I have found that the processing time of the #include section is usually relatively small, and there are big spikes in a handful of functions. Inspecting those functions will usually reveal some problem that's basically a mistake like any other performance bug. Sometimes it really is that your doing something expensive there, like perhaps using the boost.spirit parser generator, which really is slow to compile. But now you know that that is a problem, so you can fix it by moving that one function to its own cpp file so everyone only ever has to compile it once. Doing this can make a big difference because, like any other performance problem, there's usually a small number of big offenders. 
That's the recent line from the steering committee as to what it does. But that (very conservative) line was synthesised itself only after I prodded for a mission statement. Before that there was none, it had never been necessary with people like Dave Abrahams around. What the Steering Committee's role is is not fixed in stone. And you may find it taking on a much more expansive role in future years than it has in years until now. It has the power and money, if it chooses to use them. But you're on it, so you'll see for yourself soon, though probably next year not this year.
Sure, like I said I know you didn't mean that.
Looks nice. What about performance, specially around the ObservableProperty?
Yeah, it can be better seen from outside. Would be nice to have more concrete suggestion, which I can include in furure releases :)
Always great to see new libraries that do something cool! Some quick English feedback if you don't mind (I hate to bring this stuff up, but particularly if it's a mistake in a class name it's best to fix it early!): - `Ussage` in Readme should be `Usage` - `DefferedForwardContainer` should be `DeferredForwardContainer` (double `r` and single `f`) Anyways, this looks awesome :) 
WG21 is not "stuffed full of Boost folk," nor do we block vote anything. There are lots of differing opinions at the meetings even among people who have participated in Boost.
You can choose the port you want to listen on and then accept reverse connections from the client.
I was referring to V1... Which probably accounts for its rapid replacement.
A quick skim of the literature I am not sure exactly whether it is UB or if there is just some specific wording about compilers being allowed to optimize it out. A couple of quick references: https://stackoverflow.com/questions/3592557/optimizing-away-a-while1-in-c0x https://blog.regehr.org/archives/140 The draft seems to say that a loop that doesn't do IO, access volatile or synchronizing variables, may be assumed to terminate. This isn't quite as strong a statement as a non-terminating loop that does none of those things being UB, but it is close (and it is stronger than your statment, in the sense that the compiler does not need to prove that the loop terminates).
It is not hard to implement. It is hard to do without breaking old code. Or if you do it in a way that doesn't break old code, it becomes more complicated to understand.
Well, in nonblocking_atomic mode (fastest for something like int) read overhead = std::atomic load() overhead. Write overhead = std::atomic store() + 1-2 spinlocks (for event queue processing) + call's of std::function (if any). For blocking mode, overhead of using upgrade_mutex :) Plus approx. 60 bytes of memory footprint. There is test/BenchmarkOwnedProperty.h - it test traverse access speed. Most of the overhead will come from size (60 bytes of property vs 4 bytes of std::atomic&lt;int&gt;). If traversed objects will have identical sizes, they have almost the same speed. I didn't test event fire performance (it just 1-2 spinlocks + N virtual calls), but I'm sure it will &gt;90% of time process subscribers body. All in all, it does not allocated, or do anything special on the fly... It is designed to work in multithreaded environment, as you see, thence you'll have some overhead. But it is relatively easy to make single-threaded version (basically, replace all underlying mutexes with threading::dummy_mutex). There should be virtually no overhead, besides call of subscribers(virtual call of std::function()). I maybe make it latter.
Thanks, I'll fix this now.
Well, you don't have to include just that one header. There's several smaller headers you can include. There's also a such thing as going full-on enterprise too early. If you _only_ need the distance between two points, the most simple and best thing to do is roll your own implementation. Now, if you suddenly needed an rtree implementation then it's a different story. Boost.Geometry is fantastic library but it is massive and including it all can be a mistake. Like all external libs, you have to evaluate whether or not including an external dependency is a good idea or not. Edit: Also, Spirit is one of the best things in Boost.
&gt; given that it allocates the control block contiguously to the actual memory it is responsible for maintaining. I don't think the standard actually requires this, rather strongly suggests that implementers do this. You are right that without `std::make_shared` it is almost impossible to perform that optimization. Also it's cleaner since there's no `new`.
Yea, xml and performance sound oxymoron :) Gotta deal with it though.
I wasn't attending WG21 meetings in the early 2000s, but I don't think you were either, correct me if I'm wrong (I don't recall ever seeing you at a meeting, at least). That Boost was vocal in the early 2000s is not surprising given that it was birthed by committee members and the amount of people attending meetings back then was also much smaller. Anyway, I don't mean to be intentionally contradicting you in this thread a bunch, I just want to stress that the community is much less dramatic than some people seem to believe. I say this as someone who has controversial papers in flight and who has even voiced my own frustration. At the same time, while the presence of people who contribute to or evangelize Boost is in some sense growing in WG21, so is the presence of developers there as a whole. Even of the "Boost folk", we mostly either represent ourselves or organizations we work for rather than Boost itself, and we also still frequently disagree on fine (and sometimes not-so-fine) details. Regarding standardizing existing practice for anything non-trivial, on this point I am in complete agreement. One of the things that bothered me about, for instance, std::variant, was that it strayed from design choices of existing implementations without getting a comparable amount of usage in the wild first. IMO, it fell victim to design-by-committee with all of the negative connotations that are implied. What we have is still reasonable, but I think the process did let us down at least a little bit (std::variant is still good and important, overall). That said, clearly I'm in the minority on this particular issue, and at least a couple of people who've been active in the Boost community even pushed for choices I think were relatively quick and in error. What I'm trying to say is, while there are seemingly more Boost people going to meetings, it doesn't mean that there is some very concrete set of ideals that we all vote for. The only thing that I see common among the Boost folks who attend is that we seem to be more likely to try to fully understand all of the minutae for given language and library changes upfront, before they get far along in the process, even when problems are not always immediately obvious from a given paper. This ranges from high-level concerns to low-level concerns. We still sometimes come to different overall conclusions, but that's healthy. Slightly on a tangent -- part of why design-by-committee sometimes happens is because of the contradicting views that people have in the C++ community regarding whether the language is moving too fast or too slow (and precisely which things are moving too fast and which are moving too slow). While I personally feel that non-trivial library additions should come from existing practice, that does add a latency that a lot of people do not tolerate. Some people want new features in the standard itself (not Boost) sooner than later, and that means getting stuff in without much user experience. You end up having to weigh the importance of having a feature in the standard compared to the risk of making a particular class of mistake, and also compare it to how difficult it might be to actually fix that mistake (we still have vector&lt;bool&gt; after all). It's a tricky situation to be in, but overall I do think that the committee does an amazing job with its difficult constraints.
You may want to check [`libstudxml`](http://codesynthesis.com/projects/libstudxml/), it has some ideas for basic validatio support that doesn't become a pain in the ass.
Unrelated fun fact: noexpect is part of function overload resolution in C++17.
My experience is similar to yours. A lot of boost libraries feels and looks like they are not aging gracefully in comparison to some newer libraries. Especially when you add in C++14 features (and to say nothing of C++17). Boost is beginning to look and feel more like a legacy library you use to give you newer STL features in older compilers, which was not in my understanding its original intent. This is not a bad thing, but I do find that on occasion it is useful to take a boost header-only library for example and strip out all the backwards/old compiler compensation stuff and end up with pretty nice code that is actually readable. In effect boost's intent of supporting as much as possible also makes it slightly more difficult to read. That way you can often also drop a lot of internal boost dependencies as well.
what structured text format would be better then?
json, yaml are simpler IMHO, but not exactly like XML.
Protobuf has a [text-based format](https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.text_format) if human-readability is needed. Definitely isn't a drop-in replacement for xml in all cases, but it's a lot nicer to work with than either json or xml. (imo)
So how worthwhile is it to attend CppCon as a non-expert level programmer, or as someone not involved in the library or standards processes? Wondering about trying to get my company to spring for the ticket and hotel, but is there actually value in them sending someone.
My regular batch of "code fantasy" just shipped.
"cmd" implies you're using Windows, if so, just use the [VsVim](http://vsixgallery.com/extension/VsVim.Microsoft.e214908b-0458-4ae2-a583-4310f29687c3/) extension for Visual Studio (there are similar plugins for most other editors and IDEs as well) and you're golden. But if you're dead set on using vim directly (which is doable), learn how to customize your .vimrc for one. I use CMake to generate msbuilds on Windows and Makefiles on Linux, so that might be worthwhile to look at, Google is your friend. vim plugins, let's see... vundle, youcompleteme, vim-surround, nerdtree, vim-fugitive. 
No; it becomes part of the function type, but it doesn't affect overload resolution, only conversions between function pointers.
&gt; I wasn't attending WG21 meetings in the early 2000s, but I don't think you were either, correct me if I'm wrong (I don't recall ever seeing you at a meeting, at least). That Boost was vocal in the early 2000s is not surprising given that it was birthed by committee members and the amount of people attending meetings back then was also much smaller. I have never attended a WG21 meeting, can't justify the very significant cost as someone self employed. I was SC22 mirror convenor for Ireland a while back, and I have attended WG14 meetings where I was far more active historically. So I do know personally people who were on WG21 in the 1990s to mid 2000s, and I merely repeat what they told me. I have reason to believe them, Bjarne hinted at similar recollections and feelings of back then during a lunch discussion regarding the long term future of Boost last CppCon. You also must remember I knew Dave for a long time too, 2001 or so onwards, we collaborated on a few bits and pieces, and my experience of his experience put me off having anything to do with Boost or WG21 right up until my new role at BlackBerry required me getting into Boost 2012 or so. Despite that role having gone, still kicking those Boost tyres, but I'm intending to move onto other endeavours soon, five years to be at a thing is long enough.
Using vim can certainly be a practical development environment. For small projects I use vim on the command line almost exclusively (except on windows where I've found the vim in a command line performs very sluggishly with syntax highlighting on). If you want to harness the power of vim but want to stay in another IDE, there are vim plugins for many IDEs. The quality of these varies, but I've found the vim plugins for Visual Studio, and any of the JetBrains IDEs ([CLion](https://www.jetbrains.com/clion/) being the most relevant for C++ development) to have quite good quality plugins. Makefiles aren't required; there are plenty of alternatives, the most widespread of which is probably CMake, which can generate makefiles, among many other options (like visual studio project files, XCode project files, etc). In terms of plugins, some of my favorite include [pathogen](https://github.com/tpope/vim-pathogen) for making installing other plugins much easier, [ctrlp](https://github.com/kien/ctrlp.vim) for easy navigation between open files, [clang_complete](https://github.com/Rip-Rip/clang_complete) for C++ code completion. As a colorscheme, I'm quite partial to [zenburn](https://github.com/jnurmine/Zenburn) 
Link borked?
As side note: does anyone know if this call was recorded? It has not been uploaded yet to the ACCU channel at YouTube.
I dunno. I find it odd that the paper doesn't refer to p0464 or really put a good faith effort to respond to its arguments. At times ("being too literally minded" or "only language lawyers are confused by that"), it's just condescending. Whether or not you agree with Tony and Botond, theirs is a really well-written and argued paper and I think it deserves a better response. 
I agree that both sides of the arguments deserve to be taken seriously. Though it will be really, REALLY, sad if Concepts get delayed again due to disagreements on such minor issue. Had that happen I'd suggest to drop all short forms and incorporate Concepts into C++20, and talk about that later. This means people just postpone disagreements, less broken codes, the door for future shortform improvement is still open, and finally we can have Concepts already.
This is simultaneously - Freaking amazing, because now the use cases for messy macro programming have dropped considerably. - Concerning, because there will be THAT idiot somewhere that completely abuses this and makes reading his code the equivalent of slicing your tongue.
I don't understand how "&amp;&amp;" is a big problem. template&lt;class T&gt; concept bool ObjectType = std::is_object_v&lt;T&gt;; void f(ObjectType&amp;&amp;); // the parameter is an rvalue reference template&lt;class T&gt; concept bool AnyType = true; void f(AnyType&amp;&amp;); // the parameter is a forwarding reference
Except that the former only binds to an rvalue, so effectively it behaves like an rvalue reference.
Check P0696R0. With ordinary type &amp;&amp; means strictly rvalue reference, while with concept it means universal reference, which is very confusing and error-prone to the least. Your example strengthens the problem that I cannot tell which is which from the function declaration. This will become an even bigger problem in large codebase. Had &amp;&amp; been defined in a saner way, this wouldn't be a problem.
What I changed on wee-slack to use Vim with completion, etc? Sorry video is the sole demonstration I have, it includes a link to the pull request, etc. For Vim, etc, [these are my dotfiles](https://github.com/oblitum/dotfiles), and I use my [YCM fork](http://nosubstance.me/articles/2015-01-29-better-completion-for-cpp/) for completion.
The helper template is probably not worth using (though the article overall makes a good point). I think this: struct fclose_deleter { void operator()(FILE* f) const { fclose(f); } }; using file_ptr = std::unique_ptr&lt;FILE, fclose_deleter&gt;; is clearer and more readable than: template&lt;typename T, T* func&gt; struct function_caller { template&lt;typename... Us&gt; auto operator()(Us&amp;&amp;... us) const -&gt; decltype(func(std::forward&lt;Us...&gt;(us...))) { return func(std::forward&lt;Us...&gt;(us...)); } }; // ... somewhere else using file_ptr = std::unique_ptr&lt;FILE, function_caller&lt;int(FILE*), &amp;fclose&gt;&gt;; You save a little bit of boiler plate at the expense of clarity. Also, the signature of `operator()` is overly complex. It can return `void` since the `unique_ptr` doesn't do anything with the return value anyway, and it doesn't need to be variadic, since it will only ever be called with a single (presumably pointer) value.
Hell fucking yes. 
And I hope to all that is holy I never have to work with him. 
`std::default_delete&lt;std::FILE&gt;` would be an illegal specialization because no non-stdlib, non-primitive types are involved.
Wouldn't shared_ptr have that issue as well?
I don't use web from mobile so this eluded me. I'll do my best to fix it.
And there's no deduction guide for `shared_ptr` either. The pointer-taking constructors of `shared_ptr` are templated on the pointer type and can't be used for deduction.
Me to. Using some plugins, like: Vundle airline YouCompleteMe semantic-highlight ...and more... (And custom settings, of course.) YCM does a really nice job. For my own projects I use cmake. With ninja. And CMAKE_EXPORT_COMPILE_COMMANDS, that will work nicely with .ycm_extra_conf.py There are a lot of plugins out there. Sometimes I try some. Other times I remove a bunch because I didn't use them. Everybody has there own preferences and workflow. http://vimawesome.com/ http://www.vim.org/scripts/script_search_results.php http://vimcolors.com/ https://www.reddit.com/r/vim/ As you are switching, you might already know what you like and would like to have and what you are missing. 
I learnt VB as my first programming language. It was fun learning the concepts. Then I was all pumped up to tackle C++ , attempted it 3 times before, gave up due to lack of uniformity, tools and cryptic notations. 4th attempt now, and I am beginning to appreciate the language. 
I might be missing something here but wouldn't a capture-less lambda also work here? 
The C++ Programming Language by Bjarne Stroustrup (the creator of C++). The first five chapters provide an introductory tour, enough to jump in and start using C++ (along with motivations for decisions). The rest of the book is an in-depth look into how it all really works (somewhat reference). Best of both worlds. The latest edition is based on C++11 I believe which is where some of the major changes were introduced. C++14 and C++17 were much less minor to the change in nature of C++ so you're not missing much.
If you're going to combine enum values, consider powers of two and ORing them together. Check with AND. Using addition will lead to problems later.
You have really bad luck naming things. https://newsroom.intel.com/chip-shots/intel-unveils-project-alloy/
I think you should write it up as a formal proposal, with all changes to the standard written out. You might find out that it's not as easy to spec as you think. Or perhaps that it is indeed something that would spec nice and be easy to implement and maybe even likely to be considered. Can't know until you do the tedious part.
recently I've reviewed [Review: Modern C++ Programming Cookbook](http://www.bfilipek.com/2017/06/modern-c-programming-cookbook-review.html) - and I think it's a really great book. It's a cookbook, so you can pick what you need.
But parallelizing container operations in C++ is generally just as easy too noawadays...
I thought I had made it clear that I know both of those things. But if you look at several of the libraries that are not C++11 or 14 yet, it looks like they are there to help software that cannot move to a newer standard gain some of the benefits of these newer standards for example boost thread, boost's versions of any, optional and so on. What I am not saying is that Boost is not useful, but maybe there should be a demarcation of versions and divide into newer libraries and backwards compatibility libraries. Maybe this can also be used to the benefit of removing some of the backwards compatibility requirements that to me seems to make writing new code for boost rather daunting.
VSCode and anything using Electron has easily measurable impact on energy use if you're mobile. Notepad++, TextMate and Sublime pretty much consume at least an order of magnitude less energy per keystroke than VSCode or Atom do. If you scroll or do more complex things, the wins are even bigger. It's ridiculous how bad using a browser-based IDE is in terms of energy waste. Sure, eventually it might get better, but I fail to see the point of it. There's so many better ways to get portability.
LPT: In the future, if you think of giving a public project a name, google the name in the context of the project. E.g. if it'll be used for software development, google *projectname software development*.
I used to use Zimbra. Its cli tools took forever to start. WTF were they thinking :(
I saw that you typed a sad face emoticon in your comment, so I just wanted to let you know that I hope you have a wonderful day!
Well, your favourite GUI lib should have something like onUIThread method... You may make small wrapper around reactive::bind for it, like (in semi-pseudocode): bindUI(auto&amp;&amp; widget, auto&amp;&amp; closure, auto&amp;&amp;... properties){ reactive::bind(widget, [closure](auto&amp;&amp; widget, auto&amp;&amp;... properties){ MyFavoriteGUI::onUIThread([&amp;](){closure(widget, properties...);}) }, properties...); } bindUI(myWidget, [](auto&amp;&amp; myWidget, int x, int y){ myWidget-&gt;setWidth(x+y); }, x, y); Or without wrapper: bind(myWidget, [](auto&amp;&amp; myWidget, int x, int y){ MyFavoriteGUI::onUIThread([&amp;](){ myWidget-&gt;setWidth(x+y); }); }, x, y); If I understand you correctly.
If you want lightweight, [dear imgui](https://github.com/ocornut/imgui) is the answer. Essentially perfect when high-performance game-like input latencies are a must, and pretty much a no-brainer for a fast editor. If you want an entire framework, then wxWidgets and Qt are decent, with the latter having more investment into it. Both can be used to write low-level editor code easily and with very minimal overhead imposed by the framework itself. None of these three have overheads anywhere near of Electron's. I mean, you can literally do the same stuff orders of magnitude faster and using orders of magnitude less energy. Eletron is so bad at doing complex stuff that you can get better performance by just streaming gl display list data from an imgui- or Qt-based server to a small webgl runtime running on top of Electron. BTDT both.
/u/joboccara, How are you sure this will never break? the maths seems too shallow. it works with 2 enums but the variadic version will break. i.e. with 3 enums : return enumValue(e1) + enumSize&lt;Enum1&gt;() * enumValue(e2) + enumSize&lt;Enum2&gt;() * enumValue(e3); Lets consider it's 3 enums of 5 values (so 0 to 4 and 5 being "End_"). We will have `(0, x, 0)` that is equals to `(0, 0, x)` (both are equals to `5 times x`). The solution would need to be: return enumValue(e1) + enumSize&lt;Enum1&gt;() * enumValue(e2) + enumSize&lt;Enum1&gt;() * enumSize&lt;Enum2&gt;() * enumValue(e3); Right? or did I missed something?
A great thing about the switch statement on an enum class is that you can skip the `default:`section and it forces you to handle all of the values. Very useful when you add a new value and want to make sure that you updated all the switches. That's why I don't like this pattern, because you loose that safety by having to switch on `size_t`, and to add an `End_` value to the enum class itself. (although in the latter case it's possible to extract the number of elements in the enum with some template and macro tricks).
https://wandbox.org/permlink/jtNEUIK2KJRFULbb It kind of works, but has similar drawbacks. You get the same size as `FILE*`, but it's not default constructible, so you have to pass `my_deleter` to the ptr's constructor. Also, since each lambda has a unique type, such ptr is unusable with any other lambda (unless you employ some trickery, but I can't recall it exactly and if it was standard-compliant or not). Finally, this might cause problems if the same same lambda is used between different TUS, though I'm not certain about this and would suggest further research before taking my words at face value.
With metadebuggers, duh.
I'm the opposite, keeping it a single proposal keeps momentum up for getting the short forms in. The short forms is for me by far the biggest appeal of Concepts.
Yes, that web page is not for beginners, but as a resource specifically for OP's situation, I think it is ideal.
Let me clarify what I am working on. The aim of the VC++ team is to clearly document the IFC binary format that VC++ uses for compiled module interfaces, and openly release it to the greater C++ community. This is an opportunity for the C++ community to build semantics-aware tools ecosystem around C++ and modules in particular. If the community feels it needs a TS form, great. But the primary objective is to help the C++ community seize the opportunity to grow openly semantics-aware tooling for C++.
Meta unit tests written using second order metaclasses. `$$class`
If it helps, here's an example that does compile (although sometimes the compile time exceeds the maximum allowed): https://godbolt.org/g/Vg7zwh
right. I've gotten that far as well. What I am really interested in though is generating functions based on the protoclass's content. So all the various more interesting features don't seem to compile well.
yep, it works with 2 enums since e2 is at least "e1::end_" (if not 0)
The terse syntax isn't necessarily *that* terse once you repeat concepts in the consistent deduction world. From the paper's examples, `copy()` is a little shorter: Output_iterator copy(Input_iterator, Input_iterator, Output_iterator); template &lt;Input_iterator In, Output_iterator Out&gt; Out copy(In, In, Out); `sort()` (the one that takes iterators) is a bit longer, even longer with the relation (with lots of breathing room to use a name longer than `R`): void sort(Random_access_iterator, Random_access_iterator); template &lt;Random_access_iterator It&gt; void sort(It, It); void sort(Random_access_iterator, Random_access_iterator, Relation&lt;Value_type&lt;Random_access_iterator&gt;&gt;); template &lt;Random_access_iterator It, Relation&lt;Value_type&lt;It&gt;&gt; R&gt; void sort(It, It, R); `operator+` on `Number`s is little shorter: Number operator+(Number a, Number b); template &lt;Number N&gt; N operator+(N a, N b); `find()` is a little longer: Input_iterator find(Input_iterator, Input_iterator, Equality_comparable&lt;Value_type&lt;Input_iterator&gt;&gt; ); template &lt;Input_iterator It, Equality_comparable&lt;Value_type&lt;It&gt;&gt; V&gt; It find(It, It, V ); `next()` is one of the few I've found that is appreciably terser: Value next(Value); template &lt;Value V&gt; next(V);
pretty sure I'd be able to remove all the macros of my codebase with this. &gt; property&lt;int&gt; value { }; gives me a hard-on &gt; signal&lt;int&gt; mySignalThatReturnsInt(); &gt; slot&lt;Priority&gt; mySlotThatReturnsPriority(); I don't think that is enough; full functions signatures are needed. e.g. signals: int mySig(string foo, int bar); slots: int mySlot(string foo, int bar); is possible with Qt. 
I really don't like this pattern. The non-flattened one seems a lot more readable. 
But wouldn't you rather have macro programming? It's more general.
You learn something new every day. Thanks for correcting me.
But what do you do about Nintendo Switch statements?
By the time we have metaclasses, we should have modules. Modules are like mini-pchs, and it means you won't be recompiling the same header file 100,000 times in a project. 
They went to Discord/Slack
Extremely interesting feature! Unfortunately, we won't see this till about 2022 or so. There is so much committee needs to approve before metaclasses can be acceptable.
The C++17 version is nicer template&lt;auto f&gt; struct invoke { template&lt;class...Args&gt; auto operator()(Args&amp;&amp;...args) noexcept(noexcept(f(std::forward&lt;Args&gt;(args)...))) -&gt; decltype(f(std::forward&lt;Args&gt;(args)...)) { return f(std::forward&lt;Args&gt;(args)...); } }; Now we can just: using file_ptr = std::unique_ptr&lt;FILE, invoke&lt;&amp;fclose&gt;&gt;; or if you want `invoker` to be simpler: template&lt;auto f&gt; struct closer { template&lt;class T&gt; void operator()(T* t) noexcept(noexcept(f(t))) { return f(t); } }; giving us using file_ptr = std::unique_ptr&lt;FILE, closer&lt;&amp;fclose&gt;&gt;; which is clear and simple. 
Wow. This has the potential to be the most transformative change to C++ since the addition of templates. I can only imagine that this is what it was like for C++ users in the early 90s to read Stepanov's original STL paper. It's very exciting, but scary in a way -- the potential is so huge that it's hard to grasp what the full repercussions might be. Committee members: please, get this into a TS ASAP!
Ah you're right, sorry I misread your post. I think basically we're in agreement, you are correct and I'm not :-).
A lambda capturing references in an inlined context has no need to exist; there is no fundamental cost there. There is a possible optimization failure, but the optimization isn't hard here, and we should have some faith in our compilers. I don't see the extra move with C++17 prvalue guaranteed elision. Can you illustrate? 
tl;dr. Just read the last paragraph, which is reproduced below: "However, I wouldn’t suggest actually using that like this in production code. Most often, a better solution would be to design the algorithm so that it works lazily. range v3, for example, can work on infinite ranges which are lazily evaluated as needed."
I'm an experienced programmer reading C++ Primer and it's a pretty good overview and explanation of its features.
All caps, `conio.h`, `iostream.h`, Turbo C++. Doesn't listen to feedback: * https://www.reddit.com/r/cpp/comments/6gy87h/c_programme/ * https://www.reddit.com/r/programming/comments/6fkmjj/c_basic_programme/ *quality*
Stop spamming this crap.
&gt; noexcept(noexcept(f(t))) Does this help? C functions like `fclose` (which are primary target of this code) are not marked noexcept but in fact do not throw. 
That's the method I usually go with. Convert them to a bitmapping or simply concat them into a string in languages that allow switches on strings. It's really only worth it if both enums have lots of options though. 
Why don't we skip and go to the end step right way. It's not that it hasn't been done before: https://en.wikipedia.org/wiki/Lisp_(programming_language) I am not proposing to replace C++ with LISP, but rather create a language that is source-code compatible with C++ but all the code in it is compiled and transformed by meta code. 
But isn't it opt-in? I.e. you have to explicitly use metaclasses provided by someone when defining your own structures, for this too work. I.e. it won't magically change the behaviour of your already written code. And if so, I don't see how that be much different from using any external lib. There is no guarantee that the 3rdparthy author didn't do `#define true false` somewhere in any case ;P
I wouldn't say that C++ Modules ([N4610](https://wg21.link/N4610)) are like mini-pch files. They address the main goal of precompiled headers but they provide much more than build throughput improvements. Precompiled headers are a build-time technology and don't have any real integration with the language. C++ Modules enhance the language to allow definition of an interface. Enabling the component developer to define an interface means that the consumer doesn't need to deal with any random internal state that never should have been exposed in the interface. Maybe you're confusing C++ Modules, the current TS, with [Clang Modules, the cross-language build-system technology built as a huge improvement over PCH files](http://clang.llvm.org/docs/PCHInternals.html)? *Edit: Changed first paragraph based on the discussion following.*
Oh fuck no. If anyone ever tries to force me to use something as fundamentally *wrong* as Guice in C++, I'm coming after *you* for planting the idea. That said, if it supports code injection, it would facilitate my zero copy immutable type wrappers... I'm just not sure how it could, with this syntax. My approach allowed defined types with template syntax, to allow explicit member function specialization... I don't think this does the same.
Not to mention that default template &amp; function arguments means that we can combine the two `sort` overloads into one with the non-"terse" syntax.
That's actually kinda useful for writing tests sometimes... But yes.
Sure, attributes are a better choice. I also think querying for the attributes will be available in this proposed metaclass system too (attributes should participate in the reflection just as much as any other part of the function signature), so it'll probably be possible to just use them as you suggested. Coupled with user-defined attributes this feature may become very powerful and replace most of the remaining ugliness completely. Like: [[qt::property(get_value, set_value, ...)]] int value; or similar
Thanks. For some reason Reddit glitched out for me refusing to post my comment and when I refreshed the page I saw no comments at all, Looks like it posted them after some delay.
Which was what it was used for... until one very junior guy decided that the entire idea of C++ having private fields were impractical to his code because he couldn't just access all fields, discovered the define in our unit test build and turned it on in the regular build. I had left the company at that point, but remained friends with some guys there and they didn't do reviews so it was not until much later they found out that there were suddenly a lot of code that had APIs in the form of direct variable access with no real structure left behind. Abusers will abuse.....
If C++ was a stock I would be buying a lot of it right now. If this works, it will be a game changer.
I have no idea (a) how difficult this will be to implement in a compiler, (b) how long compilation will take now, or (c) how the hell my IDE is going to understand all of this. But it sure looks cool.
&gt; you can get better performance with SOA layout, which is possible using only C More like, "SoA sucks in both C and C++, but if you are not going to use OO-features why bother with C++" ? Not that I agree with Mike Acton, even if you don't use OO there are many reasons to prefer C++ over C. Anyhow, if all you do all day long is write and maintain SoA-like code, C++ abstraction capabilities don't help you. 
One of the problems mentioned with the original code was that the Red-Large case is far away from the Blue-Large case. It still is in the "improved" code. The extra complexity doesn't seem worth it to me. Maybe it would work out better in a real example, or maybe the code is flawed either way...
First, your `LAZY` macro is missing a `noexcept(noexcept(blah))` clause. May as well be complete. This is a more general purpose macro: #define RETURNS(...) \ noexcept(noexecpt(__VA_ARGS__)) \ -&gt; decltype(__VA_ARGS__) \ { return __VA_ARGS__; } for which there is a proposal to replace it with #define RETURNS(...) =&gt; (__VA_ARGS__) something that is unlikely to happen with your `LAZY`. With this, things are a BIT more verbose. auto result = opt.value_or([&amp;]()RETURNS(foo())); but the fact you have a macro is less visible. For transparency, we just keep your `lazy_eval`: auto result = opt.value_or(lazy_eval([&amp;]()RETURNS(foo()))); and the deep mojo is no longer hidden behind a macro, except the annoying boilerplate of `RETURNS` (which we hope the standard replaces with `=&gt;`). 
Well I thought it was a cool technique to share. ː) And it has real-world applications, like my `DEBUG_ASSERT` macro.
I didn't see the variadic implementation before it was taken down, but it would be easy enough to write. You just accumulate the multiplications as you go: namespace details { constexpr size_t combine_enums(size_t cur) { return cur; } template &lt;typename Enum, typename... Enums&gt; constexpr size_t combine_enums(size_t cur, Enum e, Enums... enums) { return combine_enums(cur * enumSize&lt;Enum&gt;() + enumValue(e), enums...); } } template &lt;typename... Enums&gt; constexpr size_t combine_enums(Enums... enums) { return details::combine_enums(0, enums...); } 
I was under the impression `std::sort` was one of the usp for c++ even compared with C. Rust seems to beat in that!
Again the library does not assume any particular semantics for the return value. If in a function that returns int you do return throw_(foo()); the foo will be moved to thread-local storage and you'll get -1 from the function -- but try_ doesn't care about the return value, it uses has_current_error() to check for errors. That said, you wouldn't call try_ to check for errors -- only to _handle_ errors (by analogy with using try to catch exceptions). The section on programming techniques might be of particular interest: https://zajo.github.io/boost-noexcept/#programming_techniques
I think 'isolation' is a better (general) term -- isolation from macros, of course, but also environment compilation switches, e.g. someone changing calling convention etc. Your point about "c++ to c++ language isolation" is a a very good one.
What is the cause for that? I'm curious
I find VIM to be incredibly useful because many times i am in a situation where i have to update, edit code on a remote machine and pulling anything heavier them VI across a X session can be slow and painful to use and if you get familiar enough with vi then there are certain operations that you can do using a combination of commands that are hard to duplicate on other editors. Also I find it ideal to use when you know what your doing, ie: You know the code base really well or know exactly what change your going to make. On the other hand when I am trying to understand the lay of the land and freely navigate around then I find IDEs more intuitive and easier to use. Now i do hear that there are some plugins and add ons to enable all kinds of capabilities into VIM but I have not explored those. 
I so want [this](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0644r0.html) to happen, either with a unary operator `&gt;&gt;` or `&gt;`.
Misleading Title is misleading. Code for generating the numbers to sort looks like this: let mut v = (0u64..100_000_000) .map(|x| x.wrapping_mul(x).wrapping_mul(x).wrapping_mul(18913515181)) .collect::&lt;Vec&lt;_&gt;&gt;(); Which, in C++ code, (I think) translates to this: std::vector&lt;uint64_t&gt; values(100'000'001); for(size_t i = 0; i &lt; values.size(); i++) { uint64_t val = i; values[i] = val * val * val * 18'913'515'181ull; } Probably not sorted to start with (because of integer overflow after 2^(10)-ish), but far, *far* from random. Secondly, as mentioned by /u/stjepang both here and in the linked thread, there seems to be a significant algorithm difference between what C++ uses in `std::sort`, and what Rust uses in `Vec::sort`. So the headline shouldn't be "Rust sorts numbers faster than C++", the headline should be "pattern-defeating quicksort is faster than introsort for some subsets of arbitrary input". Which actually makes sense: the input *isn't* random, and I suspect that if it were truly [pseudo-]random, it might degrade the performance of the algorithm slightly, since it seems to be tuned to handle runs/patterns in the data (hence its name), and may perform less admirably on more random data. If we're going to make performance comparisons between C++ and Rust, we need to compare Apples to Apples. If anyone is willing to implement the algorithm described in Rust into C++, and do a more direct comparison, then we can talk performance. And don't call it a comparison on "random integers" if the input integers aren't random. ;) #EDIT: Looking at the [github where the algorithm was implemented](https://github.com/orlp/pdqsort), it looks like there actually is a C++ implementation of this algorithm that does indeed yield performance improvements, even on shuffled data, on the same order of magnitude as what Rust was getting for its sorting algorithm. So again, this really isn't a Rust vs C++ comparison, it's a PDQSORT vs. INTROSORT comparison. Still impressive, but doesn't really make sense to make this a Rust vs C++ thing *yet again*.
&gt; Rust seems to beat in that! More like: "Orson Peters' new pattern-defeating quicksort is faster than introsort for the inputs we chose!"
Paging /u/AndrewPardoe
This is great. I am so glad to see support from the C++ establishment for this. It will keep the language alive and relevant for much longer.
The comparison is not between rust vs cpp. But default standard library sort in both languages. When choosing a programming language for a task, considering what we get out of the box is important. I have always assumed c++ will have a competitive advantage as it is old and more effort is poured in for optimization compared to new languages. But looks like not always true. So I thought it will be useful for other programmers. &gt;&gt; So the headline shouldn't be "Rust sorts numbers faster than C++" The headline doesn't say that, it says the 'default' sort in rust is faster than `std::sort`, which all c++ devs know is the default sort in c++.
A well-implemented radix sort will always beat pattern-defeating quicksort (no wonder, one is `O(n)` and the other is `O(n log n)`). That said, it's not easy to beat pdqsort. :) For example, on my machine pdqsort is only very slightly slower than the famous ska_sort (a radix sort) when sorting 10 million integers. Regarding D, on my machine with 100 million 64-bit integers stable sorting takes 18 seconds and unstable takes 12. This is quite a bit slower than C++ (12 and 10 seconds). I'm using flags `dmd -O -release -inline -noboundscheck`.
Well, because I find cross-language benchmarks a lot of fun. Who doesn't? ;) More importantly, yeah - it's a good idea to compare your implementation to other existing implementations, simply to get some sense of how fast or slow yours is. There were no other parallel sort in Rust so I had to compare with implementations in other languages.
Let me ask Sridhar.
Weird, because the numbers he showed implicated that D had the fastest known sorting implementation. Maybe it's not the default yet?
Does it come with a proof? Timsort is/was pretty cool, except it had a bug in it for years.
Because it makes C++ a cleaner language. How are the `class` and `struct` type different? This is entirely compiler defined and you have a huge amount of code describing it. This is something that we move away from the standard into the std-lib which is easier to manage. Imagine, for example, that we wanted to add PODs objects *after metaclasses*. We could have weird and complex semantics, that result in your pod-object suddenly becoming a normal object. The reason is simple: there are already many classes that would break if we added this feature too aggressively. We'd have to be very specific and "safe" when enforcing this. With meta-classes you can add a `pod` meta-class that hides away all the complex jumping and weird edge-cases, and you'd keep everything else clean. You could even have it that you can't make a `class` or `struct` into a pod-like class by default, and this has to be exposed through the `pod` metaclass. That way we know when things are *always* a pod because the programmer specified it. We wouldn't have our code suddenly broken because we passed around data to a C library and suddenly it's not a POD anymore (because of a simple convenience method that happens to be virtual). The compiler could still, behind the scenes, optimize some classes into POD objects, but this would be a compiler optimization and would affect the semantics or use of the language. So metaclasses don't allow us to just expose an `interface`, that's dumb. Metaclasses allow us to define a way to make new features in C++ be exposed through a library instead of adding a keyterm, or adding a new heap of complexity and special syntax to existing things.
Action at a distance, implicitly global instantiation, defaults applied to the real usage, rather than the test usage. What's not won't with Guice? In the entire time I was using it at Google, I never found a better answer for that question than "I'm lazy, sloppy, and don't like thinking through my architectural relationships, and this enables me to do these things." Which none of the people who loved it so ever said it loud, but it certainly showed in their code, which looked like Enterprise FizzBuzz with injections to cut through the tangles of initialization, instead of well thought out design.
C++ Primer, 5th Ed. is decent. Effective Modern C++ is a nice follow on.
Sridhar tells me this was a good tool but unfortunately we had to pull it because of some serious issues. If you'd like to see this tool revived, I'd suggest entering a [UserVoice item](https://visualstudio.uservoice.com/forums/121579-visual-studio-2015/category/30937-languages-c) and getting upvotes for it. There is work to be done here. It's more likely to get funded with a strong show of support from the community. 
Thanks for the quick reply! I will for sure enter an item. There is no tool out there at the moment with the capabilities mentioned in the video! 
Your excellent analysis is the only reason I'm approving this post with its obnoxious title.
No idea, honestly. I'm curious as well - maybe we can ask him? /u/andralex
&gt; I don't understand how data races can be avoided without restricting terribly the set of possible programs. The set of possible programs *is* restricted. For everything else, there's `unsafe`.
Vim is an excellent text editor. There are several plugins for autocompletion and other nifty things. And I'm sure there are plugins for integrating build systems into Vim as well. Here is a pretty extensive [manual](https://www.gnu.org/software/make/manual/make.html) for GNU Make.
I really enjoyed this book: Discovering Modern C++: An Intensive Course for Scientists, Engineers, and Programmers (C++ In-Depth) https://www.amazon.com/Discovering-Modern-Scientists-Programmers-Depth/dp/0134383583 It's not a huge tome, which I consider to be a positive, but it shows how modern c++ can be used to solve real problems. Probably oriented towards engineering and scientific code, but that works for me. It may be useful to have Stroustrup (C++ Programming Language) or C++ Primer (Lippman et al) as a thorough reference besides. Also recommend C++ Templates (Vandevoorde, et al) but they are going to be releasing 2nd ed in a few months. I consider this to be the best template learning resource though. 
I assume the OP means unnecessary. a- is not that atypical a prefix for negation.
Where it said/written? They are designed to replace `__attribute__`/`__declspec()`. Even one of the examples in attributes proposal is about specifying the alignment, which often times is crucial to the code working.
&gt; Can't know until you do the tedious part. I disagree, in a sense that if idea is stupid it is likely that it is easily disprovable by somebody who knows better. :) If idea is not stupid then you are right, but chances for that are slim.
Hi /u/AndrewPardoe, I'm relatively new to modules but certainly interested in using them in my primarily-VS projects and libraries. Whilst I mostly control that ecosystem, I do need to use some of the libraries in a more 'standard' project (i.e. some UE4 stuff) that is full of includes. Are there any ramifications or problems with a project both importing modules and including headers? Lastly; how does a module import interact with static lib linking? You link your libs and then import modules as required, where those modules are defined and exported in said lib?
&gt; Alignment is controlled with the alignas specifier, not an attribute. Right now, yes. Before it was (proposed) to be controlled by the attributes: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf Also, I'm not sure how what you've quoted from the standard means `so using them to affect semantics is a no-go`. Especially in a beautiful futuristic world of metaclasses, which itself allow you to define contextual keywords with user-defined semantics.
&gt; Also, I'm not sure how what you've quoted from the standard means `so using them to affect semantics is a no-go`. I don't really know how to clarify this... Implementation-defined means you can't rely on an attribute having any specific behavior except for the guarantees made by a _specific_ version of a _specific_ toolset on a _specific_ platform. If the attribute is intended to cause a change in semantics then it's effectively an implementation-defined _language extension_ — does this not sound like the epitome of A Bad Thing™? A compiler that doesn't support the attribute, or gives it different semantics, is just as likely to compile silently with the wrong behavior as not. &gt; Especially in a beautiful futuristic world of metaclasses, which itself allow you to define contextual keywords with user-defined semantics. User-defined, not implementation-defined – _that_'s the point. What the user defines will work the same way across _all_ compliant implementations, and if the necessary metaclass isn't defined then you get a compilation failure instead of \&lt;whatever your compiler vendor happens to do\&gt;.
Saying "you can do the same with macros" is not an argument _for_ something, it is an argument _against_ something. Macros are much worse than templates, because macros follow basically no rules - you have no idea what is inside a macro without looking at it - did it declare a local variable, etc etc. So as long as metaclasses have a bound to what they can mess with, it won't be as bad as macros.
Definitely, so far within the committee, attributes are meant to be ignorable by a compiler.
This probably changes when you can reflect attributes.
&gt; Can you illustrate "extra move" overhead for ctor_shared? I don't see any. If you capture argument in lambda -- you'll have an extra move (and dtor), if you capture all arguments by reference (that are used to create that argument) -- then no. I didn't think this one though. &gt; Please illustrate where the price is. Price is still the same: atomic inc/dec (due to shared_ptr aliasing ctor usage) + lambda ctor/dtor (which in this case is likely to be eliminated, it [seems](https://godbolt.org/g/HEdn7B)). Edit: [here](http://cpp.sh/8mpk6) is an approach that makes ctor_shared obsolete. I expected lambda to have some extra cost, but it seems it is not the case.
There shouldn't be any issue using modules with header files. Modules are also designed with work with either a static or dynamic lib model. They should be orthogonal to other language features. In some places you can get yourself tied up in a way that we would consider a lower-priority scenario. For example, including modularized code in a PCH is kind of weird (but I know a team who did it temporarily.) But in general, if something works without modules and stops working with modules, please let us know. 
&gt; If you capture argument in lambda -- you'll have an extra move (and dtor) You're pointedly ignoring the whole "_a `[]` or `[&amp;]` lambda with limited existence like that can be inlined out of existence_" part... ;-]
Do you know how to access various meta members? I'm trying to create a function for each variable, but I can't seem to get anything working (unknown type name 'f').
Can this operator can also be used to move values? I mean for example: void f(std::string s) { g(std::move(s)); } Could the be replaced by: void f(std::string s) { g(&gt;&gt;s); } Is there a case where `std::move` it's better than the operator?
There's a button under the ASM, to the left of the full compiler version.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
I do not really like it too. On top of that the use case seems rather limited to me. How often do you need to evaluate such enum constructs? Imho only once in your code. If you do it twice (or even worse repeatedly rely on the same enums to determine behaviour) you should consider to encapsulate those behaviours into specialized classes and only construct them once with the help of those enums. If you do those evaluations within a class there is a name for this anti pattern: *tagged class* (Clean code by uncle Bob) Btw: Nesting could easily be more readable by separating the sub enum evaluations into separate functions! That is also true for some kind of unique factory function.
Have a look at TOML. Imho much nicer than YAML.
From the discussion above and below `try_` calls some TLS variable that contains whether an error happened. If you don't call `try_` the program continues in an error state. If you do: auto r3 = make_negative(-1); auto r4 = try_(make_negative(1)); Either you get an error or the error of r3 is lost. If you get an error you don't know that the error is from r2. If you don't get an error the program continues in an invalid state. Anyhow calling try_(r2); afterwards cannot really tell you, if there was an error, that the error comes from the r2 computation. So in the presence of coroutines this scheme might be a bit dangerous. If you are using `Boost.Fiber` which allows migrating coroutines between threads, the use of TLS will just deliver wrong results: // in coroutine: auto r2 = make_negative(-1); // migration to another thread try_(r2); // might return that there was no error // other coroutine in previous thread auto r2 = make_negative(1); try_(r2); // might return there was an error Is this correct /u/emildotchevski ?
I've stopped reading any further after seeing `cmake_minimum_requiered(VERSION 2.8.11)` and `include_directories(...)`. Don't do that any more. CMake 3.x isn't that bleeding edge any more.
I'm not that well-versed in CMake - is the 3+ alternative to `include_directories` just `include_target_directories` for the appropriate targets?
Yep
It's probably worth noting that the real strength of pdqsort isn't in dealing with completely random inputs--Quicksort does very nicely for that. The real strength (much like introsort) is dealing with inputs that follow some patterns for which which Quicksort works relatively poorly. Introsort handles this by keeping track of recursion depth, and if it gets too deep, switching to a Heapsort. As is well known, heapsort guarantees O(N log N) complexity, but is typically something like half the speed of Quicksort. A lot of the speed improvement in pdqsort for random inputs really just comes from careful tuning--cache alignment, branchless partitioning, etc. It also underwent a fair amount of testing by a number of people during development--for example, the first attempt at branchless partitioning helped performance on sorting `std::vector` quite a bit, but was basically disastrous if you applied it to an `std::deque` instead. A couple of different ways of dealing with that were tried before the current one was chosen. If anybody has a lot of patience (and a little bit of reputation on StackOverflow) you can read through the transcript of [`Lounge&lt;C++&gt;`](https://chat.stackoverflow.com/search?q=sort&amp;user=565635&amp;room=10) for a lot of the gory details.
I do it all the time, and *only* for tests. Superior to the alternatives.
&gt; I mean, they are like mini-PCH in that it lets you get access to C++ code from somewhere else without recompiling it each time. No, you will need to recompile it each time unless you restrict yourself to a sub-set of C++ (e.g. no templates in the interface).
There's still use for the separate proposals sort of as a side-research project. It looks useful for a whole lot; so make sure that it's general enough at least for the stuff that we know we want.
FYI I fixed it :) Hope it looks better now.
If you create a user voice item it would be good to post it, I think this would be useful tool The closest thing I could see on there was a slight mention of the same idea in https://visualstudio.uservoice.com/forums/121579-visual-studio-ide/suggestions/2680137-make-header-include-refactoring-possible
While not strictly required, using Vim as your development environment without makefiles is impractical at best. Learning makefiles isn't hard. The manual is [here](https://www.gnu.org/software/make/manual/make.pdf), but you can probably make due with just this [here](https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html). In any case, yes, you're going to want to learn makefiles and CLI with Vim. But, if I may offer a suggestion? Have you tried VSCode (on Mac or Linux) or Visual Studio (on Windows) with the Vim plugin? Because it's pretty nice. Not perfect, but it can be easily bundled with things like linting and auto-complete which is a *massive* pain in the ass with Vim, especially for C-languages. I would suggest you look into those. With Visual Studio you don't even need a CLI up, and with VSCode CTRL+~ can easily toggle a shell. It's just a suggestion. I liked Vim and the keyboard shortcuts just feel good now, but some things are just better handled by an IDE, and managing plugins through Vim is just annoying. I'd rather have easy plugin functionality AND Vim keys. Best of both worlds!
No, I mentioned this in the rest of my message. I was explaining how I ended up with that incorrect statement. In fact, at the very end I proposed a solution that is a refinement of his idea and avoids any extra costs (it seems... generated asm looks a bit fuzzy, but I can't find anything wrong with it).
While it is a bit different, I am quickly mentioning [cotire](https://github.com/sakra/cotire) as a way to generate PCH files, if you are using CMake with VS.
https://visualstudio.uservoice.com/forums/121579-visual-studio-ide/suggestions/19753354-automatically-generate-precompiled-headers
Ideally we would have two notations like void foo(Concept a, Concept b) and void foo(Concept a,b) The first one allows two different types, the latter not. Then we could write something like std::copy(InputIterator b, e, OutputIterator o)
&gt; I don't see how user-defined attributes can be introduced unless they have substantially different syntax. How does the compiler distinguish between an undefined "user-defined" attribute vs. an unsupported regular (implementation-defined) attribute? The symptom is the same – all the compiler knows is that it's encountered an attribute it doesn't recognize. Compiler aside, this seems like quite a source of confusion for users... ... just like the compiler distinguishes between an user-defined type, and an unsupported regular implementation-defined type ? e.g. __int128_t or stuff like this ? Being against this is somewhat throwing the baby with the bathwater. Attributes are ridiculously limited as of now in C++; of course their scope should expand to allow users to define them with whatever semantics they wish for, ideally to meet and surpass the capabilities of C# attributes and the likes.
I guess `min` needs to be captured here (page 4) constexpr { if (count_if($T.functions(), [](auto f){ return f.name[0] == ‘g’; }) &lt; 1) compiler.error(“at least ” + to_string(min) + “ function names must start with ‘g’”); }
I think the `bitfield&amp; operator=(const bitfield&amp; that) { // copy assignment operator` code is missing a wrapping `switch` statement. Otherwise: a terrific addition to C++!
Now I do not use Vim myself, but I know a lot of developers that do, including some of my colleagues. What plugins you need depend on yourself, Vim is highly extensible and customable, and though I am a Emacs user I think Vim is easier to extend. Learn makefiles: Read the book https://www.gnu.org/software/make/manual/make.html Multiple file projects alternatives to Make, there are a arse load. My favorite is python based and is called Waf: https://waf.io/
&gt; Doesn't help for cross-platform, but that seems to come up surprisingly infrequently. not providing cross-platform support out of the box in this day and age is absolutely unimaginable for me 
&gt; void foo(Concept a,b) This is syntactically ambiguous, and may be as tricky to readers as `void f(X&amp;&amp;)`.
The most used GUI library for C++ is QT
Does that not indicate that we should not introduce the "natural notation" at all, at least right now. Both sides have valuable points and no matter what you choose both solutions seem to have a good chance to catch users out. I would rather have concepts now with bit of a clumsy syntax but the chance to later add the short version than adding now a short version with the risk of having another C++ "in hindsight" gotcha for programmers to come. As /u/sphere991 points out the natural notation is often not so much shorter after all. And as /u/tpecholt comments with ranges the STL view might look very different. Right now I see pushing the natural notation as a relatively high risk move for relatively low gain. And introducing a more explicit notation now does not prevent us from adding the "right" choice later if necessary.
I don't see this being the case for most user code. The algorithms have a lot of complex requirements and ties going on, but I expect most user code will not need extra relations, meaning the terse syntax would fit them perfectly. This was certainly the case for the last class I wrote that used concepts, and the terse syntax made it much, much easier on the eyes.
&gt; can't really find any great GUI libraries. Can't find any great ones or any at all? There are loads of GUI libraries, which ones didn't you like?
Making GUIs and games are two very very different things, from the design standpoint as well as programming standpoint. There is no magic wand that will do both perfectly.
For games. I really like SFML. It's very easy to learn and use. And you can create games quickly with it.
If you want UIs that use native widgets, then wxWidgets is still the way to go. Note that Qt *doesn't* provide this. That said, since he mentioned games, I'd guess he wants to have a library for displaying the in-game UI, ie. health, ammo, etc.
Qt
Well I guess C++ wasn't already complicated enough. This proposal certainly ought to help with that.
A recent version of Qt does actually provide native widgets, but currently it is a little limited.
Could you please update the benchmarks in the readme with a modern compiler and version of fmt?
Yes, it's on my TODO list =)
Cute question
Don't update?
aren't they simply emulated to look like native?
I was looking at the benchmarks and it says that Boost Format is smaller **without** optimization. Is this a error or actually true?
Check the sidebar. [Specifically this list](https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list)
&gt; An enormous amount of successful, commercial software runs only on one OS I don't even know any "successful, commercial software" which came after 2010 (e.g. not adobe, office...) except games and even those nowadays tend to be cross platform.
The same goes for IOStreams and tinyformat. It could easily be true. Think about loop unrolling, for example. The code might be faster, at the expense of an increase in executable size.
Done. Nonius is about 5.5x times slower than sltbench on testing dataset (87 seconds for sltbench versus 482 seconds for nonius) and a bit less reproducible (0.4% average relative error for sltbench versus 2.6% average relative error for nonius). Maximum relative error will be obtained later. If you want to reproduce results (see metrics documentation section in sltbench, link in the comment bottom, I will add nonius backend to documentation asap), you need fixed nonius version. The latest one produces incorrect xml-s when --reporter=junit is provided. I've already proposed the merge request to fix the problem, but noone knows how fast it will be accepted. (https://github.com/rmartinho/nonius/pull/2) I will add instructions for nonius to metrics section asap: https://github.com/ivafanas/sltbench/blob/master/tools/metrics/README.md
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6k07zq/c_gui_library/djiphbl/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6k22hc/im_having_some_issues_with_arrays/djipkby/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Don't paste images of code, paste it indented by 4 spaces. Ask in /r/cppquestions Use a vector
Ah of-course. That makes sense. Didn't think about that thanks!
And that's why I specified... "For games". Twice actually. :-)
That's right, the non-optimized compiled code is smaller than optimized one for Boost Format. I didn't look into why but @boredcircuits's explanation seems reasonable.
Are there any breaking API changes?
Good point. I should probably do that.
Yes, but probably not on APIs you're using.
Only semi related but it occurred to me recently that immediately evaluated lambdas are a really nice way to actually implement a macro. This actually lets you combine many of the upsides of a macro while strongly mitigating their downsides. For instance, you can still substitute a class name in multiple places inside the lambda, but you can also forward some of the macro arguments into arguments of the lambda, ensuring they are only evaluated once. And of course you get a new scope and a single clean statement without do while(0) shenanigans.
How is the proposal for standardization going? I see that it was recently submitted http://fmtlib.net/Text%20Formatting.html (P0645R0)!
&gt; just like the compiler distinguishes between an user-defined type, and an unsupported regular implementation-defined type ? e.g. __int128_t or stuff like this ? Huh? The compiler makes no distinction here – if your code tries to use `__int128_t` and no `__int128_t` is defined, you get an error. Whereas with an attribute, the compiler is supposed to _ignore_ what it doesn't understand. &gt; Being against this is somewhat throwing the baby with the bathwater. C# attributes are useful because C# has runtime reflection. Getting hung up on things like "but _their_ attributes are useful, ours should be, too" is pointless; attributes aren't inherently desirable or useful until we have reflection, there's no baby here.
I should really be hired by the big players to name their APIs
My favourite is Modern C++ design by Alexandrescu. It really changed my mind even if I wasn't able to catch 100%. It may sound superseed by the new standards to some extends but IMHO still is an enlightening reading. m2c
Website isn't updated yet.
What will be so big in the change that it requires a 2.0 version? :O Will there be any breaking changes?
I believe 2.0 is C++ 11 based, which allowed them to remove a ton of C++ 98 compatibility cruft, thus making for much faster compile times.
Moving things to new headers or between headers is a breaking change. It means that existing code has to add `#ifdef`s to handle the different ways of `#include`ing across the different versions.
And if you care about size you have `-Os`. Well at least GCC has it.
You say that like you expect fmt to be on the system already. You're not statically linking it?
I strongly recommend [The C++ Standard Library (2nd ed)](http://www.informit.com/store/c-plus-plus-standard-library-a-tutorial-and-reference-9780321623218) by Nicolai Josuttis. Of all the books I have on C++, this is by far the one I refer to most often while programming.
If a library statically links fmtlib, and anyone using that library also uses a different version of fmtlib, they've got ODR violations. I.e., this is just begging to give someone a headache some day.
With `ldc2 -O3 -release -boundscheck=off` stable sorting takes around 15 seconds and unstable takes 10 seconds. Much better, but still not stellar performance. Disclaimer: it's entirely possible that I'm missing something, since I'm not proficient in D.
I don't know - C++ people don't /need/ a safe-space, I'm sure half the people here would switch if something faster came along. And if rust got to 99% of C++'s speed, many would switch for the increased safety. 
FYI (and /u/awson as well), vcppdogfooding has (finally) been updated, with compiler v19.11.25428.
Traff OÜ is an effective online marketing platform, at which advertisers can make best use of your resources, and site owners have the opportunity not only to make money on Internet advertising, but also to participate in the promotion of leading brands.
In my [(draft) paper](https://drive.google.com/open?id=0B1-vl-dPgKm_T0Fxeno1a0lGT0E) there are asymptotic complexity proofs, but the C++ implementation does not come with formal verification. However, one of the people that worked on the Timsort verification is a professor at my university, so perhaps I can talk to him to see if it's a worthwhile project.
Go go go Vinnie!
This is true. Not everybody is going to switch to a different sorting library and opt out of std::sort implementations that don't perform as fast. In comparison I believe Rust is adding pdqsort as the default sorting algorithm. Faster by default until C++ compilers adopt a better sorting algorithm. The unfortunate reality is that the performance of many languages is often compared by the defaults, and not actually on equal footing. Sometimes benchmarkers even make the egregious mistake of assuming one compiler is indicative of the language's performance. Python's a great example. CPython tends to be slower than PyPy and Cython due to implementation details.
In first example, the command to compile the program must be specified. The blog said : &gt;The program runs without problems and outputs: &gt; service ready It depends on how you compile the code. test|⇒ g++ service.cpp main.cpp &amp;&amp; ./a.out service SERVICE1 ready test|⇒ g++ main.cpp service.cpp &amp;&amp; ./a.out service ready Though the blog ref this : https://isocpp.org/wiki/faq/ctors#static-init-order Using g++-7.1 on Arch
Good luck! (Though I don't think you need much :-) ) ~~Why does the GitHub repo have the tags "tensorflow" and "machine-learning"? That leaves a bit of a sour aftertaste for me as it looks like "click-bait" (or "search-bait", if that word exists). You really don't need that. Or do you have a solid reason for it? I went to the documentation and could not find any reference to it.~~
Languages are tools. Part of the reason Rust shows up here is that there's a lot of interest in the possibility it may replace C++. This leads to a lot of benchmarking the two languages. Sometimes it's relevant to us, sometimes it isn't.
How the linking process works with static libraries and why the order matters; understanding how it works makes it much easier to get it right http://eli.thegreenplace.net/2013/07/09/library-order-in-static-linking Redirecting system calls from a C library. Surprisingly simple and easy to do. https://www.jwhitham.org/2015/07/redirecting-system-calls-from-c-library.html Fast string tokenising in C++ https://tristanbrindle.com/posts/a-quicker-study-on-tokenising/ Writing your own surprisingly simple JIT http://nickdesaulniers.github.io/blog/2013/04/03/basic-jit/ In range based for loops, when to use auto/auto&amp;/const auto/const auto&amp;/auto&amp;&amp;/const auto &amp;&amp;... https://blog.petrzemek.net/2016/08/17/auto-type-deduction-in-range-based-for-loops/ Win32 CRT Debug Memory Magic Numbers - just invaluable knowledge http://www.nobugs.org/developer/win32/debug_crt_heap.html Using modern C++ smart pointers with types that require a specific function called to tidy up http://swarminglogic.com/jotting/2015_05_smartwrappers
No idea what you're talking about! :)
Wow, this must have been a very weird GitHub glitch. I swear that along all the tags (e.g. "boost, osx, tsl, ssl, ...etc"), there was "tensorflow" and "machine-learning" at the end (even after I refreshed the page). I went back to the Beast repo now and now it's gone. If that wasn't you, then that's really, really weird. Sorry about that.
He probably just changed it once he saw your message.
That would be awesome
Nailed it! this should be your emBO++ talk
May be. Official site https://nonius.io points to rmartinho github account, not libnonius, but rmartinho is forked from libnonius, so I really do not understand which repository is the correct target.
Any plans for CTest integration?
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [philsquared/Catch/.../**ParseAndAddCatchTests.cmake** (master → 6f32db3)](https://github.com/philsquared/Catch/blob/6f32db35af06b30701d159b9e16a21e76d82aada/contrib/ParseAndAddCatchTests.cmake) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djk87bb.)^.
What?!?! When did this happen? I've been running Catch tests through CTest like a pleb!!! Thank you so much! I have to edit my CMakeLists.txt immediately!
non_thread_safe version added https://github.com/tower120/reactive#non_thread_safe . Performance around ObservableProperty highly depends on listeners count. With zero listeners update 400'000 values took 5ms for non_thread_safe version and 26ms for thread_safe (VS2017). May be faster if you will update the same properties.
As pleasant as the short form seems, without Concepts there will be no discussion. Quoting Guido: "Guys, we are not Perl. We can afford to write a few more lines of code."
History says about 2 months ago.
&gt; Rust and C++ are like Harry Potter and Voldermort, neither can live while the other survives. Completely ignoring the fact that C++ lived for 20+ years before Rust was conceived.
&gt; Apparently there are efforts to make Orson's pdqsort part of C++ but they've been going slow. I'm sure there'll be 10+ years of people complaining that switching to pdqsort from whatever default their STL implementation uses would break the non-standard assumptions they made about how equal keys would be unstably ordered.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [onqtam/doctest/.../**benchmarks.md** (master → b8d0e61)](https://github.com/onqtam/doctest/blob/b8d0e618d93f980e8ee742041cb6e97f630207e0/doc/markdown/benchmarks.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djkcvnm.)^.
Best of luck. Keep up the good work.
I don't think he ever said it was in D. It looks like he started work getting it added to D's standard library but didn't finish it. He's got [this repo](https://github.com/andralex/MedianOfNinthers) that seems to be related and isn't that old.
No, the C++ standard provides no such guarantees. The constexpr-ness of something has little to do with it being a constant value. Instead, can you interact with it in ways fully defined and specified by the standard in a way that is doable at compile time? There is no way to extract the bits in a function pointer's address without relying on unspecified behavior; so those bits do not have to be the same between executions of the program. PMF are less well specified, partly because different compiler vendors implment them very differently. Some compilers have `sizeof(PMF) &gt; sizeof(void(*)())` in some cases, for example. Others don't. There is no such guarantee for PMFs either. 
It put it in a namespace, the fact that you can use the namespace scope or do a using is sort of implied? Or is there something else I missed?
For templates this intermediate representation is exactly the same one you get from PCH. The only thing one can do a priori is check whether templates are syntactically valid (e.g. you did not miss a semi-colon, which can be done for PCH as well). Everything else has to be done when you pass it the types because: - templates cannot be type-checked a priori (which might produce a compiler error). - visibility and ADL affect the compile-time path that code inside templates might take (e.g. due to SFINAE) So even when modules, when you call a template, you need to type-check it, process possible errors, generate code for it, ... and none of this can be cached between TUs. /u/AndrewPardoe I'd like to see some benchmarks of MSVC compiling e.g. the `&lt;tuple&gt;` and `&lt;functional&gt;` tests, without anything, with PCH, and with modules. With and without taking into account the time it takes to compile the PCH and the Modules. 
So, your position is better Concepts with short forms in 2023 than Concepts without short forms in 2020? Because that is the opposite of manphiz's position: Concepts in 2020, with (ideally), or failing that without, short forms. 
A good Concept clearly accepts more than one kind of thing...
Why not permit short form concepts *but you cannot use a concept more than once* for now. 
 void f(std::string&amp; s) { s = g(&gt;&gt;s); } is not the same as void f(std::string&amp; s) { s = g(std::move(s)); } 
It's not technically UB. The init order is unspecified / implementation defined in that it has to be done in some order, but you don't know what (in practise it's typically the order the TU's appear in the link line, although some linkers have pragmas or other directives also). Linking is a netherworld that exists mostly outside of the language standard. This specific case also depends on the fact that a `std::string` object that is just block of zeros is valid, empty string for the given standard library implementation. But you could do the same thing with `int`. Yes it's horrible (see the "F" in SIOF), but it's something to be aware of, even if just to avoid falling foul of it. It would be great if this was cleaned up by the Modules TS, anyone know if that addresses SIOF at all?
Meaning a compiler needs not change anything _just_ because an attribute is associated with a function/symbol. Why does this preclude user code (in the form of metaclasses?) branching on attributes if they're merely left associated with a symbol?
The C++ standards committee should introduce C3 already. Some strict C++17 mode that breaks backwards compatibility so we can move forward when writing new software from scratch. 
&gt; reinterpret_cast-ing to say intptr_t that's not possible at compile time
There is no guarantee that function address will be the same between executions. You might get the effect you want by creating a function object and serialization that. The boost serialization library supports this functionality.
Probably better off ( and much a safer ) going with serializing the function as a string and deserializing with a factory
Should the `Communication` class manage the lifetime? I think the answer is yes, depending on the finer points of "manage". What I really want is for the `Communication` object to keep the `HardwareInterface` around as long as it (the `Communication` object) exists. The two ways to do that are: 1) Hold a smart pointer to it 2) Document that the user needs to We keep the `HardwareInterface` around for the lifetime of the program (I can't think of a single instance where we create and destroy these - just create them at init time and keep them forever), but I think we should enforce that in code and libraries. I don't think a `weak_ptr`is a great fit as we shouldn't destroy the `HardwareInterface`once it's created. I think my real question is: is it good enough to just document that the user should manage this? Should we try to do better with the smart pointer? I'm not sold there's a simple yes/no provable answer, but if we're going to spend a bunch of time writing libraries and adapting code for libraries, I'd like us to make a good decision early and stick to it. 
Do you know what makes function objects special? I assume you're still just serializing a pointer to operator() member function?
Every library that you mentioned makes odd choices on behalf of users. Beast: no odd choices. That is why Beast is growing steadily in popularity.
I will not mount a serious defense of template introducer syntax here.
 #define freedom ;
I can imagine that being allowed. Possibly even motivation for making sure attributes are part of reflection. I think it has come up in discussions.
Hmm... maybe you can try to calculate offset of given function to 'main' function and store that.
No that's not my position at all. More along the lines of I prefer a 75% chance of concepts with shortforms in c++20 than 90% chance of concepts without shortforms. I get that concepts is great for library writers, but as an application writer, concepts without shortforms is 'meh'.
Yeah, I was clarifying that while shoving bits into an int and using it is still defined, doing the same for `std::string` is not. Of course working is valid at that point, and you can conceive the reason being that all 0 bits represents an empty string, it's just pedantically undefined either way.
Few thoughts: - to minimize allocation overhead you can use [make_shared](http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared) - [enable_shared_from_this](http://en.cppreference.com/w/cpp/memory/enable_shared_from_this) can act as interface in Communications ctor: Communications::Communications(enable_shared_from_this&lt;HardwareInterface&gt;* ptr){ auto sharedPtr = ptr-&gt;shared_from_this(); auto regularPtr = (HardwareInterface*)ptr; } edit: another possibility is to add ref counting to HardwareInterface for additional security (assert in destructor). 
To be fair, the maintainers of CppRestSDK have said that they will consider switching to using Beast internally for non Windows platforms if it becomes part of boost. Currently they implement HTTP on top of boost asio and Beast simply does this better. (Im saying this as someone who has contributed multiple large features to CppRestSDK). Beast should make it easier to write good http libs, I don't currently see it as directly consumable for someone who wants to just make http requests.
&gt; Many of these have more features ( read more useful for real work ) Is this the "No true Scotsman" logical fallacy?
Honestly, I've thought that there should be something like a syntactic sugar frontend for C++ (which I think, personally, should resemble Python, but of course many may disagree) which makes almost-exclusive use of modern C++ features (like every variable being `auto`, and every loop being over a collection/generator, for example). Even, perhaps, a mostly-functional style where every variable is `const`-by-default. But then, once I go too far down that path, I end up thinking "Well, why don't I just use Python or some functional language..." Still, I think C++ is capable of a much better middle ground.
&gt;&gt; was a great, subtle way to trigger my OCD Achievement unlocked! I've fixed the formatting--thanks for the note. 
I just tried to update, with both PowerShell and nuget.exe, and the only package available (even with -AllVersions option) is 14.0.24629. Which is older than the one i have. Can you tell what you did to get the new version?
The thing about c++ is that it really is many languages. If you are writing brand new code, just use the new stuff (never use new and delete, just the make_unique, or make_shared stl classes) and you really don't need to worry much about the "big three" (or 4 if you include the move constructor. Usually only library writer need to worry about move constructors though). If you need to maintain older code, then you will have to worry, but the sooner you migrate it to the newer syntax, the better. You only need to go the "c" level if you are making OS level calls; and often those can be avoided by using STL or some other library to do the work. Also avoid c run time calls if you can, stick to c++ stuff. Really you just need to work with it. There is no royal road ([Euclid](https://en.wikiquote.org/wiki/Euclid) for geometry) and no substitute for experience. Edit, just came across [this](https://www.reddit.com/r/programming/comments/6k7q12/the_rise_of_the_new_language_mc/) post which gives more details.
Cool, I'd love to hear the results. On top of the Github repo I also have a [draft paper](https://drive.google.com/open?id=0B1-vl-dPgKm_T0Fxeno1a0lGT0E) available for reading that explains the design and contains some asymptotic complexity proofs.
Not really, I mean freedom as in freewill. I'm a mere engineering student and I only have a couple of scholar projects in C++ so I can be wrong in my opinion. I like C++ because it gives me the freedom of choosing how I manage my data, if I want to move it, copy, passing the reference or a pointer I can do it. If I want to put my data in an union because reasons, I can do that. If I want a 'simple' life I can use a container in the std and choose to leave my trust in them. If I want work with bits I can do it. If I want to load a full file in to the ram, it let me do it. If I want to break a code line into two, I can do it without black magic. It let me choose freely between tabs and spaces. Also, if I want to do a web server I can do it easily, if I need to do a parser I can do it, if I need access to the GPU to do some visual processing stuff I don't need to change languages (well, that's isn't true, but HLSL doesn't count), if I only want a console program I can make it, and if I want to make an embedded program I can do it. There are a lot more reasons, but you get the point. That kind of freedom is the freedom I like.
I've been mostly writing in C++ for many years. I still feel like a newb.
If you really consider which of those things are actually missing from other popular languages like Java, most will inevitably be low-level optimizations which can result in segfaults. :P
They rolled back the version from v19.11.25428 to v19.11.25415 (no idea why), but I do see the latter there presently... I don't use NuGet to use the packages, but rather just unzip them directly so that multiple projects can reuse the same installation — so if your problem is NuGet specific, I've no idea, sorry; but if the problem is just obtaining the package, the current URL for the latest package is http://vcppdogfooding.azurewebsites.net/api/v2/package/visualcpptools.community.vs2017layout/14.11.25415-pre To see the list of package URLs directly you can go to [the package manifest](http://vcppdogfooding.azurewebsites.net/nuget/Packages) and look at the `feed/entry/content` nodes.
Programmer jokes are awesome. ~~but i think that semicolon shouldn't be there, sir~~
I’m old. I started with C. So when I started using C++, I already knew a subset that was a complete language in its own right. I could incorporate more of the language into my work as I learned it. And I’m excited that today there is still more for me to learn. Arguably few people should ever master the whole language. There are parts of it that are only really relevant to specific work. And as it keeps moving forward, there are parts that are becoming obsolete which shouldn’t be used by people who have mastered them. I wouldn’t necessarily suggest starting by mastering C anymore, but I think it is still entirely valid to start getting real work done with a subset of the C++ and build from there. There is no shame in only using the parts you know. You’ll always be looking back on your old code and seeing how you’d do it differently today, but I’ve found that happens with every language anyway.
Your words are touching. I think if the things you want to do can only be properly done with CPP, you'll get a lot more courage. (Not exactly a response for your question) And in my opinion a subset of the language will suffice. A lot of the times what is important is the experience which is not necessarily coming from studying the language itself, but from working on the exact type of projects that you intend to make a profession.
I've been writing C++ for 20+ years. I probably qualify as an "expert" in the language tho there are still corners of it that I am definitely not an expert in (TMP, for one). For the most part, I know quite a bit of language, and for the parts that I don't know as well, I can fumble my way through with the occasional help of google. I know what I don't know, if you know what I mean. I enjoy the language very much, its many warts notwithstanding. I remember starting out as a professional working on a largish application (~500k LOC in the early '90's) and marveling at how the experienced devs managed such a large codebase. But then you work in it yourself for a while and you gradually change your perspective and learn that you don't need to hold it all in your head at once. I now work in codebases on the order of 10's of millions LOC. You learn how and when to compartmentalize. The same is true for learning C++. C++ is clearly a very large language. It has a lot of dusty corners. But, for the most part, you don't need to go into those corners. You can get a very long way just by staying out in the middle of the dance floor, so to speak. Avoid manual memory management. Avoid raw pointers. Use STL containers and algorithms. Follow standard code idioms. Understand the difference between pass-by-value and pass-by-reference. Learn about the occasional dusty corner -- learn why you might want to go there and the reasons most people don't. People learn C++ every day. You can too.
I think that's pretty much what he said.
I figured the point was that you could group on arbitrary dimensions. If you want larges together, put the larges together. Or maybe the larges, first, and then sort by color then size for the rest, whatever makes sense for the code. It's more flexible. The real problem is the `End_` requirement IMO. Breaks exhaustiveness checking.
I've been doing cpp for... 6-7 years, 5 seriously and continuously, through uni and I program pretty much every day, I definitely wouldn't consider myself an expert but know more than some I guess Occasionally i'll discover a random new feature that I had no idea about. Recently it was that you can call functions like ::std::whatever to access the global namespace, and after that that dependent types in template shenanigans need a typename keyword stuck in there, just for fun I generally steer clear of any complex non exclusively helper (ie user facing templates) template code as its totally unmaintainable as a rule (eg creating classes that fit the begin/end semantics or weird move semantics etc means i'm 100% doing it wrong), which is why i suspect I'd not seen those before. I only noticed the first poking through the STL while debugging, and the second on a totally unmaintainable piece of template code There's still features I need to get more familiar with. Anonymous namespaces for one are a feature that i forget about 100% of the time and have to google. C++14 introduced a bunch of stuff, and c++17 even more. Keeping up to date is really ongoing with c++
I wasn't too bad from 2005-11, now I am playing catch-up constantly :-). ~~Exit:~~Edit: that said, language is 10% of what one needs to know. Tooling is next 20, system is next 20, 3rd party libs next 20 and your problem domain the remaining 30 :-). Disclaimer: 45,73% of all percentages on the internet have been invented on the spot.
It rather looks like you went down the empty rabbit hole. If you step away a bit, what bigger goal are you trying to achieve?
https://www.reddit.com/r/cpp/comments/6ka5um/serializing_function_addresses/djlclhb/
You see, the debugger figures out the address of functions (so it can decode the stack), so they are maybe just implementation-defined.
For embedded stuff, I would tend to reach for the first approach (user MUST handle the lifetime properly). `shared_ptr` transfers the lifetime control to "uncertain when the thing will be destroyed", which might be bad in embedded (and elsewhere). To my mind, you are making a mistake of reaching for `shared_ptr` for wrong reasons (e.g. "toys! Looks easy!). Think of it this way: how well did your code work without it so far? When did you encounter lifetime management problems and how did you solve them? How much would `shared_ptr` have helped as opposed to the way you solved it then? People who consider performance implications, OTOH, need to see the impact first. It's possible that it's negligible for your code. So measurements first. My stance is: one really **needs** `shared_ptr` only in multithreaded scenarios, as they are a very hard case of "uncertain when the thing will be destroyed". Otherwise, it's most often reached for out of convenience. As I am old, I think convenience is overrated :-).
Totally, I can lookup the function address in a table by index (provided the table is built deterministically which I can do), or I believe I can serialize a polymorphic function object (which boost::serialization supports).
No, I don't feel like I never learned it, but I do feel like there are always shores or coves to explore.
Yup, to clarify, every feature the above commenter listed is true in Rust.
This is not always good advice, often some thing you ignored could make your life much easier. 
no,you are always learning
Yes, it does get easier. There is a trap in learning C++, which is that there are really two kinds of C++ programmers: those who write libraries (and complex online tricks and puzzles), and those who write applications. The first group wants to be as generic as possible while at the same time be as efficient as possible, so they are deeply into template meta programming, and can argue for days over things like perfect forwarding and noexcept (just look at the discussions on forums like this). The second group Just Writes Code. Sure, they write the occasional template, but it turns out that taking a tiny hit on efficiency by passing a const reference instead of perfectly forwarding a no-except function pointer object template pack blah meta thingie _also_ works just fine. At the cost of a few nanoseconds of additional processing and twelve bytes per allocated object, of course... And their primary concerns are making sure the whole thing doesn't blow up in their faces, and compile time. The first is actually surprisingly easy once you get into the habit of RAII, and the second mostly means steering away from giant template-based monstrosities and the ridiculous fad of 'header-only' code. The thing is that the first group is very vocal: they are at the forefront of language development, and they will endlessly discuss these painfully low-level language features as if they are the only thing that matters. And I'm not saying it doesn't, but that does not automatically imply that it also matters to _you_. Their experiences and needs are not the same experiences and needs that "most" C++ programmers will have. The people that write applications with C++ just get on with it and don't post videos about their work. Why would they? "Look at me, I just used this language as it was intended! Whoot!" Writing enterprise-grade applications is not so much a matter of language, as it is a matter of organizational skills. It has very little to do with puzzle solving, and if it ever comes to that, that puzzle had better be hidden behind a completely opaque interface. For the rest it is mostly a matter of making sure that your shit only interacts with other peoples' shit in a clear, concise, and controlled manner. C++ actually makes that pretty easy. Pop quiz... We're hiring two C++ developers. Let's say one comes in, and demonstrates great passion wrt. r-value references, perfect forwarding, and TMP. He doesn't get hired. Why? Answer: because I don't want to argue about the nature of every function parameter in the whole application for the rest of my career, because I don't want to debug yet another TMP monstrosity, and because I care about compile time and development time _far more_ than I care about saving a few nanoseconds of run time performance. Pop quiz nr. 2... What is the _only_ feature that really excites me in "future C++"? Answer: modules! Anything to keep down compile times, and to stop the flood of unwanted symbols and bl**dy #defines from wreaking unseen havoc (looking at you, X11, with your #define Status ...). Besides, a single import statement instead of two dozen #includes? Sign me up! Co-routines? Meh. Concepts? Yeah, looks vaguely interesting. Reflection? I could probably find a use for that. Uniform call syntax? Please for the love of God, NO! Doesn't anybody here get to debug large systems? Variable-size arrays on the stack? What on earth for... A vector with short vector optimization (similar to short string optimization) seems much more useful. Anyway, just my two cents. Don't give up; use what you know, and slowly expand your knowledge. It's what we all did, after all... 
I would say I have learned the basics. Other than that no, there is so much to master. But I love writing in C++.
It's actually the big 5, not 4, in C++11; you forgot move assignment operators.
&gt; My stance is: one really needs shared_ptr only in multithreaded scenarios Not true. There are cases where there is no clear owner of an object. 
I know this is rather minor but would the addition of a `println` implementation be welcome? I'd rather not have to always add a `\n` when I want to end the line.
Don't worry, if you become a professional C++ dev than after 10 years you will still be confused by the language. Just yesterday I saw some weird c-like syntax for class member function pointers that somehow instantiates a class that appears to save away parameter values like lambdas can do... at those moments you wonder if you truly know anything.
&gt; The context is multiple copies of the exact same program, running on different machines and talking to each other over the wire. why reinvent RPC once again ? this has been a solved problem since 1985. Take a look at [Qt Remote Objects](https://doc-snapshots.qt.io/qt5-5.9/qtremoteobjects-index.html) for a modern approach for instance. 
How many of those have simple integration with Boost.ASIO? How many of those allow for the building of testable components without the overhead of virtual dispatch through the use of templates &amp; concepts?
You are referring to 'function addresses being the same between program executions' - not sure if I fully understand what you're after, thus the solution below might not help you in any way. We successfully use this technique to identify functions across different instances of the code running concurrently in the context of a distributed application. In HPX, we associate an unique type with each function we would like to 'send over the wire' (represent in all instances of the code). This can be achieved by binding the function address as an integral template argument. template &lt;typename F, F ptr&gt; struct A {... use 'ptr' to invoke the function...}; void foo() { ... } typedef A&lt;decltype(&amp;foo), &amp;foo&gt; foo_type; Now `foo_type` can be serialized as usual and used on the other end of the network to invoke `foo`. The same can be done for member functions (see https://stackoverflow.com/questions/15192700/how-to-rewrite-this-to-make-it-conforming-to-the-c-standard for a corresponding solution). 
Let me see: 1. auto: the examples of using auto in the article are pretty good, but I feel auto is overused in general. 2. nullptr: yep - one of the best C++11 features. Don't know a single downside of using it. 3. shared_ptr: nope - I have yet to see a need for that one. unique_ptr, on the other hand is very useful. 4. strongly typed enums: yep - no downsides. 5. static assert: yep - I had used a macro for that, but now that it is a part of the language it is even better. 6. variadic template: nope - I can see how it can be useful for authors of generic libraries, but I don't write them. 7. range-based for-loops: yep 8. initializer lists: nope - there are some dark corners about initializer lists that I don't understand, so I avoid them 9. noexcept: nope - I don't believe in any kind of exception specifications. 10. move: yep, although I am much less enthusiastic about it now that I am actually using it. In practice, it is all but impossible to know when move constructors are invoked. 11. lambda: yep, in moderation. 12. Explicitly defaulted and deleted special member functions: yep, much cleaner than making members private. 13. override: I'd say yep, but it turns out I haven't written a new class hierarchy since C++11 was introduced, which is a good thing. 14. std::thread: nope - never had a chance to use it. 15. Unordered containers: Oh, yes.
 **Company:** [RaySearch Laboratories](https://www.raysearchlabs.com) **Type:** Full time **Description:** RaySearch is a technology company with a difference - our software is a vital weapon in the ongoing battle against cancer. We help save lives through innovative software for radiation therapy, which is one of the most important forms of cancer treatment. Our success has led to rapid growth and we are therefore looking for talented software developers. RaySearch believes in investing in its people. We offer outstanding staff benefits and excellent career development opportunities in a flexible and stimulating environment. We prioritize knowledge-sharing, creativity and collaboration, and you will work together with some of the most talented and highly educated people in the industry. You will work in a modern office environment with access to the latest hardware and tools. We encourage a healthy work-life balance and have created a strong social culture, with regular events and activities for employees. RaySearch is committed to equal opportunities. We value diversity and are dedicated to preventing discrimination. [About RaySearch Laboratories](https://www.raysearchlabs.com/About-RaySearch) **Role** We are continously recruiting skilled C++ developers to join our development department. Our development department is organized in agile teams with physicists, algorithm developers, application developers and test specialists, all dedicated to designing and evolving cutting-edge medical software. Developers generally participate in all steps of the development process, including analysis, architecture, design, implementation and testing. We recruit for full-time positions based at our head office in central Stockholm. **Education &amp; Experience** * MSc in engineering physics, computational science, or similar. * 3-10 years of experience in an academic or industry environment. * Strong programming skills, especially in C++, modern C++ and architecture. * Strong algorithm skills preferably including parallel computations on CPU and/or GPU. * CUDA skills are meriting, but not required. * Specialized knowledge in physics or algorithm development is required for the respective competence groups. * Software development in C#/.NET is meriting. **Location:** Stockholm, Sweden. Fluency in English is required. Fluency in Swedish is a strong advantage. **Remote:** No **Visa Sponsorship:** No **Technologies:** * Parallel algorithms both on CPU and GPU. * CUDA experience very much appreciated (we currently rely on C++Amp). * C++11/C++14, will adopt C++17. * Visual Studio (currently Visual C++ 2017), boost, google test with visual studio integration, ReSharper C++ &amp; C#. * The algorithms are implemented in C++ and the application layers in C#/.NET, under Windows, for Windows. Scripting in Python. **Contact:** To apply, email your letter, CV and transcript of records including course listing with grades to work@raysearchlabs.com, subject "reddit c++". Questions are asked to the same address. During the Swedish summer (July to end of August) expect only limited response. More information and positions, in Stockholm and elsewhere: [RaySearch Laboratories Career and other open positions](https://www.raysearchlabs.com/career), [RaySearch Laboratories at Stack Overflow](https://stackoverflow.com/jobs/companies/raysearch-laboratories). 
Yes, I agree. The best part of C++ is that you can code to overcome the limitations of your system. You need something blazingly fast, then use coding that will enable that but might require a lot of memory to do so. You want to use less memory, then code like that! You can code for lisibility, testability, efficiency, maintenance, scalability, prototyping, etc. All those "goals" requires a different approach of the problem and will result in different code. 
The language evolves, the techniques evolves, the systems evolves, so you'll always have something to learn. Put that aside, you can't master a language in all aspects of it imho. It depends on what purpose you use the language for. The best part of C++ is that you can code to overcome the limitations of your system. You need something blazingly fast, then use coding that will enable that but might require a lot of memory to do so. You want to use less memory, then code like that! You can code for lisibility, testability, efficiency, maintenance, scalability, prototyping, etc. All those "goals" requires a different approach of the problem and will result in different code.
Been writing C++ for games mostly full-time since around 1998. The language is constantly evolving, and there are some dark, dark alleyways of knowledge I've only stumbled down a few times. That said, 99% of the code I maintain is totally understandable, and I've never had the need to write any code that uses/abuses the language too much. But there are definitely engineers out there that like to push the limits, and I look at them in both awe and disgust. :) Also in large codebases there's also plenty of code smells and WTFs... I know because I wrote plenty of them. You learn to not stare at them too hard - everyone has deadlines and bad days. It can be a messy language at times, but you'll pick up good habits as you go along from other engineers and it'll eventually seem less scary. The team you work with has a big influence here, be very weary of teams/engineers that scold others for mistakes. My golden advice is this: confusion is a requirement of programming, so try to be aware of that feeling and turn it into productive curiosity rather than anxiety. Unless lives are at stake, programming is not important enough to lose sleep over, so try and have some fun with it, and stay humble.
`noexcept` is useful for optimizations, and move constructors are guaranteed to be called when returning out of functions (so you can now, e.g., return vectors without worrying about copying the whole thing).
I agree with you in almost everything. However, I find that when it comes to data communications, which is my field, raw pointers and manual memory management are needed.
There are half-a-dozen cases... There, fixed :-)
That's not how TL;DR works. 
Came across a nasty one this week. Apparently if you explicitly delete a move constructor, even though you define a valid copy constructor, it still will call the move constructor, and thus fail because you deleted it. Removing the statement which explicitly deletes it fixes the issue because the compiler won't generate it then. (GCC doesn't work, MSVC does though) Almost pulled my hair out since I didn't use temporary's or anything, so there was no reason to even assume it would call the move constructor.
&gt; noexcept is useful for optimizations I know. It's just that I was never in situation where that kind of optimization was useful on function level. I was in situations (rarely) when I had to disable exceptions on module level. &gt; move constructors are guaranteed to be called when returning out of functions I know the theory. In practice, you get surprised. See "Effective Modern C++", item 29 if you don't trust me. 
&gt;I mentioned this was a project using UE4. It maintains some game-specific alternatives to STL so it turns out there is already a TFunction! It seems quite well done and more importantly has some nice allocator optimisations: it will first use a small buffer like mine (up to 32 bytes) and after that cascade to a more general allocator. For more detail see Function.h in the UE4 public repository. Interesting, I'm certainly not familiar with std::function implementation but couldn't it use a similar optimization?
&gt; and after that that dependent types in template shenanigans need a typename keyword stuck in there, just for fun You managed to avoid learning this for 6-7 years? How?
Interesting, that is similar to what I was looking for.
This deserves more upvotes for its honesty. Every time I think I've mastered everything there is to know about the language I find a new uncharted nook or cranny to explore. True mastery is knowing your weaknesses, and overcoming them.
&gt; it could, but it doesn't It does, but it depends on implementation whether it does, and what size of small buffer is available. "Quality of Implementation." "QoI" is a fairly dirty word in some parts though. I mean, if I have to ship a game in a year on 6 platforms with 3 different compilers/stdlibs, and even one of those lacks the "quality" that I need for a particular feature/type, then I can't just go complain to the compiler vendor to get a better quality of implementation; I have to work around or replace that thing _now_. And there's no reason to be doing all that work and just conditionally doing it for that one platform/compiler when I can do that on all platforms and all compilers and possibly get a little something extra out of it, e.g. a `function` replacement that never ever allocates (which is what I do) _and_ compiles faster and has less call overhead (on account of requiring simplifications like only supporting trivially-destructible function objects, if that's all the project needs).
You realize that member functions defined with their declaration in a class or struct definition are implicitly `inline`, right? &gt;A function defined within a class definition is an inline function. §7.1.2 [dcl.fct.spec]
good point - thanks for giving more context to my one-liner! 
What other clutter? Do you have an example? 
After more than 15 years of using C++, I thought I was an expert. Then I read "Modern C++ Design" and learned how wrong I was!
I'm really annoyed that 5.9.1 is not considered an upgrade to 5.9, but rather a separate installation. If it's a bugfix update, which this seems to be, then let me update directly rather than having to mess with environment variables and go through a time-consume install + uninstall process that includes checking a lot of boxes. The maintenance tool "5.9" package should have an auto update to 5.9.1, and the old version (currently 5.9.0) should become the package that gets installed in a separate directory.
the compiler specific hints are not guaranteed to work either you make some good points - I shall clean up the inlines first chance I get
I must say that I love the simplicity and small size of Beast. Even I, a novice C++ programmer, have been able to get it setup and use it. I only wish that using OpenSSL was easier on Windows (but that isn't Beast's fault). I ended up using a pre-compiled DLL that somebody here on /r/cpp recommended.
as one of the comments says &gt; sounds like “we rushed the update and we don’t trust what we’ve done, so we keep an exit door open” 
too long, did read
[removed]
Is there any way to get coverage information from CATCH tests? I know this depends on the compiler/IDE, not just on CATCH, so I am just asking for info and not blaming probable lack of coverage on CATCH. 
I also do most of my development within Visual Studio but most of what I write is cross platform and gets compiled on clang &amp; GCC as well. Actually as it happens, on Windows CppRestSDK uses WinHTTP APIs for all HTTP communication. See here: https://github.com/Microsoft/cpprestsdk/blob/master/Release/src/http/client/http_client_winhttp.cpp It implements HTTP on top of boost asio for all other platforms. See here: https://github.com/Microsoft/cpprestsdk/blob/master/Release/src/http/client/http_client_asio.cpp There is also a websocket impl that might be relevant.
I played a bit with the code in compiler explorer and it seems like the static_assert checking for the size of "f" is not entirely correct since we're trying to placement new an object of size Impl&lt;Functor&gt; which also has virtual methods.
It wraps [WinHTTP](https://msdn.microsoft.com/en-us/library/windows/desktop/aa382925%28v=vs.85%29.aspx) by default.
It is likely possible to implement routines which translate `beast::http::message` to and from the WinHTTP message representation, and then use native WinHTTP calls to send and receive those messages. Or with a suitable implementation of the *Fields* and *Body* concept, have `message` instances which directly map to WinHTTP objects. So you would be using Beast to interface with high level code that wants to inspect and modify the HTTP message itself, while WinHTTP takes care of the sending and receiving.
I started keeping an eye on Beast since hearing about it at CppCon because it was interesting. Recently, we've decided to start using it in a project (which I can't disclose any details about). It looks to be maintained at a very high standard of quality and especially in the last two months or so, I've been impressed by the kind of changes I've observed in the library.
I thought I knew C++ until I saw an industry code base. I had no idea conditional inheritance was a thing.
&gt; too long, di**e**d read**ing**
Can you use any other library (e.g. BoringSSL)? Or does it have to be OpenSSL?
u/aearphen I noticed that the common case of just using format() causes a memory copy. Have you considered perhaps having a version of Buffer backed by an std::string that can be have its backing std::string moved into the return of format?
OP: READ ALL OF THIS. Read every last bit of it, then read it again. Several more times. This guy/gal is solid gold, and should describe almost EXACTLY how you probably do and probably should feel. iprobablydisagree: THANK YOU! Thank you for spending the time to put C++ (and programming in general) to words. You are clearly an asset to any community, and it's much appreciated!
&gt; since "just inline them anyway" is also not part of the standard Yes, it is: &gt;This International Standard places no requirement on the structure of conforming implementations. In particular, they need not copy or emulate the structure of the abstract machine. Rather, conforming implementations are required to emulate (only) the observable behavior of the abstract machine as explained below. §1.9 [intro.execution] Now I'm sure your counter-argument is going to be that this provides no guarantee around inlining and only permits it (along with a great many other optimizations). You would be absolutely correct, but how is this any different from the effects of the `inline` keyword? Which is why I call this a cargo cult: There's a confusion of cause and effect. Sure, you put `inline` on a function and it was inlined, but did that actually cause it to be inlined or was it just a result of the optimizing compiler's analysis of the program? Sure, you did a particular thing and "*cargo*" arrived on your Pacific island, but did that actually cause it or was it just because the Japanese and United States were fighting a war? &gt;and on *real shipping implementations* `inline` can have the effect of allowing inling where it otherwise would not happen. Which should be considered an issue with the implementation. &gt;I will agree that there *should* be a standard way to force/request/encourage optimization inlining, but there isn't I disagree completely. That would be coupling the implementation to the language. Inlining is something that is done by the compiler so that C++ programs run faster on real computers. C++ is not a language which targets real computers, specifically: &gt;The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine. §1.9 [intro.execution] If there's a standard way to mandate inlining, why not loop unrolling? Tail call elimination? Loop vectorization? Operator strength reduction? Et cetera.
 Additionally, the boost version of std::function also has SBO if you want a reliable implementation that works on multiple platforms.
&gt; boost Why would they want to use a well tested, peer reviewed library, didn't you hear, they're developing a game!
&gt; noexcept: nope - I don't believe in any kind of exception specifications. Well then have fun using `std::vector`.
You never stop discovering features in C++...
I just accepted the fact that I will never fully understand this language. But you know what? That's completely fine. You don't have to know every single type deduction rule, you don't have to know about short string optimizations or copy elision. I mean it's probably useful to know it. Even Bjarne admitted that learning all of C++ rules is probably impossible, because it grows and develops in such a rapid pace 
Why? vector is older than exception specifications.
vector copies your objects if your move constructor isn't `noexcept`.
&gt;If an exception is thrown while inserting a single element at the end and `T` is `CopyInsertable` or `is_nothrow_move_constructible_v&lt;T&gt;` is `true`, there are no effects. Otherwise, if an exception is thrown by the move constructor of a non-`CopyInsertable` `T`, the effects are unspecified. §26.3.11.5 [vector.modifiers] Explained differently: Let's say you have a type `T` which is copyable and movable, but due to your objection to "*any kind of exception specifications*" you have failed to mark your move constructor (which cannot logically throw) `noexcept`. Accordingly you have the following: - Your type satisfies `CopyInsertable` - `is_nothrow_move_constructible_v&lt;T&gt;` for your type is `false` Accordingly `std::vector` will copy elements around inside itself because if it moved the move constructor might throw and then when attempting to roll back another move constructor might throw, thereby violating the strong exception guarantee. If only you'd marked those move operations `noexcept` `std::vector` would happily have moved the objects but...
&gt; Sure, you put inline on a function and it was inlined, but did that actually cause it to be inlined or was it just a result of the optimizing compiler's analysis of the program? It caused it to be inlined according to the implementation-defined semantics of an option to the compiler that enables an analysis that the compiler does not do by default. You can keep putting more and more effort into being condescending but it really isn't doing much to convince me of _anything_ besides how unlikely I am to want to share a beer with you. :) &gt; Which should be considered an issue with the implementation. I consider it a failing of the standard to provide implementations with a better standard-compliant option to meets its users' needs. &gt; If there's a standard way to mandate inlining, why not loop unrolling? Tail call elimination? Loop vectorization? Operator strength reduction? Et cetera. Sign me up. 
Per Meyers' advice, one shouldn't count on move semantics anyway. vector can be used without them just fine.
But is it really worth losing them to uphold an anti-exception-specification dogma? IME, absolutely not.
No, I agree. In fact, default move constructors are noexcept by default, IIRC. The previous poster made it sound as vectors were useless without exception specifications, which is simply funny given that vectors have been used since 1994 or so.
You are arguing what the standard *says* against what actually *happens* in the real world. Moreover, you're arguing against experts in the field, not cargo-cult "expert game developers.". You may be technically correct, but you're still not right.
utf8 on Windows is the most frustrating thing ever. If only setting the code page was enough. Would be neat to have U versions of the API functions like the A and W versions, but then it's almost too late to bother with. Working with wchar and tchar is painful enough. 
I mostly agree. But note that *stdlib* doesn't change the active codepage (to 65001). It would have been a simple solution if it worked, but down at the API level, while it does apparently work for output, it doesn't work for input of non-ASCII characters. So, instead translating buffers are installed in the standard iostreams that are connected to the console. These buffers use Windows' wide (UTF-16) console API, without dragging in `&lt;windows.h&gt;`. And they use an UTF-8 translation that does not get stuck in an error state when it's fed invalid bytes, but instead it then produces a replacement character, specifically ASCII 127 “DEL”. In order to help with the issue of general UTF `char` to `wchar_t` and vice versa conversion the functionality that *stdlib* uses internally is exposed as two public classes, available via `&lt;stdlib/extension/Byte_to_wide_converter.hpp&gt;` and its sibling header. I balked at defining simple wrapper functions on top of that, because that would be *adding* to the functionality of the standard library, on a slippery slope to feature creep. I think that that functionality more properly belongs in some other library that would aim to complement the standard library rather than just fixing things. --- Regarding `tchar` that you mention, it can be necessary to deal with that in legacy code. But it was originally in support for Windows 9x programs, restricted to Windows ANSI. This support became obsolete in the year 2000 with the introduction of Microsoft's Layer for Unicode. And of course, today our tools do not even support creating Windows 9x compatible executables, so the whole thing, the `T` stuff, is an anachronism. Best avoided for new applications, IMHO.
&gt; You are arguing what the standard *says* against what actually *happens* in the real world. Absolutely 100% correct. You should program against what the standard says, and not what actually happens. What the standard says is guaranteed, you can reason about it, you can rely on it, et cetera. What actually happens is ephemeral, prone to implementation details/artifacts, et cetera. The same goes for consuming APIs. You program against the contract laid out in the documentation, not what it actually does in the real world. An example of why this is good: What actually happens when you call `std::memcpy` with overlapping regions of memory? The standard says it's undefined, but what **actually happens**? Maybe it works correctly on all the platforms you test on so you decide it must be good enough, saves you having to memorize [another function](http://en.cppreference.com/w/cpp/string/byte/memmove). But what happens when down the road your implementer decides that an implementation that doesn't handle overlapping areas gracefully is better/faster? [What if this isn't just a made up example but rather something that actually happened?](https://sourceware.org/bugzilla/show_bug.cgi?id=12518) What separates engineers from untrained people building stuff is robustness, forethought, and discipline. You don't build a bridge by stacking up bits of metal, driving a bunch of trucks over it, and then saying "*good enough!*" when it doesn't collapse. You carefully design, calculate, plan, and then execute. When/if this fails you perform an organized, structured analysis so that you (and society-at-large) can learn and improve from your mistakes. Programming against contracts is robust and requires discipline. Slamming code into an editor and seeing what actually happens is lazy and reckless.
&gt;Absolutely 100% correct. You should program against what the standard says, and not what actually happens. What the standard says is guaranteed, you can reason about it, you can rely on it, et cetera. What actually happens is ephemeral, prone to implementation details/artifacts, et cetera. Come down from your ivory tower and join us in the real world. Real engineers are shipping real software and need to make informed decisions about how compilers actually behave.
I'd also replace these virtual calls with direct function calls.
&gt;&gt; You are arguing what the standard *says* against what actually *happens* in the real world. &gt; &gt;Absolutely 100% correct. You should program against what the standard says, and not what actually happens. What the standard says is guaranteed, you can reason about it, you can rely on it, et cetera. If the standard were really guaranteed then implementing against what actually happens would be identical to implementing against the standard. In reality, we sometimes want behavior slightly different from what the standard specifies for practical reasons, and opt to use a compiler flag which our compiler vendor has specified has different behavior than what the standard specifies. When these differences meet our needs better than the standard, we use them instead.
&gt; variadic template: nope - I can see how it can be useful for authors of generic libraries, but I don't write them. Well, it is way simpler to implement some algorithms with variadic templates. Just [see it](https://github.com/thelostt/ccompiler/blob/91a32077551a3cd638ffb36719cb773860c910e1/src/parser.cpp#L164) by yourself.
Performance posts are interesting but it's a shame when they don't contain any tangible results, like a benchmark, or a statement on how much the frame time improved etc. Now it just reads as "I tried using std function but I thought it was slow so I spent time reinventing it." Which for all that we know might just have been a waste of time
I wonder if this book will get a revamp should io2d make it in.
I would not call this "rare" at all, it's quite common to have named constructors (see Named Constructor Idiom). While I agree that a factory method should be made for unique_ptr here, I can see it being annoying to have separate stack and heap methods for each factory method. One thing that can be done (although this is also tedious) is to create a public subclass just for the named constructor. That, or creating a dummy parameter. They are both not really ideal solutions in my opinion, though.
changelog http://code.qt.io/cgit/qt-creator/qt-creator.git/tree/dist/changes-4.3.1.md
qt creator 4.3.x so far for me has been practically unusable for serious work. 4.3.0 crashed randomly at hourly intervals, often losing work as a result. 4.3.1 isn't much better and hangs the machine for minutes on end if a file or files is/are open in creator is/are changed or edited outside creator. also the cursor randomly jumps several lines down when performing some edits that use autocomplete. this makes it infuriating to use.
I doubt io2D would be very good for games. Maybe it would be used for managing a window. But I doubt it.
Or just get a pdf of it ¯\_(ツ)_/¯ 
One motivation behind the thing is to teach beginners and use standard I/O that isn't console-based. Beginners love making games using actual 2D drawing and input. It might not be great for professional games, but it should work fine for beginners trying to learn C++ and use it to make some neat things they can show off.
I have some rough measurements here: https://vittorioromeo.info/index/blog/passing_functions_to_functions.html
Yes and no. There is nothing Catch specific, but you can use the usual suspects of gcov, lcov, etc. If someone writes nice automation script or documentation, it might get included in the main repo.
For the lazy: &gt;General * Fixed that wizards overwrote existing files even when told not to do so (QTCREATORBUG-18284) Editing * Fixed memory leak in code completion (QTCREATORBUG-18326) All Projects * Fixed that links in `Application Output` stopped working after application stops (QTCREATORBUG-18134) * Fixed that `Application Output` was no longer editable (QTCREATORBUG-18418) QMake Projects * Fixed `Add Library` (QTCREATORBUG-18263) CMake Projects * Fixed crash when restoring session with multiple CMake projects (QTCREATORBUG-18258) * Fixed that `test` target was missing (QTCREATORBUG-18323) * Fixed that `STATIC` and `INTERNAL` variables were shown in project configuration * Fixed that CMake `message`s were not shown in `Issues` pane (QTCREATORBUG-18318) * Fixed issues with CMake variables that contain `//` or `#` (QTCREATORBUG-18385) * Fixed that deployment information could contain empty items (QTCREATORBUG-18406) * Fixed that targets were duplicated when importing project (QTCREATORBUG-18409) * Fixed that building application failed first time and after build error when using CMake &lt; 3.7 (QTCREATORBUG-18290, QTCREATORBUG-18382) Qbs Projects * Fixed crash when renaming files (QTCREATORBUG-18440) Autotools Projects * Fixed regressions in project tree (QTCREATORBUG-18371) C++ Support * Fixed crash when requesting refactoring operations on invalid code (QTCREATORBUG-18355) QML Support * Fixed crash when changing kit environment (QTCREATORBUG-18335) Valgrind * Fixed crash when running analyzer for iOS and Android (QTCREATORBUG-18254) Version Control Systems * Fixed filtering of untracked files in commit editor when multiple projects are open * Git * Fixed that ref names were missing for `Show` * Mercurial * Fixed extra options in diff and log (QTCREATORBUG-17987) * Gerrit * Fixed parsing output from Gerrit 2.14 Test Integration * Fixed that changing QML file triggered full rescan for tests (QTCREATORBUG-18315) * Fixed issues with multiple build targets (QTCREATORBUG-17783, QTCREATORBUG-18357) Platform Specific Windows * Fixed checking whether example should be copied to writable location (QTCREATORBUG-18184) * Fixed issues with MSVC2017 and CMake (QTCREATORBUG-17925) macOS * Fixed performance issue on HiDPI displays (QTBUG-61384) WinRT * Fixed running MSVC 2017 based applications (QTCREATORBUG-18288) Android * Fixed detection of MIPS64 toolchains * Fixed that 64-bit ABIs were missing in AVD creation dialog iOS * Fixed running on iOS 10.3 devices (QTCREATORBUG-18380) * Fixed crash that could occur at startup while device is connected (QTCREATORBUG-18226) BareMetal * Fixed crash on shutdown
The purpose of the post is also to reveal how std::function works and highlight a (educational) non heap allocation variant. I cannot reveal exact details due to the nature of the commercial product. Don't forget that in the end I used the game engine equivalent one, not mine. I also try to survey all the alternatives out there: SG14, UE4, changes in C++17 etc
Have to agree, imgui (and nuklear) were a revelation to me in writing responsive UIs.
I work on a product for TV broadcast automation. It came after 2010, It sells to hundred of TV stations around the world. It's windows only. It's successful, commercial software. You've never heard of it. Almost nobody has ever heard of it. My previous job involved working on a static code analyser suite. Some of the software was single platform. It sold to hundred of companies around the world. It's successful, commercial software. You've never heard of it. Almost nobody has ever heard of it. Before that, a single-platform set of software for tracking aircraft with about five customers. Successful, commercial software. Before that (although now we're far back enough that this software came before 2010), a single-platform set of software for tracking tennis balls at tennis matches and judging if they were in or out (this is the only one you might have heard of; it went by the name "Hawkeye"). Successful, commercial software. Before that, embedded software for a particular embedded hardware board for a camera that went on helicopters. Successful, commercial software. There is a fridge in my kitchen running software made for that platform. Successful, commercial software. There's a microwave in there too. Much the same. The car as well. Once you hit embedded software, there is a huge amount of successful, commercial software written for very specific pieces of hardware running specific versions of some niche OS (or running bare metal with no OS at all). Very much not cross platform. &gt; I don't even know any "successful, commercial software" which came after 2010 There is an enormous amount of successful, commercial single-platform software that you (and I) have never heard of (or interact with every day without even noticing), because individual consumers like you and me aren't the target market. 
This "hint" is ignored by most (all?) modern compilers. The only thing `inline` tells the compiler is to bypass the One Definition Rule.
MSVC, GCC and Clang all do. Which compiler do you use?
Instead of reinventing the wheel you should have a look at Malte Skarupke's implementation. You'll find it on probablydance.com
&gt; Absolutely 100% correct. You should program against what the standard says, and not what actually happens. What the standard says is guaranteed, you can reason about it, you can rely on it, et cetera. What actually happens is ephemeral, prone to implementation details/artifacts, et cetera. No. You should accept that *not* programming against the standard has costs. And also, that ignoring the current implemtation of the standard provided by your compiler has costs. You should determine the benefits and costs, and with eyes open decide. UB should only be used when the benefit is large and the educated risk is small. Unspecifieds behaviour more often, when the resulting behaviour is stable accross many compiler versions and the benefit is huge. When you do either, the cost is auditing the result *in every build and compiler upgrade in the future*. This is a large cost, but not infinite. In the case of extra `inline`s, this cost is much reduced. There are basically zero standard mandated differences between struct Bob{ inline void foo(){} void bar(){} }; (Presume they have non-trivial identical bodies). In a sense, your worst case "compiler follows standard strictly" scenario is your `inline` burns nanoseconds of compiler time and is a waste of typing/reading. This is a low cost. The fact your current compiler uses it as an additional hint means there are some benefits. You are communicating something extra to the compiler, in a low risk way. The fact that there are optimization levels where it makes a concrete difference mes these benefits are measurable; the meurable costs are meanwhile tiny, and unmeasurable bounded. 
&gt;the compiler specific hints are not guaranteed to work either I recommend changing the compiler, if the compiler specific hints don't work as advertised. That, or using non-broken hints/attributes.
I have, several times. Each time I was humbled by my own ignorance. And then, C++11 came, and nobody can ever claim they master this. But now I think can use it proficiently up to a point, in certain scenarios.
Japanese cats and blueberry jam smiles upon thee I haven't looked at the code but why is moving the cursor and escape sequences windows 10 only?
&gt; i.e. passing it an integer pointer that does not come from fopen FILE is typically not an integer. But speaking about this... last time i tried wrapping plain open (which does return an integer) in *_ptr it was not easily possible. Is that still the case? Did we finally get unique_resource or whatever in easily accessible places? Like boost or std? Im not looking for solution (problem is trivial). Im looking for an elegant solution.
I forgot to mention, *stdlib* also supports international text i/o via the wide streams. So that you can use `wchar_t` based code for a Windows API oriented program, and be happy. :) For Visual C++ the conventional solution for wide iostreams i/o has been Microsoft's `_setmode` extension, but that's in practice not entirely portable, and it messes up things for the narrow streams. In contrast, the *stdlib* approach of installing buffers is portable: the same code works in *nix-land and Windows.
[removed]
&gt; Remember, things like memory allocation and resource acquisition should be done inside the constructor, protected within a normal try catch block; never in initialization list. Utter nonsense. That would mean you shouldn't do this: struct X { std::unique_ptr&lt;Y&gt; y; X() : y(std::make_unique&lt;Y&gt;()) { } }; Saying you should never allocate in an initialization list is just wrong.
Looking at the chapter list, it ends with polymorphism. I suspect this is inheritance kind of polymorhism, which is good to know but also often a bad idea, in particular in games. I don't know what to think about this. Why does it stop there?
&gt; 1. Since it’s recommended for destructor to not throw any exception, don’t use function try block with destructor. &gt; 2. You can’t return from inside the handler of a function try block. Therefore, it make no sense to use function try block with non-void function. I think I need one or two more sentences to help me understand the reasoning of the first bullet (though I do agree with the conclusion). I don't think the second bullet is correct. &gt; Moreover, using them with [...] constructors without initialization list doesn’t accomplishes anything. This does not seem correct to me, but maybe I am just misunderstanding it.
The book is using `rand()` :-( Could definitely use a "modern C++ overhaul.
&gt; I haven't looked at the code but why is moving the cursor and escape sequences windows 10 only? I don't know about the former, but the Windows terminal simply didn't support ANSI codes until Win10 v1511 (or you had to enable them with a special flag, `/kansicon` or somesuch).
Incredible, thank you very much. :)
&gt;:) I am happy that you are happy. Spread the happiness around. [This doggo demands it.](http://l.yimg.com/os/152/2011/10/31/Untitled-11_172253.jpg)
&gt; does spdlog while doing asynchronous logging parse the input before or after enqueing? u/gabime will correct me if I wrong, but my understanding is that formatting, which includes format string parsing, is done before enqueueing (if that's what you mean by input parsing). &gt; is there an internal structure that can be serialised so that the string parsing and string conversions can be done after deserializing? There is an internal data structure called ArgList which stores references to arguments in a compact way, but it doesn't provide any serialization functionality. It is possible to build serialization/deserialization separately and construct ArgList on the receiving end and I think someone has done this before, but I don't remember the details.
I am not sure if this belongs to the core library because the same can be achieved by adding `\n` with the same amount of typing. However, it's trivial to define your own `println` function as described in https://github.com/fmtlib/fmt/issues/428#issuecomment-262668687.
&gt; But the title of this Item is to assume that move operations are not present, not cheap, and not used. This is typically the case in generic code, e.g., when writing templates, because you don’t know all the types you’re working with. In such circumstances, you must be as conservative about copying objects as you were in C++98—before move semantics existed. This is also the case for “unstable” code, i.e., code where the characteristics of the types being used are subject to relatively frequent modification. &gt;Often, however, you know the types your code uses, and you can rely on their characteristics not changing (e.g., whether they support inexpensive move operations). When that’s the case, **you don’t need to make assumptions. You can simply look up the move support details for the types you’re using.** If those types offer cheap move operations, and if you’re using objects in contexts where those move operations will be invoked, you can safely rely on move semantics to replace copy operations with their less expensive move counterparts. This is from the section you reference (emphasis mine). Also, I'm not really sure what you mean when you say that it's hard to predict if move constructors will be invoked. I haven't found that to be the case, can you give an example?
Yes, I have it on my TODO list as well (https://github.com/fmtlib/fmt/issues/193#issuecomment-150392139) and I hope to get to another round of optimizations soon. Surprisingly, even with extra copy `fmt::format` is nearly as fast as `sprintf`. Note that if you care about performance, the write API can be a better choice.
I mean isn't this book for beginners who just want to learn C++? They can learn the different techniques and the pros and cons later.
I wonder how Threadripper will compare.
SFML would probably be better-suited
Keep in mind that this is compiling Chromium (reportedly fairly long single-threaded link stage) on Windows with VC. Results are quite differen in kernel compilations with GCC. Also, pure speed is not (always) the only deciding factor. There is also power consumption and cost. For example for CI builds Ryzen 1700 looks very interesting.
So you are ok with beginners having class inheritance as the only way to understand polymorphism? That's the main reason we end up with tons of crappy code in companies codebases.
All alternatives to inheritance that I know of are actually simpler and most of the time far more appropriate.
Well for me Ryzen has been a blessing, it's taken my Qt5 qtbase compile down to about 7-8 minutes without ccache and 2-3 minutes from there after a git-pull every few days.
oh jeez calm down
I didn't mean to be alerted or angry, if that's what you perceived, just trying to point that I'm not speaking about advanced C++. I should probably merge these messages.
Threadripper *gives* you time... I'd like to see how well it does as well, looks like a beast, but until those first couple of weeks of bugfixes etc are out of the way and people start being able to use it, it's all hype to me. :)
Thank you. It's not the LOC that I worry about, it's the 'I thought this code was doing this, but I totally forgot that in this one case, this behavior is masked by something else.' Again, thanks, each time I feel overwhelmed, I'll come back to this thread.
Instead of reinventing the wheel, use my reinvented wheel!
Thank you for a great tl;dr. Your post, along with most others in this thread have reminded me that one doesn't just "learn C++", but you use it as a tool. Yes, I do dabble in different programming languages and paradigms and I will continue to do so.
Thank you, that is my takeaway. There are tools for the taking, use what suits your purpose. 
I agree, and I suppose this why doing projects are as important, if not more, than reading/watching a language in theory.
Thank you, that Euclidean quote will stick me for a while. The new stuff does make C++ seem pythonic in many ways, but much more powerful.
Thank you OldWolf2. 
&gt; "I'm going to learn everything about the language! I will learn every aspect and nuance and then and only then can I consider myself a C++ programmer!" and it was an absolute terror to my actual learning. This reflects my thought process as well. Thanks for sharing your experience with learning the language.
That is an interesting thought! I do believe that Modern C++ seems pythonic to some degree.
This is a great analogy. Thanks.
Thank you, having fun is the reason I picked up C++ despite not using it day to day.
Thanks. I could be way off here, but I feel I do use a lot of advanced techniques in Python, that, if I try to find a parallel in C++ require a lot of trickery and complexity.
Thanks, I agree about focusing on the projects.
It's not my reinvented wheel. Also, it's not just reinvented but improved, as he shows in his benchmarks.
Thanks for sharing your experience.
That is a sound point. 
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6knni7/pybind11_and_wxwidgets_c/djnjids/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I still do it on occasion, but not nearly like I used to. I would get to something advanced or complicated, struggle with it for a bit, then decide, "**** IT ALL! START THE BOOK OVER! Obviously you're not getting *something* from before and that's why you don't get *this*!" Now? I don't even care, for the most part. I'm not going to learn the ins-and-outs of everything. If I don't get it? Whatever. Keep moving forward.
True, but it feels like the ratio of known to unknown in C++ is lower than most other languages. Of course, this is a vague statement and just an impression.
Thank you. I have realized that by learning C++ (to whatever level I'm at right now), I have become a better at writing software in Python.
This is the feeling I get. I don't see it in my professional code and I presume it is only because it's mostly Python and that's the nature of it.
Thank you for that perspective. It feels better to think in terms of 'my goal should be to figure out what this code does, or write code that needs to achieve this goal' instead of 'I need to be an expert C++ software engineer.
That is a very healthy way to approach it. Thanks.
Thank you. Those are good points to keep in mind.
That sounds very familiar. I keep going back to some chapters repeatedly.
Does that imply that this book doesn't use any modern C++?
I saw the kernel compilation speed, but that is C. So it is possible that it is not just the link phase benefiting from single core performance(if you see the chart I linked 10 core Intels are much faster than 4 core Intels of similar/faster clock).
I'm also open to suggestions on how to improve version management. There is only so much I can do in my spare time, and so far I was focusing more on functionality and less on compatibility issues, although after rebranding in version 3, I tried to preserve backward compatibility as much as possible while still evolving the library. I've opened an issue on GitHub (https://github.com/fmtlib/fmt/issues/532) and everyone is welcome to contribute to the discussion.
No it doesn't, but that's all I could get from the TOC.
&gt; If the standard were really guaranteed then implementing against what actually happens would be identical to implementing against the standard. This is inaccurate because the standard doesn't specify behavior for each possible input program.
MOOCs?
Online courses..
How does "online MOOC" abbreviation expand into "online course"?
`Massive Open Online Course`, has originated from Coursera and the universities doing their courses in public. 
1800X gets 16.32. The 7820X gets 26.58. Price is $500 versus $600. We knew this right from the Ryzen launch; MSVC has a real problem with Ryzen. Linux compilers do great, MSVC does not. I haven't heard MS address the issue, hopefully they'll make big improvements quickly.
Not arguing io2d would be the best drawing library for learning. What it has going for it is that it would be standard and shipped with compilers. No extra setup for schools/learning materials.
&gt; Linux compilers do great, MSVC does not. do you have benchmarks of large projects on Linux(FFox,Chromium)?
This is overcomplicating things. RAII solves the problem of exceptions in constructors quite nicely. If all your resources are wrapped in RAII owners, then if your init list throws an exception, it doesn't matter because the right thing just happens and any resource already allocated gets freed. Any time you get away from all resources have an RAII owner, you just bring yourself pain.
I started vim and now I can't get out. Please help. I'm typing this from a friend's laptop... 
I looked through many reviews right after Ryzen launched, and yes I found some at the time.
They'll accept different iterator types, but they'll also require different concepts. e.g. copy(Input_iterator b, Sentinal_iterator e, Output_iterator o); 
Without terse syntax, there's no way to specify concepts for generic lamdas. And if they are required to resolve to the same type, no way of allowing different types. At least not without http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0428r1.pdf "Familiar template syntax for generic lambdas"
https://www.phoronix.com/scan.php?page=article&amp;item=ryzen-1800x-linux&amp;num=5 has the Ryzen 7 1800X beating even the i7 5960X when compiling the Linux kernel. http://www.hardware.fr/articles/956-13/compilation-visual-studio-mingw-w64-gcc.html has the Ryzen 7 1800X drawing around even with the i7 5960X when compiling Boost (under both MSVC and MinGW gcc, so it isn't just a compiler difference). Admittedly, neither that large.
Maybe they compiled it with icc.
Please don't learn C++ through a book about a compiler that's 4 years old.
Those games take teams of experts years to create. I think you're underestimating them. Also, VS2017 has a free community edition, so you might as well use that instead of tieing yourself to a specific older version of VS.
In AAA games, due to scope and infrastructure/platform, it's virtual impossible to change the compiler as one wishes; best hope is incremental version updates. These attributes are not broken, is just that by their nature are only hints, ultimately the internal logic of the compiler will be in a better position to judge and make the final call of inline.
I have never come across any in particular. I have found that the best resources are books like - Effective modern C++ by Scott Meyers - The C++ Programming Language by Bjarne Stroustrup are the most helpful resources. There are also a few blogs / video channels and podcast that provide good starting points to expanding my knowledge - CppCast - C++ Weekly - Fluent C++
Thank you. Will check them out. 
\&gt;amd \&gt;surprisingly bad pick one
Yes, RAII and destructors are usually better ways to handle exceptions than the explicit try-catch approach the article focuses on. That's true everywhere, not only in constructors.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6kp3nj/good_c_11_online_moocs/djnzpzy/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6kpemr/pybind11_and_wxwidgets_c/djnzqpn/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Great questions, and very astute of you to notice!!
Which compiler?
im using vc 2017 but that book is the most recent, comprehensive study i know of.
i am using using vc 2017 but that book is the most recent, comprehensive study i know of. open to learning from resources more recent that compare to its comprehensiveness
If you're interested in learning C++ for Game Development maybe you should check out this book: https://twitter.com/GeekDailyDeal/status/881043454758760449
is it really that good or just cheasy as?
My suspicion (and it is only that, a suspicion) is that the existing implementation of SmallVector isn't portable to the DeathStation 9000, but it should be portable to any system used in the last 5 years, including embedded systems.
They really need to fix the project browser for cmake. The autodiscovered header files get placed in a completely different section from the source.
Well obligatory link then: http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list The focus is on the language instead of game development. C++ is a language that doesn't lend itself well to being learned without a resource devoted specifically to it. That is to say, learning C++ through game development might work, but will almost certainly not teach idiomatic C++.
so would learning the dialect of game dev cpp be more benficial to me and then broadening my horizon to the idiomatic or vice versa - narrowing in on game dev cpp?
I'd personally say that if using C++, it works better to have a good, proper understanding of the language (there are so many opportunities for an improper understanding) and then narrow in on domain knowledge without the language getting in the way.
ok thank you is the book i am using ok for that then? good better worse or equal to something like Programming: Principles and Practice Using C++ (2nd Edition), or C++ Primer by Lippman? personal recommendations?
/u/AndrewPardoe, do you know if the MSVC team has looked at compilation times on Ryzen?
Can't say firsthand. I haven't read many myself and I'm unfamiliar with yours.
&gt; Linux kernel. C, not C++ &gt; compiling Boost cant read French but if the just compiled Boost libraries does not seem representative of general work most developers do(Full binary development)
what would you recommend personally brohiem
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Check out [short_alloc](https://howardhinnant.github.io/stack_alloc.html) which provides similar capabilities existing STL classes. 
Both of the ones you mentioned (PPP and C++ Primer) are pretty well-received by the community for beginners. The former is used by the language's creator to teach intro classes.
Here is yous answer "Our new compilation test uses Windows 10 Pro, VS Community 2015.3 with the Win10 SDK to combile a nightly build of Chromium" So they are using VS and obviously MSVC wich is by far the worst compiler of the market so no surprises there, other compilers do as they should do with the CPU and Ryzen it is on the top
[removed]
Your post has been automatically removed because it appears to contain profanity or slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6kptg4/beginning_visual_c_2013/djocccx/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
[removed]
Your post has been automatically removed because it appears to contain profanity or slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6kptg4/beginning_visual_c_2013/djocfq4/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Qt has a similar class: QVarLengthArray http://doc.qt.io/qt-5/qvarlengtharray.html
[removed]
Your post has been automatically removed because it appears to contain profanity or slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6kptg4/beginning_visual_c_2013/djocxia/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
As does [Boost](http://www.boost.org/doc/libs/release/doc/html/container/non_standard_containers.html#container.non_standard_containers.static_vector), and [EASTL](https://github.com/electronicarts/EASTL/blob/master/include/EASTL/fixed_vector.h). :-]
&gt; s like memory allocation and resource acquisition should be done inside the constructor, protected within a normal try catch block; never in initialization list. What if std::make_unique throws a bad alloc when you do it in initialization list? I believe it's not be a good practice to fail the construction of the whole object when we can handle it more safely inside the constructor body. For example A::A() try : B(b), c(n) { try { //Some memory allocation using new, malloc or RAII throws bad alloc } catch(Exception&amp; e) { //attempt recovery for bad alloc. } } catch(Exception&amp; ae) { //function try handler. Will throw anyway. } I'd handle the bad allocs inside the constructor body(probably by setting them to nullptr) and let those members speak for themselves when I use the object, instead of going for the function try block which anyway isn't designed for attempting recovery. 
This seems misguided to me – 99% of the time a class isn't going to know how to deal with an allocation failure, so initialization in the member initializer list is exactly the correct thing to do. Yes, in the occasions where you have a sensible localized fallback for allocation failure you might use `try..catch`, but that is _rare_...
Having seen a few large codebases i can see that being the case, but the moment you start giving hints to the public on how to do stuff, this argument becomes less interesting. Given there are portable AAA games that need to actually deal with multiple compilers, drawing conclusions about C++ programming best practices from just something Visual Studio specific is a little iffy to me. Going back to inline, i dont know how it looks in VC, but gccs \_\_attribute\_\_((always_inline)) has a pretty good chance to actually inline code, to the point where its certainly useful to use it as non-hint. This was my recommendation, if you care about something happening use tools that give you the guarantee. If you are stuck with less then stellar tools then oh well.
&gt; I think I need one or two more sentences to help me understand the reasoning of the first bullet (though I do agree with the conclusion). I don't think the second bullet is correct. 1: It's best practice for destructors to not throw exceptions because it can cause memory leaks. The order of destruction in case of inheritance is from most derived towards the base class. So if an exception is thrown during the process, object would only be partially destroyed. 2: I checked on this and I believe if function try block is used with a function, return is ok. But if used with a constructor it's illegal and compiler gives an error. But IMO, with functions I'd use the try catch inside the body. I'll change the post to reflect this. 3: Function try block serve it's true purpose only when there is a initialization list is available. So for constructors without initialization list, I'd use the try catch inside its body. I hope it clears your points.
Again, they're only using `inline` for development ergonomics, not to affect ODR semantics or the actual release build in any way; they're developing with VC++ and `inline` happens to affect VC++ in a useful way for them, for _debug_ builds. Nobody said "best practices" anywhere that I saw, just "oh that was a matter of habit because \&lt;...\&gt;"
I think solution you outlined is the correct one. The perceived deficiency is probably that its not C++ in that you need to actually write linker script/assembly snippet/attribute.
&gt; unfortunately we had to pull it because of some serious issues Maybe you should test before promoting a tool. I was lucky to avoid this but I imagine I would be pretty pissed if I spent setting it with my workflow only to find out it broke my builds... Or at least fix the bugs of the tools you released.
&gt; vector copies your objects if your move constructor isn't noexcept. Can you remind me again, whose idea was it to allow move constructors to throw? And why?
For me it's been quite useful since it shows which headers you forgot to add to add_library and add_executable
I have seen and built a lot of different solutions around stuff this, but would really wish for some machine parseable document from the CPU/MCU vendors that would allow me to code generate a nice solution with linker scripts, structs, constexpr or inlineable getters/setters and enum class symbols that would allow for entirely compiler checked (no macros is a goal for me) hardware-near programming without it taking weeks to do by hand.
Your post has been automatically removed because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6ksfsv/need_help_with_stdvector_and_classes/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
You can, and it will confuse libstdc++ badly.
How do you "attempt recovery for bad_alloc"? Usually you don't, and letting the exception interrupt construction is exactly what you want. I agree a function try-block is usually not the best approach, but neither is catching the exception. Trying to catch every exception as soon as it is thrown is misguided.
About ten years ago I felt like I had a pretty solid handle on almost all the core language (or at least, knew which bits I couldn't trust myself with and just didn't go there) , and "just" needed to get very familiar with all corners of the STL. Then C++11 came on scene and I've been behind ever since. As I type this, I've got Scott Schurr's talk on introducing constexpr going. One of many, many things on my "C++ things I really should know" list. I generally find that "learning" a language feature comes in two parts; there's the simple mechanics of when it's valid, and there's gaining an actual understanding of it so that when it's the right choice, it flows naturally from my fingers without having to think about it. The first can take a day; the second can take years of experience and failure.
Yeah, this is one of the things I really like about Ada: you can have full control over how types get laid out (like which bits each field uses) and where objects get placed in memory as part of the language without hacks. I wish C++ and other systems languages had this kind of control built into the language as well.
Yeah, maybe that's the typical case then. I don't know. Most of my headers don't end up getting installed and aren't needed as part of a dependency
Reading the article I found that it was about function `try` blocks, not about exceptions in constructors. The author' advice about when to use function `try` blocks is based on considering just one or two use cases that occurred to him. At the end he dismisses any possible use of function `try` blocks for ordinary functions: &gt; [Dismissing ftb for non-`void` function] &gt; * You can’t return from inside the handler of a function try block. Therefore, it make no sense to use function try block with non-void function. &gt; &gt; [Dismissing ftb for `void` functions] &gt; * Moreover, using them with void functions and constructors without initialization list doesn’t accomplishes anything. Better to use normal try{..} catch(){..} block inside the body instead. But, as an example, I once used them for generating call trace information for exceptions. 
They're trying. It's not easy to compete against Intel. Keep in mind: Competition is good for the customer. It's good for all of us if AMD manages to develop and sell some good products.
my point is that there's nothing surprising about amd being bad. 
If I encounter a bad_alloc for any of the member of a class, I'd handle it inside the body(may be setting them to nullptr explicitly). These members which are null will speak for themselves in other portions of the code. This is my approach. And I agree that catching every exception as soon as it's thrown isn't a good idea.
Has the debate about stackless vs stackful coroutines been decided already?
Always wonder how many people use nested bind expressions for their unique behavior on purpose, and how many use them by accident?
If I'm completely honest, the only thing that has held me back from Ada is that it is *so ugly*. On paper, it looks amazing, like everything I ever wanted in a programming language; but looking at the actual code, it's so heavily based on keywords, and not like in Python, where the language is designed to almost read like English prose — Ada just throws them together in a jumbled mess that is hard on the eyes and the fingers. It reminds me distinctly and unpleasantly of COBOL.
What's the purpose of using the std::placeholders in the lambda, as per this example? auto l1 = [ p1 = 2, p2 = n ](auto _1) { return std::invoke(f, p1, p2, _1); }; l1(10); Is there some advantage or use I'm missing? Seems like you could use any old variable name there.
It's not using the placeholder, it's just using the same name. You're right it could be any old name. I assume the author used that name for symmetry with the bind expression.
The TS covers only stackless ones. I think there might be some other papers about for stackfull ones, but this one looks like its going to be in first at the very least. What would the advantage of stackfull ones be? Having played around with these now for a while I'm not sure I see it.
Ahh, right. The employment of the `using` made me think that it was synonymous with the other use of `_1`. Thanks!
&gt; It’s sub-optimal because it has to type-erase No it doesn't – this is why the result type is unutterable. It's sub-optimal because there's a shitload of template machinery that will _likely_ prevent the optimizer from doing as good a job.
Check out [SVD](https://github.com/posborne/cmsis-svd) and [Kvasir](https://github.com/kvasir-io/Kvasir) if you're dealing with ARM micros.
C++ actually has a near-standard solution for hardware access, that goes well beyond the "hardcoded addresses" case. It was included in the draft TR on C++ Performance (the latter can be found on the WG website).
If anyone has the time I would love a partial code review for this library, its my first foray in trying to organize and publish a personal library so its likely somewhat shit... but I haven't found anything 100% similar so I decided to go for it. Just as note, I know there are 1001 other string manipulation libraries out there but they are either very large and with a lot of dependencies (e.g. boost), use their own string type, are no longer maintained or are simply not generic enough (I find myself sometimes needing wstring support for example) or don't have the exact functionality I need. Also, this is far from complete and I am open for suggestions of functionality that can be added and how to implement Unicode uppercase function in a reasonable fashion.
Stackless is.. well, problematic because it divides the world into resumable and non-resumable functions, akin const dividing the world into const and non-const methods. This post nicely summarizes the issues with the stackless approach, note in particular the 3rd point in the top-most post by Gajewski: https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/LA8gxi73XYw There's also a longer paper criticizing the stackless approach, submitted to the committee; it's available among the working papers but I'm unable to find it quickly right now. The arguments convinced me that the stackful approach would be the "right" way to go.
Did you leave some *stdout* debug statements in?... #ifdef RESERVER_SPACE_OPTIMIZATION std::cout &lt;&lt; "\n\n\n\n\n\nOOOOOOOOOOOO\n\n\n\n\n"; holder.reserve(2*container.begin()-&gt;size()*container.size()); #endif 
[removed]
I'm planning on covering some of this when I get to combining generators (due in a couple of posts time). For me I think I'm OK with them being infectious in that way, because it also allows the coroutines to be extremely cheap -- this is important for some of the things we want to do with them. I do get the infectious nature in point 3. Point 4 is of course completely wrong (as I show even in this first part of the tutorial). Writing a generator is also actually very simple, although the machinery is a bit harder (but of course completely re-usable). A user of a library provided generator class would just write the obvious code that `co_yield`s the values. The problem with stackfull is the amount of stack space needed. Not a problem on 64 bit systems, but surely a problem elsewhere. I expect though that there would be use cases for both, and maybe there is away to do both through some suitable extensions to the machinery my tutorials are about.
Yes, my bad, fixed. Thank you for spotting it.
&gt; that will likely prevent the optimizer from doing as good a job more importantly (to me), it prevents good diagnostics. Last time I used `std::bind`, I failed to make clang produce any helpful messages, and I failed to stop gcc from printing several hundred lines of messages.
&gt; For almost all cases, std::bind should be replaced by a lambda expression. It’s idiomatic, and results in better code. In what way is the code "better"? The bind is shorter and more straightforward. And being "idiomatic" doesn't seem like it should be more important than being concise.
[removed]
Your post has been automatically removed because it appears to contain profanity or slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6kptg4/beginning_visual_c_2013/djoriyl/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Author, here. Yes, you're right. I was thinking of the std::function that usually ends up holding the result of std::bind. In my codebase at work we've got a non-std::bind that works in '98, so no auto available. Hoping someday Oracle and IBM release modern compilers that work on all of the codebase. 
Yes, trying to make the replacement as mechanical as possible. 
[removed]
Your post has been automatically removed because it appears to contain profanity or slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6kptg4/beginning_visual_c_2013/djossno/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
How does this compare to SPI python strings?
For anyone else who doesn't immediately recognize the acronym, "[Substitution Failure Is Not An Error](https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error)".
It will compile faster and make smaller code in debug and release, smaller debug symbols, provide better compiler errors, is easier to locate in code databases (it's an actual call and not a function reference). Std::bind supports extra arguments too that will be copied in the object (for example to hold a reference) and changing the function signature can result in silent errors. A lambda is expressing the intent directly and will fail to compile then, which is good when you have to update all the call sites! 
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
It is also possible to write some code for clang-tidy to do that automatically. I had a prototype I worked on at a LLVM hackathon once. 
[removed]
[removed]
How often did you hit reply for that message? I have around five screens filled with it. 
I don't have a problem with long-winded error messages. In fact, the stack trace is often very useful to know where a type gets transformed into something unexpected, such as adding a cv-qualifier to a T. I just wish compilers would always report the instantiation point first, and then print a stack trace, since 90% of problems are on the call site. gcc seems to usually have a "required from here" first, but both clang and cl show the line on which the error occurs first, followed by a stack trace and/or a list of candidates. I also wish compilers could have a richer kind of output (json?) that could have hierarchical information, which could be better displayed by IDEs: there's an error on this call site, expand to see the stack trace, expand to see candidates, etc.
40 times? It seems more likely to be a bug in the poster's Reddit app or something...
For this I agree with you. If there were a way to output the whole thing in a specific format, IDEs could really show where errors happened and why in a pleasing way. At this point, maybe a compile-time debugger is needed!
Ahm... link please ? I am unaware of the library you are talking about :S
&gt;&gt; Maybe you should test before promoting a tool. Thanks for the suggestion. Even with testing it's possible to produce software with bugs and/or design flaws. &gt;&gt; I was lucky to avoid this Had you even heard about this tool before your saw this thread on Reddit? &gt;&gt; if I spent setting it with my workflow only to find out it broke my builds As I understand it, the tool was published on [VS Gallery],(https://visualstudiogallery.msdn.microsoft.com/), not included in Visual Studio. There are some very good tools on VS Gallery, but they are not endorsed or supported at the same level as features released in VS. &gt;&gt; Or at least fix the bugs of the tools you released. Are there particular bugs that you need addressed in our tools? Or are you just commenting because you see an opportunity to criticize? 
You really need to update whichever app you're using. You are posting the same response over and over again.
It's still there...did you forget to `git push`?
A lot of really cool techniques to help improve diagnostics in compilers(especially compilers like gcc and msvc which could use a lot of improvement). I actually wrote a blog [here](http://pfultz2.com/blog/2015/01/31/improving-error-messages/) about improving error reporting in a long chain of function calls, and some solutions. These techniques seem very interesting as another approach to improve errors, and maybe can be used to improve the technique I presented even further, especially since the final solution for even better reporting is [improvements](http://pfultz2.com/blog/2015/02/27/error-messages/) to the compiler(which clang as yet to integrate [D8309](https://reviews.llvm.org/D8309)). You can also add string literals to `enable_if` as well to add messages to failed overloads: template&lt;class T, class=typename std::enable_if&lt; (std::is_integral&lt;T&gt;{} &amp;&amp; "This type cannnot be added") &gt;::type&gt; T add(T x, T y) { return x + y; } Which clang produces this error: enable_if_message.cpp:16:5: error: no matching function for call to 'add' add(foo{}, foo{}); ^~~ enable_if_message.cpp:8:5: note: candidate template ignored: disabled by 'enable_if' [with T = foo] (std::is_integral&lt;T&gt;{} &amp;&amp; "This type cannnot be added") ^ 1 error generated. However, this doesn't work on gcc.
You asked for a code review, so here's a few things: ### Template template parameters and default arguments ### You have this: template &lt; template&lt;class...&gt; class Container = std::vector, class String&gt; String join_container( const Container&lt;String&gt;&amp; container, const black_magic::dont_deduce_t&lt;String&gt;&amp; join_with) { // ... This compiles on clang and gcc, but not on Visual C++. The problem is whether `Container&lt;String&gt;` should use `Container`'s default parameters. In the case of `std::vector`, that would be the allocator. There's a [CWG issue for this](http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#150), ~~which hasn't been resolved yet, afaik~~ [which has been resolved in 2016](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0522r0.html) and is in the latest C++17 draft. There's also [a couple](https://stackoverflow.com/a/23121197/4885801) of [questions](https://stackoverflow.com/a/13738472/4885801) on SO about this. You probably should rewrite this, perhaps something like this: template &lt;class Container, class Join&gt; auto join_container( const Container&amp; container, const Join&amp; join_with) { using String = typename Container::value_type; // ... Note that I removed the useless default `std::vector` since it can always be deduced from the parameter. ### Non-descriptive names ### You have this: namespace black_magic { While it sounds funny, there's nothing magical about a non-deduced context. If you want it to be internal, the convention is a `details` namespace, or something similar. You also copied the code from [this answer on SO](https://stackoverflow.com/a/44834741/4885801), so you probably want to put the URL as a comment for attribution (be nice) and for future reference. ### Text is hard ### There's a couple of mentions here and there that show you're uncomfortable with strings and encodings in general: to_lowercase_ASCII to_uppercase_ASCII //How do these two work with non Latin/Greek characters ? //Doesn't work for greek, cyrillic... etc :/ (Yet) This makes your library unusable for me. ### noexcept ### template &lt;class String&gt; String to_lowercase_ASCII(const String&amp; original) noexcept { String the_copy = original; Copying strings typically requires memory allocation, which may throw. In this case, it would call `std::terminate()`. ## `ifdef`s ## What is this supposed to do? String purge{}; #ifdef RESERVER_SPACE_OPTIMIZATION purge.reserve(i); #endif purge.reserve(i * pattern.size()); ### Warnings ### When compiled with whatever `all` switch, there's a lot of mismatches between signs, mostly with your `for (auto i=0; ...` where you compare an `int` and a `std::size_t`. This tells me you're not compiling your code with the highest warning level possible. ### Code formatting ### Inconsistent spacing: #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include&lt;iostream&gt; #include &lt;type_traits&gt; #include&lt;cctype&gt; template &lt;template&lt;class...&gt;class Container = std::vector, class String&gt; Redundant brackets for default-constructed objects: Container&lt;String&gt; parts{}; String holder{}; Also, typos. Typos everywhere.
Is there any hope of getting basic string manipulation operations in the standard library? If I had a sterling pound for every buggy hand-rolled split operation I've seen in the wild...
GCC 7.1 currently
This is actually pretty cool. Your blog post also cover some interesting techniques too. Thanks!
On the topic of `noexcept`, some people consider OOM to be a non-recoverable error where terminating is a sensible thing to do. That's not to say the app couldn't shut down more nicely when this happens, not to mention that any app that does want non-terminating behaviour is now locked out of using this algorithm.
Ok, I do have a few questions, if you ever have the time to answer, will try to formulate them. As far as credit for the non-deduceable context trick I added it right now. I sort of assume it is a common pattern and adding 'credit' for it would be like adding 'credit' for pimpl. If it isn't than I've made a terrible mistake and now it is corrected.
[removed]
Your post has been automatically removed because it appears to contain profanity or slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6kptg4/beginning_visual_c_2013/djoznqd/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; I do have a few questions, if you ever have the time to answer Shoot, I'll see what I can do. &gt; I sort of assume it is a common pattern and adding 'credit' for it would be like adding 'credit' for pimpl. Creating a non-deduced context is a (not-so-common) pattern, but there's a variety of ways to do it. You're attributing the specific piece of code that you're using. It's probably fair-use, and so not necessary, but like I said, attribution is always nice and it might help someone else (or you in 6 months) to understand what's going on.
It happens sometimes if you have a bad internet connection
Why is the existence of an an automatic fixit required to deprecate it?Even if the approach is manual, it should be fine? Deprecating it for C++20(ish) and removing it in C++23(ish) means that there's a long time to do manual fixes for those who actually do nested bind expressions ...
Is there a way to upvote this comment twice?
You can gild it. It's the same thing, right?
https://github.com/imageworks/pystring
Ok, so, I added some safer compilation option and removed the undefined signed-unsigned comparison behavior. My questions were answered by re-reading your comments except for one: Why is it that you think the signature of 'join_container' should be : template &lt;class Container, class Join&gt; auto join_container( const Container&amp; container, const Join&amp; join_with) { using String = typename Container::value_type; My reasoning there was that whatever type is inside "Container" should be the type people are joining with, if there's no cast from the type of "join_with" to 'typename Container::value_type' the compilation will fail anyway, so what's the difference here ? &gt;There's a couple of mentions here and there that show you're uncomfortable with strings and encodings in general: Yes, I am indeed clueless as to how encoding works, up until a few months ago I didn't even understand the difference between UTF-8/16/32 and the fact that they are all meant to represent the same Unicode standard. I actually realized how clueless I am when trying to implement a to upper implementation that supports unicode for wstring only to realize that towupper doesn't support anything but ASCII and that toupper seems to have the same effect. I'm also not very clear on how setting locales affects the toupper/tolower operations and how I should go about the whole: -&gt; Specify encoding -&gt; Find function specifically designed to work with chracter[s] that are meant to represent said encoding In a way that is compatible with Unicode (even with UTF-8 only would be enough, since that means it can be the exact same code for ASCII strings and most of the time people seem to prefer UTF_8, especially on linux/bsd) ...I've added a large warning and will try to better implement uppercasing and lowercasing (and a character-wise count) in the following weeks/months, it seems to me that there are little "For dummies" resources on the subject and most papers/articles are quite old, meaning I have to harbor some prior knowledge to discern the relevant from the outdated :/ Overall, this library was meant from stopping me to write the same boilerplate over and over, I may have hurried a bit too much when it comes to publishing it. I put it all together last night and I should have probably aimed for a higher quality of code before asking for reviews.... I will try and improve it over the next few days/weeks/ &gt; Template template parameters and default arguments As far as I see there's no windows-compatible way of achieving the same effect without placing more responsibility on the user, maybe I need to search more, I'm generally speaking bad at templates :/... if there is one I shall implement it, otherwise, I'm unsure what to do. Also, once, again, thank you for your advice.
Your package manager for deployment (apt on debian, nuget on windows). Cmake for development
IDEs have a lot of potential here. I'd really like to improve template error messages in both MSVC (command-line compiler toolset) and Visual C++ (MSVC in the VS IDE.) See, for example, the rich visualization provided by our C++ Code Analysis tool: [PRE*f*ast finding uninitalized memory](http://imgur.com/gallery/JIH5O). This would be an amazing feature with template errors and SFINAE.
I also found this https://conan.io/. However, a package I'm looking for doesn't exist on NuGet, nor does it exist in Conan.
Oh... I actually never knew about this :/ At first glance is seems to lacks the functionality I'm most curios about (Unicode compatible upercasing and lowercasing. It also doesn't work with anything other than std::string (though that could be easily changed)... making it a bit annoying to use for me since my work often involves me juggling with std::string std::wstring and QString. It seems to have more functionality though most of it is seems a bit redundant (then again, mine has some redundant functions which are just convenience wrappers as well). I will take a thorougher look at it tomorrow and see what ideas and code I can steal from it, thank you for pointing it out :)
[removed]
Your post has been automatically removed because it appears to contain profanity or slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6kptg4/beginning_visual_c_2013/djp26jn/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Wonder if one could use GitHub Desktop for GitHub hosted libraries?
I've manually removed the duplicate posts (thanks for not replying to multiple copies). Wow that took forever.
Author here. Just to point out, this compile test (using the suggested guidelines from Google on a Windows compile, then migrated into an unupdated environment and a clean build for each CPU) seems to enjoy L3 cache a lot. So even though double the L2 cache on Zen, or 4x the L2 cache on Skylake-X, because the L3 in both cases is now a victim cache, IPC goes down. So it's not a direct result of single threaded IPC as much as it is relying on data in deeper caches. See this link for a compare from Skylake-S to Skylake-SP with the different L2/L3 cache arrangements but held at same freq/core counts. http://www.anandtech.com/show/11550/the-intel-skylakex-review-core-i9-7900x-i7-7820x-and-i7-7800x-tested/16
Why assume that a container is a template at all? Imagine I have non-template `MyText` which is a collection of lines, and defines `MyText::value_type` as a `std::string`. Why prohibit using the algorithm with this type?
Please, make sure you format code properly. Code blocks should be indented by four spaces, inline code should be between backticks (\`like this\`). &gt; removed the undefined signed-unsigned comparison behavior. The changes are not much better: for(int64_t i = 1; i &gt;= 0 &amp;&amp; size_t(i) &lt;= original.size(); i++) { This should be for (typename String::size_type i=1; i&lt;original.size(); ++i) You could use `std::size_t`, but I know some string types (like [QString](http://doc.qt.io/qt-5/qstring.html)) that use `int`. &gt; My reasoning there was that whatever type is inside "Container" should be the type people are joining with What about: std::vector&lt;std::string&gt; v; join_container(v, "glue"); This would construct a temporary `std::string` for no reason. However, the original reason for my change was because I changed `Container` to be a regular template parameter instead of a template template parameter (so it could compile on Visual C++), losing easy access to `String`. I guess you could go with template &lt;class Container&gt; auto join_container( const Container&amp; container, const typename Container::value_type&amp; join_with) but what's the point? Just make `join_with` generic and be done with it. &gt; towupper doesn't support anything but ASCII and that toupper seems to have the same effect. This doesn't make much sense. `towupper` works with wide-characters, which are platform-specific (32-bit and 16-bit are popular). They're meant to work with encodings _other_ than ASCII. Honestly, I'd stay away from `wchar_t` in general for anything cross-platform, use UTF-8 internally and convert to whatever your platform uses when needed. &gt; try to better implement uppercasing and lowercasing (and a character-wise count) You realize there are people who have been working for decades on libraries to handle this sort of stuff? This is not something you'll do in a week-end. Localization is _hard_. As an example, `ß` in German doesn't necessarily have an uppercase equivalent, but can sometimes be changed to `SS` depending on context. I think you should decide whether you want a library that does _string processing_ (splitting, joining, replacing, etc.), _localization_ (case conversion, etc.) or _encoding-specific processing_ (code point count instead of bytes, encoding conversions, etc.). You seem to be conflating the three. String processing is a good exercise for novices, but the other two are a minefield. I would strongly advise against trying to roll your own, even as an exercise.
I often find I need libraries that package managers don't provide and I don't want to add a package manager as another dependency. So I use Git submodules (Basically allows for a repo inside another repo.) to add the dependencies to the project. I than add the new folders to my project using add_subdirectory in my CMakeLists.txt. I use git anyway so this is a perfect solution for me. This way the dependencies build when I build my own project and with the same compiler. I can even save all the .lib files to a specific folder for easy linking. (The dependency needs to use git and CMake for this of course)
How come no one ever mentions Nix around here? I feel like this is a part of a big plot where some shady figures are trying to keep C++ developers unproductive. Nix is AMAZING!!!!! especially for C/C++ development. If you're targeting Linux only then just go headfirst into nix, no exceptions. If you're targeting MacOS and Windows as well, then evaluate whether Nix might be your silver bullet. 
Well, for now I'm not doing anything as far as the encoding specific processing aside, the only two functions that are about encoding are clearly marked as being only ASCII compatible by the name. Also, yes, the way I handled the loop iterator there was bad (much better to just cast it to signed when needed) and I did implement your version of join container in order to be msvc compatible (hopefully..., I don't actually have any of the miscorsoft toolkit on hand to test this). I will try and find a way to make split work like this as well... maybe just have a mutable version that passes the container by reference and be done with it.
Hmh... that is a valid point, the revised implementation fixes that as well, so now it should be useable with non-template containers.
&gt; easier to locate in code databases (it's an actual call and not a function reference) Indexers handle that.
Bind looks better in functional code: there are no these repetitions of everything. I wish it was more strict about the number of parameters somehow if possible.
There's a balance. I started writing a function that could give me all the permutations of a std::vector&lt;bool&gt;. Upon a quick google search, turns out &lt;algorithm&gt; has a function called next_permutation() that does exactly that. Saved me a whole hour of work.
It is really great as a dependency manager, but its central repository has very little libraries right now. You can easily create your own package, though.
Can you elaborate, or point to a tutorial/website/whatever that explains how nix is making you more productive?
Looks like [`reviews.llvm.org`](https://reviews.llvm.org/) is currently down. 
Even Microsoft says to use vcpkg instead of nuget - https://github.com/Microsoft/vcpkg/blob/master/docs/about/faq.md#why-not-nuget Also vcpkg covers only MSVC compiler, for GCC I recommend Msys2 - http://www.msys2.org/
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [Microsoft/vcpkg/.../**faq.md#why-not-nuget** (master → 144d371)](https://github.com/Microsoft/vcpkg/blob/144d3718c4197b101c7d61ee6a258200371fb1ab/docs/about/faq.md#why-not-nuget) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djp5p3m.)^.
The official site says it only supports Linux and Mac - https://nixos.org/nixpkgs/ Also I don't see a list of packages anywhere.
Oracle,has,a,c++ compiler?
Nm, I'm stupid. Solaris. :/
Omg. No feedback from the app at all, I had no idea.
Just using the website actually. You press "Send" and nothing happens. Bad design!
I still saw them though and removed them now. The mobile webapp is horrible. The connection was fine since the message was sent, but no feedback at all. Sorry about that!
The problem with indexers is that well will say that a reference has been made to the function, not that it's been called.
This is the top-level comment for **meta** discussion. Reply here if you have questions or concerns about this post.
A very good writeup. I'd recommend changes to the CMake invocation section though. Given that the `-H.` and `-BBuild` flags to CMake to represent the source and build dirs are internal and undocumented, and on top of it all that `-H` (no period) means something completely different, I would recommend making the build directory creation and use explicit. So instead of: $ cmake -H. -BBuild Do $ mkdir build ; cd build ; cmake ../ There are the normal (and more importantly, idiomatic) shell tricks you can use if not changing directories is important for this.
It can cross-compile to Windows but I have not found any clear explanation about how to cross compile existing package to Windows. Packages are here: https://github.com/NixOS/nixpkgs/tree/master/pkgs
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [NixOS/nixpkgs/.../**pkgs** (master → c5e314d)](https://github.com/NixOS/nixpkgs/tree/c5e314dabe45142d4790cdc9169438ba6e133ec5/pkgs) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djp7u80.)^.
I'm not a native speaker but isn't "C++ is most active than ever" wrong ? Most can't be used in a comparison. In the case of a comparison more is used Sorry if it's unrelated to the subject 
If you are working alone or you have small team and also you have the source code to the libraries then git sub modules are the best. As soon as your team starts to grow it gets harder to maintain all libraries and figure out who changed what in which library and for what reason. I have been using Conan for a few months now and it is absolutely great and easy to use. You don't even need to setup a server, you can export all libraries to your local cache and you can use the local cache for all your local projects. If you want to share the libraries with other team members starting the server is also very very simple. 
Yeah, *more* would be better than *most*. It's a good overview of all the tools you can use for a C++ project though. I'm going to try this Travis CI recipe.
Explicit instantiations are rarely useful, so I wouldn't bother to explain them to beginners. Explicit template arguments are sometimes necessary, but should be avoided when possible; I wouldn't introduce them immediately to beginners. &gt; Also, take some advice that will make your life simpler: Implement your entire template classes inlined within the class itself. The member function declarations become much simpler to work with, as you don't have to repeatedly define the correct template declaration of the host class. This advice is presented without actually depicting any class templates, much less class templates with out-of-line member function definitions. &gt; Types include all of the fundamental-types in C++, int, char, short, long, float, and double. Types also include classes and even template definitions. Valid template types does not include pointers. Therefore, things like `char*`, are not valid. What?!? This is profoundly incorrect, or so unclear that I can't understand what it's saying. &gt; Here is a common example that calculates the value of factorial: I dislike these examples because they are not useful or realistic. &gt; This is because functions are not executed at compile-time. The constexpr New World Order changes this. &gt; Template-Template Parameters is the C++ version of movie Inception. People can go without learning about template template-parameters (note hyphen location) for years. Don't bother explaining them to beginners. &gt; We will now encapsulate our byte-order conversion logic within a member function of a partially-specialized struct. Tag dispatch or C++17 `if constexpr` are superior solutions, usually.
FYI, you're shadowbanned. I've approved this comment, but you'll need to talk to a reddit admin in order to lift your shadowban. (Mere subreddit mods like me can't do anything about shadowbans, or tell you why they were applied.)
disagree, mkdir and cd are linux specific - relying on cmake features as much as possible gives you better cross platform compatibility
I love short_alloc, but it doesn't provide this capability; it's stack arenas provides no means to limit the stack allocation a given container consumes. It's a real bummer when you start making short allocations on the heap because a few large containers consumed the majority of the arena early on in execution. 
Thanks Gaby, that's a more compelling example. Although I don't know why: Mergeable{In1,In2,Out} Out merge(In1, In1, In2, In2, Out); is compared to: template&lt; Input_iterator In1, Input_iterator In2, Output_iterator Out&gt; requires Equality_comparable&lt;Value_type&lt;In1&gt;, Value_type&lt;In2&gt;&gt; &amp;&amp; Assignable&lt;Value_type&lt;Out&gt;,Value_type&lt;In1&gt;&gt; &amp;&amp; Assignable&lt;Value_type&lt;Out&gt;,Value_type&lt;In2&gt;&gt; Out merge(In1, In1, In2, In2, Out); instead of: template&lt;class In1, class In2, class Out&gt; requires Mergeable&lt;In1, In2, Out&gt; Out merge(In1, In1, In2, In2, Out); It *is* quite a bit shorter, and it is admittedly redundant to have to repeat the 3 template types immediately, but... is it worth introducing a new syntax just for this case? This seems so... specific, having (a) multiple template parameters, (b) interrelated and sufficiently constrained with a single concept, and (c) no other template parameters. Is this a sufficiently common case to necessitate a 4th template introduction syntax? template &lt;class T&gt; requires Sortable&lt;T&gt; void sort(T&amp; ); template &lt;Sortable T&gt; void sort(T&amp; ); Sortable{T} void sort(T&amp; ); void sort(Sortable&amp; );
Is [this] (https://github.com/fffaraz/awesome-cpp) what you're thinking of?
You can also check [here](https://cppan.org/). Cppan is under heavy development now, in a few months it will be stabilized for production use.
Please, check [here](https://cppan.org/) ([crosscomment](https://www.reddit.com/r/cpp/comments/6kw5xf/looking_for_a_certain_c_libraries_website/djpc066/)).
Just barely. Although they're in somewhat better shape than IBM/AIX. 
Actually, I don't know of a platform that doesn't support mkdir and cd (though I'm sure there is one); linux, Windows, OS X all support both.
The committee has been fairly conservative about breaking working code. If it's not automate-able, it's hard to do on a few 10s or 100s of millions of lines of code. Changing compilers is already hard. This is a good paper, in the latest mailing, summarizing what the current thinking on making changes is: [C++ Stability, Velocity, and Deployment Plans] (http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0684r0.pdf)
What part of internal, undocumented and unsupported don't you understand? &gt; disagree, mkdir and cd are linux specific What modern variant of Unix or Windows, or even any variant, does not support "mkdir" and "cd"? &gt; relying on cmake features as much as possible gives you better cross platform compatibility There are plenty of other ways to invoke CMake, e.g. cmake-gui and ccmake. If you are desperate for command-line, cross-platform compatibility, there are also the fully documented and supported ```cmake -E``` commands, e.g. ```make_directory``` and ```chdir```.
&gt; relying on cmake features as much as possible If and when the CMake devs document it, you can rely on it as a "feature". Right now, it doesn't even exist, at least according to the CMake devs themselves. It's completely an accident that it happens to work today.
Relying on building in a specific directory makes me shudder; there's usually no need for that. Can't we just `./cmake &amp;&amp; make` ?
&gt; There's a CWG issue for this, which hasn't been resolved yet, afaik. I'm pretty sure it was, [P0522R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0522r0.html).
In source builds are usually a quick way to a bad place. 
No one shall expand The Acronym! Edit: before /u/STL can clarify for me, this is a joke. The user was not shadowbanned for this comment. 
Thanks! I edited that in.
[removed]
Your post has been automatically removed because it appears to contain profanity or slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6kptg4/beginning_visual_c_2013/djplcpi/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
[removed]
Your post has been automatically removed because it appears to contain profanity or slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6kptg4/beginning_visual_c_2013/djplns5/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
[removed]
Your post has been automatically removed because it appears to contain profanity or slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6kptg4/beginning_visual_c_2013/djpm22r/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
[removed]
Your post has been automatically removed because it appears to contain profanity or slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6kptg4/beginning_visual_c_2013/djpnjyf/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
[removed]
Your post has been automatically removed because it appears to contain profanity or slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6kptg4/beginning_visual_c_2013/djpnkct/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; DeathStation 9000 Why haven't I heard this term before? :) 
That's...awesome. I wonder if anyone would be interested in standardizing this.
fixed, thanks!
I agree that is more idiomatic in that way but I was targeting simplicity, I like the concept that cmake can make the build directory for you, even been a non documented feature
There's [`constexpr_trace`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0596r0.html). (Not quite the same, but really close. The OP should contact Daveed about that.)
Welcome to the /u/STL review process. It's worth its weight in gold. Hot, molten gold that sears oh just a little bit, but pure gold nonetheless. 
I will. Indeed I think my solution is nicer as the use of a statement implies compiler magic better than a standard library function, and it also supports typenames and template names etc.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6kw5xf/looking_for_a_certain_c_libraries_website/djppvq1/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Care to explain how its buvvy rather than just being snarky about it ?
I have two problems with stackful coroutines: they require OS support to implement properly that may not be there, and unlike stackless coroutines, I can already implement them myself relatively easily. You can't switch stacks on a modern OS without API support since there are dependencies in the OS on the location of the stack and thread context, and doing so correctly requires more than just swapping CPU registers. I have seen popular libraries attempt to allocate and switch their own stacks and this invariably leads to stability and compatibility problems. On Windows, this can lead to Structured Exception Handling (SEH) failures and functions like OutputDebugString() and GetTimeZoneInformation() crashing. In that case, the fiber APIs can be used, but on a platform without such support it would be impossible to implement a stackful coroutine facility safely. I have heard that some platforms have deprecated or even disabled makecontext/setcontext() style calls, particularly iOS. Emulation by threads leads to problems with resources that have thread affinity. Stackless coroutines, on the other hand, do not require OS support as they are a control flow transformation. When the OS support does exist, it's relatively easy to wrap the OS primitives and language/runtime support is generally not required. I can implement or get a library for stackful, but the available ways to emulate stackless using fake control structures or preprocessor witchcraft are all really lacking. 
Why static_print("fibonacci(", i, ")"); prints &lt;int 9&gt; instead of fibonacci(9) ?
Awesome! I really need a compile-time debugger or something... It's seems HS's metaclass proposal has something called compiler.error()?
It doesn't, it was a mistake in the example. Fixed it - thanks! 
You raise a good point, in that the bar for any new C++ compiler today is already very high and adding to the standard library will only make it higher. But ultimately the compiler is not a goal on itself, it is there to support a much, much larger programming community. And all those people will be helped by having a powerful standard library. One possible way out of this is to have reference implementations of system-independent components. These could be included by compiler vendors, possibly with changes to match their specific needs. I have no idea if this is how things defacto already work today, or if standard libraries get written pretty much from scratch, though... Would be interesting to hear.
Some of the code of the standard library is already plataform dependent so i dont think it is a problem at all Besides, a proposal doesnt mean anything, many proposals had been dropped
@"not included in Visual Studio" It was promoted on C9. @"Are there particular bugs that you need addressed in our tools" Recently my intellisense coloring of text went crazy but it got fixed by itself... I guess it is impossible to report this kind of bug now it got fixed and I did not make a screenshot but if you have some way of adding monitoring for your internal MSFT usage you will probably catch it since my project was quite plain. Sorry for no screenshot, did not care enough to make one and report bug. In general problem is slowness of VS(for example I recently added a blank header in project and some progress bar crap was on my screen for seconds), but I guess this is a known problem that is hard to fix. Like everybody knows Firefox is slow crap, but it is not trivial to fix. But the biggest problem with your VS for C++(beside lacking support for ISO standards) is shitty support for testing. I know a lot of antique codebases use VS, but there is a lot of people who want to write modern code in VS and manually setting up tests is irritating. When you make C++ project you should be able to pick one of the popular testing frameworks(Google Test, Catch...) and then have VS do the boilerplate of running tests and reporting coverage for you.
Mm, good point, didn't notice that. But the metaclasses proposal seems a long way away and much harder to implement. What I personally really needed was a way to static print right now, so I wrote this. Maybe it's even worth standardizing in the mean time until we have metaclasses. 
Take a model-view-controller, for example: widgets have children accessed by shared_ptr, and also have pointers to models via shared_ptr. Some models may be temporary, some models may be permanent and exist as parts of other models. In this case, shared_ptr is the only type of pointer serving the requirements. 
Sorry, what?
AMD should make EPYC 7252- 7251 that can use dead cores L2 :D
&gt; C++ has multiple ways of deducing a type that are the same until they're different What do you mean? I don't see that. &gt; it has multiple ways of initializing a variable Not a gotcha by any means. &gt; The comma means different things in different contexts Again, what are you talking about??? &gt; wrapping parentheses around an expression changes its type Nope. &gt; and I'll be the first to admit it's a giant bag of scorpions. I call BS. 
I think they want to extend standard library because there is no good standard package manager for C++ and installing third-party libraries is a pain.
Why does it print '&lt;int i&gt;' ? Also, why does it print 9,8,7,6...1? Shouldn't the sequence of numbers contain multiple occurrences of the numbers because of the recursive nature of the function?
I thought this would be an article about a really cool metaprogramming hack. 🙁
static_print is executed once when the compiler reads the function definition, at which point i has no value, and again when the constexpr execution executes the constexpr function. Multiple occurrences do not happen because gcc caches the result of constexpr function executions with the same parameters.
Also facebook's [small vector](https://github.com/facebook/folly/blob/master/folly/docs/small_vector.md) where you can even change the type of the counters so they are not ```size_t``` but something smaller like ```uint16_t```!
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [facebook/folly/.../**small_vector.md** (master → dedaae9)](https://github.com/facebook/folly/blob/dedaae98309f8412f4fe33d624ce38c344117c73/folly/docs/small_vector.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djptau7.)^.
Doesn't hacking the compiler count as metaprogramming? ;)
we need such a thing - yes please!
You can use it today! Read the instructions on github
Nope. Extending the language is cheating.
There was an [attempt](https://cmake.org/pipermail/cmake-developers/2016-June/028843.html) to document the flags, but it was rejected. Unfortunately the email discussion thread stopped after this email: &gt; I don't understand the harm of documenting the options and making them &gt; public. Brad can you explain? &gt; &gt; I have worked with numerous colleagues who use them. So far nothing bad &gt; happened to them! &gt; &gt; Seems to me that they are &gt; a) used &gt; b) useful &gt; c) safe &gt; &gt; Is there context I am missing?
I was kidding, of course. But - there seems to be no way to achieve this without extending the language, in which case I think extending the language is the best thing to do. I prefer being a cheater with static print than a non cheater without it :) 
I think so, too. This is what would've made someone figuring out a way extremely cool. Cheating is not really compatible with my *at least* 2 compilers rule.
**Company:** [Zivid](http://www.zividlabs.com) -- 3D computer vision, startup, well founded **Type:** Full time **Description:** Zivid creates a 3D video camera for use with robots in industrial automation. As a devloper you need to be versatile. That is the beauty of working in a startup. You will mainly work with C++, everything from low level to GUI, but skewed towards low level. However, you are also expected to tackle most other aspects of software engineering. Linux, Windows, scripting, testing, automation, packaging, cloud services, docker, CI, bindings for other languages and documentation. Or in other words, we are looking for an alround wizards with strong C++ skills. **Location:** Oslo, Norway **Remote:** No **Visa Sponsorship:** Yes **Technologies:** C++14/17 (whatever passes VS2017, latest Clang, GCC, clang-tidy, ...). C++/CLI, GPGPU, Python, Bitbucket pipelines/Appveyor, libclang, boost, Qt, CMake. **Contact:** PM or [e-mail](mailto://mathias.nedrebo@zividlabs.com)
It is a paraphrase of Stroustrup, 'I find using C++ more enjoyable than ever'. 
I would like to see errors in html format, so that you can navigate through them.
What's wrong with unique_ptr and shared_ptr for data communications? I know people who program for real time systems with these (although on a custom memory allocator with pools). [unique_ptr is within 0.3%](http://www.modernescpp.com/index.php/memory-and-performance-overhead-of-smart-pointer) of the performance of new/delete. 
&gt; Everyone wants you to be a pro with STL, Low level optimization, OS APIs, etc... Of course we all want to hire the best programmers. But really there are not so many of them around. And for junior positions, it is often better to hire a smart guy who is eager to learn than someone who thinks she knows it all already. Do not be afraid to apply for positions that seem a little bit out of your reach. At worse your application will be ignored. If you have no C++ experience at all, I would suggest spending some of your free time playing around with it, working on some of your own projects.
I have built a small game in SFML and used C++11 features wherever possible. Now, I am planning to build a project in Qt. I can't figure out how else to learn C++. Doing a masters will hopefully get me working on the specialized areas I listed above. 
Same observation here. `bind` is clearer about the intent of the programmer, easier to read, easier to type.
The problem only comes when you need to transmit data using functions such as send or sendto. You need to serialize the data, provide the address where it starts, and then it's size in bytes. In other words, you need to have a clear idea of its memory footprint. The only advantage that I could see with using unique_ptr in such scenarios is to avoid the need for using delete. But, I never felt that this was an issue for data comms. All you need is to write delete just after send or sendto.
Thanks for the pointer. However... has this "near-standard" solution been actually implemented? It doesn't seems so in at least two major compilers (VS and clang) although the TR is ten (10!) years old. It is not a good sign...
Review provided by PVS-Studio.
I was in the exactly same situation as you in the past. The trick for me is while I didn't had any professional experience in C++ I have done some personal projects with it which the companies cared about, I've also used C++ for my dissertation. I also have tried really hard to find a job in this area, so I've sent a lot of cvs and done a lot of interviews tests before getting accepted (about 6 months with this), so make sure your CV looks good and it's C++ oriented. I'm now "gathering the fruits" of this hard work and I see that companies interest in my profile for C++ development has risen exponentially.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
&gt;&gt; C++ has multiple ways of deducing a type that are the same until they're different &gt; What do you mean? I don't see that. C++ has auto and decltype, which functionally do the same thing: deduce a type give some context. But they do their work differently in corner cases. Furthermore, we also have function template argument deduction, the beast that is decltype(auto), and now in C++17 class template argument deduction. Each of these has their own rules and can trip you up if you're not careful. But they all deduce types. As an example, auto works via similar rules as function template argument deduction, so it strips off leading reference qualifiers, whereas decltype takes the literal type of the expression. It means auto x = (expr) and decltype((expr)) y will deduce different types (notice the parentheses around expr. This plays into my later point, about how wrapping an expression in parentheses changes its type). &gt;&gt; it has multiple ways of initializing a variable &gt; Not a gotcha by any means. It may not be for you, but Scott Meyer's felt it necessary to write a whole section in Effective Modern C++ about this simple issue. &gt;&gt; The comma means different things in different contexts &gt; Again, what are you talking about??? The comma in C++ sometimes has well-defined language-level semantics, as in separating variables in declarations, and passing arguments to functions. In other cases the meaning is completely up in the air since it can be overloaded to do different things when it appears in it's expression-separation context. &gt;&gt; wrapping parentheses around an expression changes its type &gt; Nope. See my above point about decltype vs auto. In fact, it's why, unlike in C, you should never write `return (expr)` in C++. It has a different type than `return expr` which will trip up a deduced return type of the form `decltype(auto)`. &gt;&gt; and I'll be the first to admit it's a giant bag of scorpions. &gt; I call BS. Like I said, I have no intention to snark or start any kind of comment war. I've been using C++ for many years, I have purchased copies of the ISO standards (they're watermarked with my name, so you know they're legit :-)), I've used it for research and development, and I've even helped teach a course on it for about 4 years now. It still catches me occasionally. I'll admit that my use cases might be different than yours. I tend to write a lot of generic "library" code, so I run into issues with type deduction, SFINAE quirks, and, of course, I can never trust `operator ,`. 
The discussion thread did not stop after that e-mail: https://cmake.org/pipermail/cmake-developers/2016-July/028870.html The summary is the dev said "I'd accept a patch to give the options better names" and then, apparently, no one did it. Pipermail/Mailmain split it because it crossed over to the next month.
&gt; As an example, auto works via similar rules as function template argument deduction, so it strips off leading reference qualifiers, whereas decltype takes the literal type of the expression So, there is no gotcha here: auto works one way, decltype works another way. Am I right? I don't see how it is a gotcha. &gt; Scott Meyer's felt it necessary to write a whole section in Effective Modern C++ That doesn't make it a gotcha. &gt; In other cases the meaning is completely up in the air since it can be overloaded to do different things when it appears in it's expression-separation context. It is extremely rare to see an overloaded comma operator. And even if you see it, you have to have parentheses around an expression to validate it as a comma operator when used in context like in arguments. I.e. it works as designed. No gotcha here. &gt; It still catches me occasionally. I'll admit that my use cases might be different than yours. I've been programming professionally in C++ from 1998. Never had any gotcha problems. &gt; I tend to write a lot of generic "library" code I do too. &gt; so I run into issues with type deduction, That area is one that contains a few surprises, but they are not really nasty. &gt; SFINAE quirks, Very advanced topic. 99% of programmers have never done a SFINAE. &gt; I can never trust operator ,. You have trust issues (joking :-)). Operator overloading is not that different than any other form of symbol introduced in the language. I.e. you can't be sure that 'printf' doesn't launch nukes, for example. Let me tell you a real gotcha. MFC has these message maps, where you use macros to pass function pointers to arrays. These macros cast the function pointer to a specific type in order to make the array instances. This casting removes parameter checking by the compiler. For example, if the target function expects 3 parameters and you pass a function with 2, the compiler will not complain (well, it used to not complain, I haven't used MFC for over a decade). That's a real gotcha that only manifests as a crash in the release version. It has resulted in delivering the debug client to the customer, instead of the release version, for a couple of months!!! Now that's a real GOTCHA!!! 
I'm a student studying C++ Games Development at university right now; can you explain or point me towards some reading on why inheritance polymorphism is bad, especially in games? My tutor swears by it!
If you can get "Game Engine Architecture" book, there is a whole section about game objects and ways to manage it. It explains the problems while still clarifying that in simple cases, you might not need to care. I recommend reading this. Then also watch/read "Inheritance is the base class of evil" and maybe some "entity component" library rationals... There is a lot to read about the subject because there is a lot of alternatives. If you are doing a small game, use whatever you want. If you need performance, complex composition and extensibility, try to consider inheritance as a last resort solution (it is useful, but not as a default).
That would save me soooooo much time debugging compile-time failures. I always struggle to understand at which level of nested SFINAE errors I am. Having a foldable hierarchical view of these substitution failure error messages would be a huge improvement.
&gt; companies interest in [...] C++ development has risen exponentially Can you share with us in which area because they are hard to find in Montreal.
Attend the local user groups, might give you also leads to possible jobs. User Group Montreal meets on the 25th July: https://www.meetup.com/CppMtl/
People still use gitter? Trolling aside, the C++ slack channel is where most of the C++ devs seem to frequent now.
&gt;&gt; It was promoted on C9. Channel 9 is a chance for Microsofties to talk about the work they're doing in dev tools. The fact that something is mentioned on Channel 9 should not be construed as a guarantee of a technology's suitability for an purpose. It's just us talking about the work we're doing. Usually that's about features that will end up in VS, sometimes it's about little side projects like this tool. In this instance it was Sridhar talking about something Sridhar thought had some potential. The distinction I am trying to make has nothing to do with Channel 9. It's about the difference between technologies that are distributed in-box with VS (i.e., chained into the VS 2017 installer) and technologies that are distributed through other channels. VS comes with guarantees of support for N years. Microsoft has an incredible history of standing behind developer technologies: you can name 100 exceptions to the rule (Silverlight, VB 6) but it's still a rule. Being incredibly concerned about having to support anything we do for goodness knows how long is what led to our awful three-year product cycles years ago. We've been trying to move faster and open up to the community about what we're doing: shipping VS faster, [providing daily builds of MSVC on NuGet](https://blogs.msdn.microsoft.com/vcblog/2016/04/26/stay-up-to-date-with-the-visual-c-tools-on-nuget/), shipping Technical Specifications such as [C++ Modules](https://blogs.msdn.microsoft.com/vcblog/2017/05/05/cpp-modules-in-visual-studio-2017) as [experimental features](https://blogs.msdn.microsoft.com/vcblog/2015/12/03/c-modules-in-vs-2015-update-1/), etc. There's a fine line between putting something out there because it's cool and signing up to support a tool for 10 years. One key to knowing what side of the line something falls on is whether it ships in VS or not. And if it does ship in VS, is it marked "preview", "experimental", etc? If so, it's likely a preview or experiment. &gt;&gt; In general problem is slowness of VS Yep, we've definitely heard about IDE latency from developers. Big improvements were made in VS 2010 and we've made improvements continually since then. But VS is still a very large WPF app and it shows sometimes. The MSVC team is talking about goals for the next major version. Our dev manager, /u/spongo2, has already mentioned that VS performance (something we contribute to, but don't control) and IntelliSense reliability (something we pretty much own end-to-end) are big goals for continued improvement in the next cycle. &gt;&gt; But the biggest problem with your VS for C++(beside lacking support for ISO standards) is shitty support for testing. With regards to conformance, I hope you're aware of the [steady progress](https://blogs.msdn.microsoft.com/vcblog/2017/03/07/constexpr-and-aggregate-initialization/) we've been making on the [harder features](https://blogs.msdn.microsoft.com/vcblog/2016/11/16/sfinae-update/) of C++ since we started our [compiler parser rewrite](https://blogs.msdn.microsoft.com/vcblog/2015/09/25/rejuvenating-the-microsoft-cc-compiler/) a couple three years ago. We plan for [MSVC to be fully C++17/14/11/98 standards-conforming in 2017](https://blogs.msdn.microsoft.com/vcblog/2017/03/07/c-standards-conformance-from-microsoft/) with the nasty exception of not yet having completed our conforming preprocessor and the sad reality of bugs plaguing some of those hard features. Still, I'm quite proud of the progress we've made on standards conformance as of late. I think you can admit that times have changed. On testing support, /u/augustinpopa has been looking into improving our unit testing support. He's talked publicly about [improving our built-in native C++ unit test framework](https://blogs.msdn.microsoft.com/vcblog/2017/04/19/cpp-testing-in-visual-studio/) but he's actually interested in taking Visual C++ unit testing into a whole new direction. He'd probably love to chat with you if you've got time for a phone call. PM him if you want to chat. Thanks for reading this long response, and thanks for the feedback! Let me know if I missed anything. 
Like in static_assert I would add another argument for boolean is enabled/disabled. This will make wrapping with macro uneccessary.
Well, I'm betting on the quality of the relationship, not the number of people I would like to gather a small circle of people with common interests =) This, if I may say so, the family or something like that
First list of speakers will be released by next week...
&gt; Why is my only option to get into web development? Because there are more companies want web app than c++. Most web app make money and C++ is for internal apps or low level stuff. Web app require less capital/money to start and the barrier is smaller. Web app is also OS agnostic where as C++ app actually give a damn about the OS. It's also the reason why Google beat Microsoft for search engine. Microsoft was in the mindset that they control everything cause they own the OS where as Google realize that web app are OS agnostic and eventually the cloud killed Microsoft strangle or gate keeping really. Which is also the reason why Microsoft didn't much much emphasis on the internet and Google end up being a huge dominant player while Microsoft is playing catch up. &gt; The only places that have junior positions that incorporate C++ are game dev studios. Do that then if you want C++ on your resume. &gt; There are so many interesting fields with C++: HPC, Computer simulations, FinTech, Computer vision, Graphics programming, etc... If you don't have any project or experiences in those field and they aren't willing to take a junior position or willing to teach you while you work at the company then you're outta luck. You either take a junior C++ in a different industry such as video game (it's a shit industry imo, at least in USA) or you do whatever you're doing now and do side project with C++. &gt; Is doing a masters the only way to get in to these specialized industries? Assuming your master was tailor to the industry you wanna go into then sure. It'll make your resume look much stronger than if you're lacking. Especially your thesis topic is on those industry domain. It's the only reliable way I know of at least. &gt; I don't have to write JavaScript for a living. Javascript is fine unless you are doing NodeJS *shudders* imo. 
So where's the review? Where are the metrics, comparisons of bugs found by each tool, etc.?
This is a great idea. Any way to have it print a stack trace? Not of gcc, but the current meta stack.
This isn't C++, it's C++/CX.
Thank you! I'll definitely look into the book after I'm done with Effective C++.
&gt; One possible way out of this is to have reference implementations of system-independent components. Its not like we didn't have reference implementation of even system dependent stuff, like mentioned std::thread, in boost library. In fact, i believe that boost is mature enough that making it official staging area for inclusions to std library would be a good idea.
Can this be achieved without patching the compiler? 
Oh dear. Doing basic string operations in C++ is not very fun.
You could cause some warning to show a message without stopping compilation but it wouldn't be as concise (Strings would have to be represented as separate characters) and I'm not sure it would even show up exactly when the code is compiled.. 
Please let me know your reviews on this article.
Probably possible, but I wouldn't want it to print a stack trace by default as it can jumble up the output pretty quickly. I'll see if I can add some sort of a flag. 
You could disable all static_prints by defining a macro named static_print which compiles to nothing. 
&gt; Multiple occurrences do not happen because gcc caches the result Standardizing behavior of this 'function' isn't gonna be very fun, i imagine ;) Edit: could this be written as a gcc plugin?
Oh I did not mean to insinuate that your library was buggy -- just that the huge proliferation of these types of libraries suggests a major shortcoming in the standard library.
Is it 2010 again?
Sorry, didn't got you.
In C++ 11 introduction of lambdas made functors effectively obsolete. They may still show up here and there, but this should be rare.
I disagree with the implication that every compiler has to implement the entire standard library; some, like io2d don't even make sense on something like an embedded platform. Also your claim that Python only has one implementation is just plain wrong - there are multiple in use, and as far as I know none of them other than CPython implement all standard modules, which doesn't mean they're not used - just check out MicroPython. The language is merely a reference, not the law.
Yes. I agree that functors are obsolete, but at times they provide more flexibility then lambdas. Also, lambdas are sort of syntactic sugars for functors. So understanding functors makes sense before learning about lambdas. What do you say? By the way, I planned to write about lambdas once I complete basic functors.
For me only clang-tidy and maybe cppcheck exists.
The GCC linker also supports `--just-symbols=symbolfile` which allows you to define symbols at specific addresses one line at a time symbolname = 0x12345678;
Can we get the same for Clang as well ? 
Clang's scan-build seems like the best option here - why install/update etc an additional piece of software?
I'll check out clang next week, don't know how difficult it will be to implement, hopefully not too bad :) 
I saw many python programs and their developers often don't care about compatibility with python 3.x and none of them ever cared about compatibility with non CPython variants. Why would they? Why would a sanely python developer restrict himself to a subset of python standard library just to make his app compatible with some rarely used python implementation. Isn't this example of python demonstrate how difficult it is to develop an alternative implementation of the language (plus standard library) when the standard library is huge? &gt; I disagree with the implication that every compiler has to implement the entire standard library How so? The standard conformance require that not only language but also the whole standard library is provided. What is the value of a standard if it is ignored? Compilers which do not provide the full standard library are allowed to exist but they should not claim conformance to that standard. We developers should be able to rely on existence of all standard library components when we target certain C++ version. I don't think the C++ standard has optional parts.
The current preferred term is functional objects, not functors anymore, because functors is a really strong term from functional programming, which is unrelated to C++'s functional objects/functors.
&gt; But ultimately the compiler is not a goal on itself, it is there to support a much, much larger programming community. And all those people will be helped by having a powerful standard library. Absolutely true. The devs who use python, php, etc. would laugh on us if they would knew how difficult for us is a task of downloading something from a web-server. We either have to implement that from scratch using sockets (which are not part of C++ standard either) in a platform dependent way, etc. Or we need days to evaluate existing libraries (some of which may not be supported anymore or may have extra dependencies). What a pain. Yes, as developers we want a comfortable standard library. But do we really need multiple implementation of for example http-client or json parser? I don't even talk about how many years it would take for committee to develop a standard for http-client or json-parser.
Or 'function objects'.
This is an incomplete solution because that only works if all your dependencies are built with cmake as well. Otherwise you have situations where you are trying to link to library files that don't exist yet. You can instead hack ExternProjectAdd() to build you the dependency during configuration (and this supports more than just cmake) Or use an actual build-from-source package manager.. but that's not as crossplatform-y
How is gitsubmodule a solution? It doesn't provide any build information (ie. What autotools/cmake/make/compiler flags u need)
Also... `compiler.error()` is an error, not that helpful for tracing :(
Besides HPC, FinTech, and High Frequency Trading (HFT), think computer vision, embedded systems (SoC's like Xilinx Zynq), and robotics.
(old post deleted. Discord is much better than gitter)
Well, I don't see it that way, the techniques that he used there could be applied to ptrs and maybe an introduction to smart pointers for people who come from the GC world
!automoderator
The focus is on the former, starting by the title.
I think its incorrect approach educating new people - you will quickly hit the wall of too much content. I mean, when you tell someone how to do hello world in C++, you don't start with Koenig lookup. Its important to explain those things imo, but often not immediately necessary.
Include information about visa sponsorship plx
@VS/C9: I am not getting into "lawyer stuff" here, I know you are technically right, my point is that launching minimal working prototype to get feedback is not all pluses. If your customers have a shitty experience with the tool it is a bad thing, and I feel a lot of companies, not just MSFT do not give enough weight to that fact. So consider some intense internal dogfooding since after all you do have huge number of C++ devs writing many major products for you in C++. Regarding VC++ compliance: honestly I am surprised how compliant VS 2017 is since I still remember the disappointment of the days when dev stayed over weekends to implement range based for loop and Herb was announcing not supporting variadic templates... :) But also to be fair ISO made your job easier by making C++17 pretty minor release. Regarding testing I am not a big fan of talking to people, and also I do not consider myself an expert in testing, so I will just leave you a couple of user stories of what I would like to have in VS 2019 :) Note I never did any managed development so I guess C#/Java devs are probably better people to tell you how to do this, but here we go: 1) As a user creating new C++ project I would like to have an option to select among at least 2-3 most popular frameworks(GTest...) when creating my project. This framework is now integrated with the project and user does not need to manually create other project or testing_main.cpp just to test this project. 2) As a user of a project using test project integration I would like to have an option in the context menu of a project to add a triplet of files(foo.h, foo.cpp, foo_test.cpp). VS would automagically insert needed headers in foo.cpp(foo.h), foo_test.cpp(foo.h, test framework headers). 3) As a user writing code I would like to know current test stats, coverage, and maybe I would be particularly interested in tests that used to pass and now fail, since if we assume TDD at the beginning all the tests are failing and as you implement code less of them start failing so newly failing test is more "weird" than test that was always failing. 4) As a user reading the test results for a newly failing test I would like to be able to quickly know the source diff between the code for which code is failing, and the code for which code was passing. Anyway this is all quite simple(from what I call greedy customer perspective), but I understand it is super hard to implement stuff like this, for example 4) basically means version control + diff, 1) means making a stealth main that will run cpp tests... So I hope this was helpful, if you or somebody else have some complaints/better ideas I would be happy to hear them. BTW if you need some more insane code to test the compiler: https://www.youtube.com/watch?v=HMB9oXFobJc (note that they used pretty recent compiler to compile their project so if your compiler rejects something it may be right in a sense that maybe GCC did not implement something fully). 
It seems to be a library-based solution, so I'm not sure what the compilers are supposed to implement. The point is to act as a mostly-uniform facade, sitting inbetween the "magic" compiler backends implement for hardware access, and hardware-dependent software components.
Holiday weekend here, sorry for the delay. First, a clarification on "performance" (not that anyone on this thread's gotten it wrong, just a standard disclaimer.) Code quality (CQ) is the performance of the app that the compiler generates. Throughput is the performance of the compiler itself--"compiles/day" in this article. Note that in most cases, more of a compiler's throughput performance than CQ performance has to do with other issues than processor speed. Often disk I/O or memory speed will dominate. My understanding is that the optimizer team tracks CQ for individual processors, and throughput on some generic reference machines. I've seen quite a few Ryzens floating around in the halls so I'm sure we're testing CQ for Ryzens but I don't think anyone's noticed throughput issues with Ryzens. I've asked for a more specific answer from those who own our perf but, as I said, holidays here in the US. 
1. We need a package manager. 2. The standard needs to contain _vocabulary types_. Those types that you pass in and out of libraries. We just added some important ones: string_view,optional/variant/any. I think there are still a few more. 3. Anything widely useful but platform specific - threads, file_system, etc. Process handling? Networking? 4. Anything platform independent, but that we all end up writing over and over again. For example, a good meta-programming library. We could grab one (of many) from the mythical package manager, but I'd rather only learn one that we all use, instead of 5 different parts of my company are using. Also, the standard library would use the same MPL internally. But not just MPL stuff - anything that is "Oh, I've written that a dozen times, I re-write it every new project". Even with the best possible package manager, I think there is still value in having libraries. A good date-time? It is a fundamental data type (see 2 above). It is also hard (impossible?) to get right. UTF8. It should just be assumed. Any new language just starts from there. I'd like (right now) something like QVariantMap. or a JSON-like data struct - not a parser, just the data object that contains numbers, strings, lists and maps. Maybe once we have reflection this isn't needed, but I think it is. It is a generic and useful thing.
It seems like you are trying to make a kind of "tutorial" for C++ newbies, is that correct? Similar to how you should start with smart points before going to new and delete, I think teaching (anonymous) functions before Functors is the right way. Then you can also highlight the cases in which a Functor can be used to do something that a normal function cannot.
Really fun talk, fascinating to learn libc++ started off as a hobby project.
&gt; How is the situation looking for the UFCS proposal, (either bjarne or Sutters versions) Last I heard, using `a.foo()` to call `foo(a)` was not looking likely whatsoever because given the complications with existing lookup, the focus was on writing generic code once instead of twice. However, `foo(a)` to call `a.foo()` also seemed kind of stopped in progress IIRC, so I'm hoping that at least an alternative call syntax proposal like `.a.foo()` goes through. There are concerns about being able to change a class's interface, though I will say this kind of thing has worked well in other languages. I'd recommend looking up some trip reports from the last meeting because their detail will be better than my memory. &gt; Do any IDEs do the opposite `foo.a_` `a_(foo`, autocomplete Resharper C++ (including listing free functions in the autocomplete window before the transformation when you select one). That's all I know of. 
In the D language this is: int square(int i) { return i * i; } pragma(msg, "the square of ", 2, " is ", square(2)); 
So why'd it get so much faster when you forced the `string` return in the lambda?
Thanks! They're blaming the spam filters and saying they fixed it.
The rpi project: I discorage win10 because I heard its very bland and slow. I'd recommend using the basic Rasbian installation. You can write a GUI using X11 (Xlib). Here are some references for GUI: http://www.tldp.org/LDP/LG/issue78/tougher.html and GPIO http://www.hertaville.com/introduction-to-accessing-the-raspberry-pis-gpio-in-c.html in c++ But I recommend creating something on a windows machine without IoT stuff. This way you can focus on the actual development. Think of a simple program you like and try to remake it maybe. or remake a game like snake. Their are a lot of tutorials online for game development and Qt (Qt is a cross platform software development API). Or think outside of the box and make something with https://github.com/cristianadam/io2d. But that might be a bit harder since their is almost no info on this. (It is a ISO proposal for 2d graphics.) (You can for example make a UI library with this.) Remember when developing for the first time Google is your friend.
Yep, I view you as non-shadowbanned now. Welcome back to the realm of the living.
&gt; There are concerns about being able to change a class's interface, though I will say this kind of thing has worked well in other languages. I thought this was the entire point of UFCS in things like D? I want to be able to add methods to, for instance, std::string in C++. The ability to extend the library without modifying vendor-specific headers is pretty appealing. Something like string_view could have been shipped as a library rather than a language feature that way. Rust blew my mind when I imported a 3rd party crate and it added functionality to standard library types. C++ needs this, and UFCS was one way there. The "as" syntax in the metaclass proposal is another way, though less convenient as it requires creating a new type (and that restriction probably makes it just as bad as current methods).
&gt;&gt; The ability to extend the library without modifying **vendor-specific** headers NOW it makes sense - why it's being blocked...
Depends what you want to do with the pi. Qt is a good option if you need basic desktop UI(widgets) or touchscreen like UI (QML) in C++. Qt is also strong in embedded, so it would be a good choice for you.
I would love the functionality, having used C# where extension methods are a thing and the IDE shows me which calls are extension methods. That said, the point of UFCS from the committee's POV seems to be generic code. Instead of having some types with `.foo()` and some with `foo(...)` and generic code having to pick one or resort to extra work to handle both (including hacky things like `std::begin/end/swap` and newer ones like `std::empty/size`), we just use `foo(...)` and it'll find both without the programmer doing all the work to look for both. For that purpose, it's fine. However, there's another common purpose within the community that isn't this either, and that's to encourage writing free functions when possible. Free functions don't have access to private members of a class, so exposing most of the interface as free functions is good form. However, it leads to this giant divide in syntax and having you essentially guess which functions are members and which aren't. UFCS would also solve that nicely with just the `foo(...)` form. However, the third motivation appears when you do that. `foo(bar(baz(...)))` is hard to read. You have to read outward. Remember all the flak C declaration syntax gets for that? Composing function calls with this style just doesn't work, and having the other way for UFCS would solve that. None of those motivations are to extend a class's interface without being the author of the class. Having the IDE show you extension methods vs. members differently is harder in C++, too, because not all of the interface is inside of the class. Perhaps IDEs could distinguish based on the namespace containing the function. Either way, it's really nice being able to see that something is there as an extension, not part of the base code itself, and I'd love the feature even more if I could have that through tooling. All of what I've said here plays nicely with an alternative syntax like `.a.foo()`, too, so I hope that idea gains traction because it's not a big deal to have an explicit calling syntax that reads almost identically.
Please read the sidebar; this question is off-topic.
&gt; None of those motivations are to extend a class's interface without being the author of the class. That's unfortunate. I wouldn't accuse the standards committee of being out of touch, but they certainly don't ever seem to have the same view of the needs of the language as I do. The tooling issues would be challenging, yes. But I think the benefits would far outweigh the challenges. Just an example... I'm stuck in a situation here where I can't use string_view or create my own equivalent until I can convince the rest of the organization to upgrade to vs2017, whereas I could just do it myself if I could add public methods to std::string. (Although UFCS might not extend to conversion operators...) We also have an entire std::string public API that corrects a lot of usability issues in the library one, but it is a pain to use because of the composition issue you mention. Less of a pain than the exposed API, but still. UFCS was my only hope for this, I hope it's not dead.
[removed]
Keep in mind I'm not part of the committee and I haven't attended meetings (though I thoroughly enjoy reading trip reports), so take what I say about the committee with a grain of salt. What I have to go on is mainly trip reports.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6kza5i/how_do_i_get_my_foot_in_the_door_with_c/djqqisn/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; I'm stuck in a situation I'm sure thats the point. The standards committee probably has people who have a vested interest in keeping control of certain libraries, certain headers, or tools for workarounds. UFCS would solve problems, but some people out there earn a living by *creating* problems; They are probably vindictive individuals who are getting their kicks out of our frustration.
&gt; All of what I've said here plays nicely with an alternative syntax like .a.foo() that would be better than nothing but IMO it would be better not to take additional syntax space; surely a nicer compromise would be UFCS as an opt-in (e.g. deliberately enable it for functions with explicitely named ```this``` , or some other means of declaring 'extention methods' like Rust's impl-blocks). "not knowing" when you see the function call doesn't matter at all. we already have members, virtuals, inheritance; not knowing about the implementation *is kind of the point* (the ability to change implementation details without changing user code); and we've got established IDE tools which can do all the lookup solidly.. over hover something, get jump-to-def or top information ; people who don't like this sort of thing could use a simpler language than C++, or a subset (it would be easy enough to disable features on a project by project basis)
The difference between this and virtuals is static dispatch vs. dynamic dispatch. However, it's not the implementation I'm talking about, but the fact of knowing that this function is not usable without pulling in an extra library - that I can't go around saying "I saw some code that used this member function, so you could just use that to solve your problem" because the person I'm talking to might not have the library providing that extension. In any case, this will probably be better in C++ than C# because C++ people tend to explicitly qualify everything instead of pulling in a whole namespace. It was only recently that C# had the ability to do `using static Foo.Bar.LinqExtensions.MinBy;` (syntax might be slightly incorrect), pulling in a single method and naming it before use. Otherwise, there was no way to tell without IDE help, background knowledge, or documentation whether a method came from `LinqExtensions` or LINQ itself. All that said, we do technically have a similar situation already: UDLs. Nobody imports UDLs without bringing in a whole namespace, honestly. I haven't seen people add UDLs for others' types very often, but if that happens, it does present a similar situation to extension methods.
My best guess is that because the std::string gets constructed at the return statement, the compiler has access to all information of that constant character array. Which probably allows it to do some optimizations like not having to calculate the string length at runtime which it has to do when having the single construction site based only on a const char*. EDIT: https://godbolt.org/g/JXgAUk Both clang and gcc do not call strlen in the faster version.
Yes. I am trying to create tutorial for newbies. Thanks for your suggestion. I will add anonymous function tutorial before this this. I really appreciate this.
Re: the tool, yes, I agree. It's a judgment call with any technology as to what's a reasonable "minimum viable candidate"--both code and testing--to release in any form. This particular tool maybe didn't get enough scrutiny. I wasn't involved with it. Re: compliance/conformance: thanks! We've been working our butts off. Re: Test feedback: good comments, thank you. I know /u/AugustinPopa will be reading them. 
&gt; &gt; The ability to extend the library without modifying **vendor-specific** headers &gt; NOW it makes sense - why it's being blocked... Conspiracy Theory ™ 
I've heard examples of this happening for other language ecosystem issues. Given there are options where any project could easily ban it (e.g. , it could be added behind a compiler flag to disable it, or the 'explicit this' idea could be easily searched for and a build script could reject it) ... i don't see any other reason to deny people this feature, other than some genuine **malice**
Yes, it looks like a library, but due to the interactions with the compiler and the knowledge of the execution environment, it's a library that must be provided by the compiler vendors.
Just out of curiosity, wouldn't you be able to achieve the foo(a) -&gt; a.foo () conversion using a trivial helper function? Something like template&lt;typename T, typename Args...&gt; auto foo (T t, Args ...args) { return t.foo (args...); } Why does something that is mostly intended as a convenience feature for library authors, and that appears to be solveable using three lines of code, need a language change? 
Thank you. I have looked into it and will look further into QT. I'll be developing in Visual studio and remote control the raspberry pi over SSH. Would I be better of if I tried to do it in C# or maybe in an android environmen - just curious. Thanks again
Thanks for your reply I would like to make it for touchscreen so this was helpful (:
The standards committee is full of people who cares deeply about the language and are most certainly not trying to create any problems. Some see UFCS as great, some see it as harmful. Both sides has valid points. If you care about UFCS then the best way is to implement it in clang or GCC and demonstrate that it doesn't cause the issues people are worried about.
&gt; The standard conformance require that not only language but also the whole standard library is provided. It doesn't actually. Freestanding implementation is a thing (unless they dropped it after C++11, i didnt track the pdf since very closely).
Iterators are great for low-level programming; no argument here. But the lack of a high-level 'enumerable' interface makes any sort of iteration that's not based on linear memory traversal really annoying. For example, try writing a binary tree iterator: you'll end up with an unreadable mess. (Compare with C#'s `IEnumerable` for readability.)
Remote or not?
Onsite
Thank you for spending time to review my posts... :) Also here is another small bug I hit today: http://imgur.com/a/Bsw0F Obviously repro is impossible(it appeared while I was typing to add&lt;optional&gt; header), but if you put some asserts/logging in the internal dogfood of next version I believe you will be able to catch it(assuming there is noting specific about my Win10/VS installation).
[removed]
Your post has been automatically removed because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6l61yn/made_a_discord_server_for_c_help_come_here_to/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
that's why we have the coroutines ts ;)
Yeah I would use C# over C++ since C++ is just harder to use and especially if your a beginner. Use the language your most familiar with and has lots of libraries already pre-written to do this kinda stuff.
Fine, it's cool you can do this, but in the end it's yet another "cool thing" you can do in your c++ code that will drive your colleagues insane when they have to read it.
Hi Andrew, thanks again for your reply! I really appreciate having the ability to speak to the people working on my everyday tools (at work and at home). Major props. I would definitely be interested in hearing anything you get back from the optimizer team - there's of course the idea that new CPU architectures require specific optimizations (esp. given the ubiquity of Intel CPUs thus far), so I do wonder if there's anything planned, if it's at all required. I've also heard talk of Ryzen suffering on MSVC compared to other compilers, but it's all heresay at this point. Would love some numbers, but I know that's hardly practical for you guys... hopefully someone out there benches this! EDIT: That's not to say that the CQ isn't also of great interest to myself and many others (particularly in games). A Microsoft blog post talking about any work being done to support the new Ryzen architecture (both throughput and CQ) would certainly go down well, heh.
So, to summarize. With exceptions: auto result = f4 (f3 (f2 (f1 (3), f1 (4)))); But hey, exceptions are difficult and slow, so instead we should be using: boost::optional&lt;int&gt; result = f(3) &gt;&gt;= [=](int b) // b is the result of f(3) if it succeeds { return f(4) &gt;&gt;= [=](int c) // c is the result of f(4) if it succeeds { return g2(b, c) &gt;&gt;= [=](int d) // and so on { return h(d) &gt;&gt;= [=](int e) { return h(e); };};};}; Oh, that's _such_ a leap forward. We're still skipping a kilometer and a half of boiler plate here, but we'll let that slide. And people wonder why C++ has a bad name in some places... 
There's also `auto_gcroot` which does this for you... except that it also emulates the sad release-on-copy behaviour of `auto_ptr`. So, a `unique_gcroot`? Edit: Whoops, C++/CX not C++/CLI.
With `co_await` it becomes: f4 (co_await f3(co_await f2(co_await f1(3), co_await f1(4)))); Not too bad (but the `co_` prefix is abominable)
Well, exceptions do not force you to handle them. Using monadic composition forces you to explicitly handle the case where the optional is empty and where the optional is set. Boilerplate is there because the language doesn't provide a shorthand notation for lambdas or UFCS, but there are proposals to fix that. It's a language limitation that prevents useful patterns such as the one described in the article from being viable. Imagine, with UFCS + shorthand notation: boost::optional&lt;int&gt; result = f(3) .map([=](int b) =&gt; f(4) .map([=](int c) =&gt; g2(b, c) .map([=](int d) =&gt; h(d) .map([=](int e) =&gt; h(e))))) 
It seems like you picked *the worst* example to demonstrate the usefulness of this pattern. Even with exceptions, we have a pretty complicated series of nested function calls that is difficult to reason about. And even in Haskell, this takes some thought (I think this is right?): do a &lt;- f1 3 b &lt;- f1 4 (f2 a b) &gt;&gt;= f3 &gt;&gt;= f4 But you could at least simplify the optional example by not creating lambdas to wrap functions that themselves already have the correct signature: auto result = f(3) &gt;&gt;= [=](int a){ return f(4) &gt;&gt;= [=](int b) { return (f2(a,b) &gt;&gt;= f3) &gt;&gt;= f4; };}; That's shorter by half. With abbreviated lambdas: auto result = f(3) &gt;&gt;= a =&gt; f(4) &gt;&gt;= b =&gt; (f2(a,b) &gt;&gt;= f3) &gt;&gt;= f4; That's close to Haskell, but... still not super readable or compelling. I would just write it out: auto result = [&amp;]{ auto a = f(3); auto b = f(4); return (a &amp;&amp; b) ? f4(f3(f2(*a, *b))) : nullopt; }(); That's not so bad. Edit: I always want to type `==&gt;` instead of `&gt;&gt;=`... 
You're not forced to handle the optional fail case either, but there you'll get UB while not handling the exception just causes it to neatly propagate. 
This is misuse of `std::optional`. You should use `operator*` only when you are sure that the `optional` contains a value. You can argue that not handling the exception is misuse of exceptions as well, but I think the `optional`does a much better job at localizing and representing the idea of a "null state" through the type system. `std::optional`'s API is unfortunately not as safe/useful as it could be. This is one of the reasons I created the library [`scelta`](https://github.com/SuperV1234/scelta), which allows you to pattern-match on both `variant` and `optional` without any runtime overhead. E.g. boost::optional&lt;int&gt; o = whatever(); scelta::match( [](int x) { /* case where `o` is set */ }, [](scelta::null){ /* case where `o` is unset */ })(o);
Your post has been automatically removed because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6l6zzz/need_help_switching_to_working_fulltime_as_c_dev/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Typical lisp
Monad means everything should be captured in optional. So does it cause much overhead? Is there any benchmark?
What do you mean by "everything should be captured in optional"?
How does `co_await` know what to do there?
If you want to write Haskell code, then you should be compiling with `ghc`, not `g++`. Don't get me wrong, there's nothing wrong with Haskell code; it's a really interesting language, and I've enjoyed using it. But this isn't really the style of C++. With the exception of streams, which plenty of people think was a bad choice, C++ doesn't overload operators in ways that doesn't fit with their original usage. Haskell can invent new infix operators on the fly, so there's no reason not to create a new one for whatever purpose you need. In C++, it makes the code much less expressive. No one without a Haskell background will understand what `&gt;&gt;=` means, but a member function would be able to impart some information by virtue of its name. Regardless, there is already a proposal to add monadic error handling with the `expected` class. [This is an older proposal](https://github.com/ptal/expected), there's a more up-to-date one that I can never find with Google.
Targeting simplicity is great but no one wants to run commands without an idea of what the command line arguments you're blinding pasting in are supposed to do. So I was quite surprised to find that my cmake reference documentation didn't mention either flag, and then had to do some additional searching to figure out what was going on -- it turned out not to be simple from my end! ;) As someone who has used cmake since before we had "modern C++" I just think that it's not prudent to rely on features that are explicitly described as internal to the compiler. They change things all the time and ingraining new users with flags that may break 2 versions from now does not seem particularly helpful.
And ExternalProject_Add() is not perfect because it doesn't propagate your current build environment (full toolchain information, compiler switches) to the project to build. Same for most build-from-source package managers. Build wise, the perfect solution is to have it all build in one big CMake project, but then you may have to provide CMake build scripts for some dependencies yourself. It's not that big of a deal for most libraries fortunately!
I must admit I don't understand exactly how Coroutines TS manages to relate `co_yield` and `co_await`, particularly because the 'await' part, as least in my mind, typically implies asynchronous execution. What I mean is, if some function yields, it should be possible to consume it in a range-based `for` loop without having to modify the code that actually consumes. Something tells me this isn't the case here.
Huh.. well I guess that's a solution to. Wrapping up autoconf or make in cmake somehow. Do you have any examples? Wouldn't know where to start
Most importantly even in haskell I wouldn't use most of the monads weren't it for the sweet do-notation...
Ohhh, i fully agree with you. But there are a lot of developers, who think, that STL should be small and compact. WHY??? I don't understand, why developers think in this way. IMO, STL should be comfortable, not compact.
There are trade offs in both. Personally I think exceptions win, particularly if the different functions can fail for different reasons and you want to be able to be able to react differently. But I can see both approaches having a place in the toolbox. Lovely library by the way!
No, thanks
This monad is so ugly I'm not sure you can still call it a monad...
You can start by using the standard algorithms. In 1.cpp, instead of a raw loop and an if, you can do iota then remove_if then accumulate.
[wg21.link](https://wg21.link/index.txt) to the rescue: [P0323R2: A proposal to add a utility class to represent expected object (Revision 4)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r2.pdf)
Quite welcome. I firmly believe that developers at Microsoft should be more in touch with developers who use our tools systems. We've made a lot of good changes at the corporate level but I still have to do my part. As for the autocomplete/autosuggest issue....sigh. Thanks for the report! /u/AugustinPopa, paging you again :)
I'm always happy to chat directly with developers. I've stuck an entry in our "blog post ideas" OneNote page that links to your comment. I can't promise anything--some teams blog more freely than others--but I will certainly push to get a post about optimizing CQ and throughput for various CPU designs. 
&gt; like every variable being auto ...this seems like a bad idea?
The "raison d'être" of exceptions is exactly that they don't force me to handle them. For a **vast** majority of errors, there is no "handling", but rather, cleanup of any temporary state and such, which is done through RAII. "Handling" is usually done only several stack frames later, and even then, most of the time the error is just reported. This is why I believe yours and other attempts are doomed to fail. It's never as simple as exceptions and does not accept the observed ways in which code runs. And don't even get me started on the inability to inform about the various failure modes with a mere `optional`. Even a `result ` with `error_code` is not enough.
I havent watched this yet, but i definitely will. This sounds interesting AF
&gt; demonstrate that it doesn't cause the issues it's all subjective; implementations are demonstrated in D,C# I'm mostly on the same side as Bjarne in this particular debate, but he disagreed with my compromise suggestion "ok, lets making it an opt-in per function declaration" - he says that makes the feature harder to teach or use. other than that, both the opt-in and 'raw proposals' are already demonstrated in other languages - C#, D. So what people are doing is taking a stance on preferences against this feature.. "*I* don't like it, so *no one* should have it.". One thing that seems to happen here is people also rally against the 'a.foo(b)' style altogether. There are some that want to move everything over to foo(a,b) calling style (e.g. including methods) with the 'other half' of the UFCS proposal. That loses the existing state of IDE tooling which is "dot" oriented. This is a strange one.. some people have started to associated a.foo(b) with OOP hazards, hence they don't want UFCS /* which fixes those hazards*, letting us get the chaining and IDE benefits *without* the OOP baggage.
Very well explained tutorial, will probably watch all of it.
It's just writing regular CMake files to build a library instead of the orignal library's autoconf or other build script, I don't understand what you are looking for there.
Well done. I watched videos 1 &amp; 2... That's all that's up now right?
Seems like the rest of the videos are behind a paywall
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6l7mgt/some_project_euler_solutions_for_helping_me_learn/djrylqj/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yes, I invested over 200 hours of work into creating these videos (+exercises). So I hope to earn at least some money with them. :-) For anyone interested, I just created the coupon code [REDDITCPP20170705](https://www.udemy.com/functional-programming-using-cpp/?couponCode=REDDITCPP20170705) which reduces the price from 25$ to 10$.
This suggestion is less intuitive and slower than op's current solution. int main() { int answer = 0; for(int count = 0; count &lt; 1000; count++) { if((count % 3 == 0) || (count % 5 == 0)) { answer += count; } } std::cout &lt;&lt; answer &lt;&lt; std::endl; } Whats the problem with a "raw loop"? There are way harder problems in programming than writing a basic for loop. That series of 3 algorithms requires memory, and loops through it 3 times. I assume this suggestion would also want to use a `std::vector&lt;int&gt;` instead of just a `int a[1000]` when the problem specifically asks for the first 1000 numbers. Good work OP, ignore this suggestion. 
&gt; There is almost no reason post C++11 to use std::bind. `std::bind` was introduced in C++11
Yes, the other 25 videos are only [available on udemy](https://www.udemy.com/functional-programming-using-cpp/?couponCode=REDDITCPP20170705).